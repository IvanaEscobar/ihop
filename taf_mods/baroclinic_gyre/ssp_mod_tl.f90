!                           DISCLAIMER
! 
!   This file was generated by TAF version 6.8.11
! 
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
! 
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
! 
module     ssp_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use ihop_mod, only : prtfile

implicit none

!==============================================
! write visibility
!==============================================
private
public :: evalssp
public :: evalssp_tl
public :: initssp
public :: setssp
public :: setssp_tl

!==============================================
! declare parameters
!==============================================
integer, private, parameter :: cachelinesize = 256
integer, private, parameter :: comm_get = 4
integer, private, parameter :: comm_msg = 2
integer, private, parameter :: comm_none = 1
integer, private, parameter :: comm_put = 3
character(len=*), private, parameter :: commentcharacter = '#'
integer, private, parameter :: debleva = 1
integer, private, parameter :: deblevb = 2
integer, private, parameter :: deblevc = 3
integer, private, parameter :: deblevd = 4
integer, private, parameter :: debleve = 5
integer, private, parameter :: deblevzero = 0
double precision, private, parameter :: pi = 3.14159265358979323844d0
double precision, private, parameter :: deg2rad = 2.d0*pi/360.d0
character(len=*), private, parameter :: error_header = ' *** ERROR ***'
integer, private, parameter :: exch_ignore_corners = 0
integer, private, parameter :: exch_update_corners = 1
integer, private, parameter :: forward_simulation = 0
integer, private, parameter :: gsvec_size = 1024
double precision, private, parameter :: halfrl = 0.5d0
double precision, private, parameter :: halfrs = 0.5d0
integer, private, parameter :: ihop_max_idw = 4
integer, private, parameter :: ihop_max_nc_size = 15
integer, private, parameter :: ihop_max_range = 6
integer, parameter :: ikind1 = 8
integer, private, parameter :: index_i = 1
integer, private, parameter :: index_j = 2
integer, private, parameter :: index_k = 3
integer, private, parameter :: index_none = 4
integer, private, parameter :: lshare1 = cachelinesize
integer, private, parameter :: lshare4 = cachelinesize/4
integer, private, parameter :: lshare8 = cachelinesize/8
integer, private, parameter :: max_len_fnam = 512
integer, private, parameter :: max_len_mbuf = 512
integer, private, parameter :: max_len_prec = 200
integer, private, parameter :: max_no_threads = 4
integer, private, parameter :: max_num_comm_modes = 4
integer, private, parameter :: olx = 3
integer, private, parameter :: max_olx = olx
integer, private, parameter :: oly = 3
integer, private, parameter :: max_oly = oly
integer, private, parameter :: maxssp = 201
integer, private, parameter :: mpi_2double_precision = 1275072547
integer, private, parameter :: mpi_2int = 1275070486
integer, private, parameter :: mpi_2integer = 1275070496
integer, private, parameter :: mpi_2real = 1275070497
integer, private, parameter :: mpi_address_kind = 8
integer, private, parameter :: mpi_aint = 1275070531
integer, private, parameter :: mpi_any_source = -2
integer, private, parameter :: mpi_any_tag = -1
integer, private, parameter :: mpi_appnum = 1681915918
logical, private, parameter :: mpi_async_protects_nonblocking =  .false. 
integer, private, parameter :: mpi_band = 1476395014
integer, private, parameter :: mpi_bor = 1476395016
integer, private, parameter :: mpi_bsend_overhead = 88
integer, private, parameter :: mpi_bxor = 1476395018
integer, private, parameter :: mpi_byte = 1275068685
integer, private, parameter :: mpi_c_bool = 1275068735
integer, private, parameter :: mpi_c_complex = 1275070528
integer, private, parameter :: mpi_c_double_complex = 1275072577
integer, private, parameter :: mpi_c_float_complex = 1275070528
integer, private, parameter :: mpi_c_long_double_complex = 1275076674
integer, private, parameter :: mpi_cart = 2
integer, private, parameter :: mpi_char = 1275068673
integer, private, parameter :: mpi_character = 1275068698
integer, private, parameter :: mpi_combiner_contiguous = 3
integer, private, parameter :: mpi_combiner_darray = 14
integer, private, parameter :: mpi_combiner_dup = 2
integer, private, parameter :: mpi_combiner_f90_complex = 16
integer, private, parameter :: mpi_combiner_f90_integer = 17
integer, private, parameter :: mpi_combiner_f90_real = 15
integer, private, parameter :: mpi_combiner_hindexed = 9
integer, private, parameter :: mpi_combiner_hindexed_block = 19
integer, private, parameter :: mpi_combiner_hindexed_integer = 8
integer, private, parameter :: mpi_combiner_hvector = 6
integer, private, parameter :: mpi_combiner_hvector_integer = 5
integer, private, parameter :: mpi_combiner_indexed = 7
integer, private, parameter :: mpi_combiner_indexed_block = 10
integer, private, parameter :: mpi_combiner_named = 1
integer, private, parameter :: mpi_combiner_resized = 18
integer, private, parameter :: mpi_combiner_struct = 12
integer, private, parameter :: mpi_combiner_struct_integer = 11
integer, private, parameter :: mpi_combiner_subarray = 13
integer, private, parameter :: mpi_combiner_vector = 4
integer, private, parameter :: mpi_comm_null = 67108864
integer, private, parameter :: mpi_comm_self = 1140850689
integer, private, parameter :: mpi_comm_type_shared = 1
integer, private, parameter :: mpi_comm_world = 1140850688
integer, private, parameter :: mpi_complex = 1275070494
integer, private, parameter :: mpi_complex16 = 1275072554
integer, private, parameter :: mpi_complex32 = 1275076652
integer, private, parameter :: mpi_complex8 = 1275070504
integer, private, parameter :: mpi_congruent = 1
integer, private, parameter :: mpi_count = 1275070533
integer, private, parameter :: mpi_count_kind = 8
integer, private, parameter :: mpi_cxx_bool = 1275068723
integer, private, parameter :: mpi_cxx_double_complex = 1275072565
integer, private, parameter :: mpi_cxx_float_complex = 1275070516
integer, private, parameter :: mpi_cxx_long_double_complex = 1275076662
integer, private, parameter :: mpi_datatype_null = 201326592
integer(kind=8), private, parameter :: mpi_displacement_current = -54278278
integer, private, parameter :: mpi_dist_graph = 3
integer, private, parameter :: mpi_distribute_block = 121
integer, private, parameter :: mpi_distribute_cyclic = 122
integer, private, parameter :: mpi_distribute_dflt_darg = -49767
integer, private, parameter :: mpi_distribute_none = 123
integer, private, parameter :: mpi_double = 1275070475
integer, private, parameter :: mpi_double_complex = 1275072546
integer, private, parameter :: mpi_double_int = -1946157055
integer, private, parameter :: mpi_double_precision = 1275070495
integer, private, parameter :: mpi_err_access = 20
integer, private, parameter :: mpi_err_amode = 21
integer, private, parameter :: mpi_err_arg = 12
integer, private, parameter :: mpi_err_assert = 53
integer, private, parameter :: mpi_err_bad_file = 22
integer, private, parameter :: mpi_err_base = 46
integer, private, parameter :: mpi_err_buffer = 1
integer, private, parameter :: mpi_err_comm = 5
integer, private, parameter :: mpi_err_conversion = 23
integer, private, parameter :: mpi_err_count = 2
integer, private, parameter :: mpi_err_dims = 11
integer, private, parameter :: mpi_err_disp = 52
integer, private, parameter :: mpi_err_dup_datarep = 24
integer, private, parameter :: mpi_err_file = 27
integer, private, parameter :: mpi_err_file_exists = 25
integer, private, parameter :: mpi_err_file_in_use = 26
integer, private, parameter :: mpi_err_group = 8
integer, private, parameter :: mpi_err_in_status = 17
integer, private, parameter :: mpi_err_info = 28
integer, private, parameter :: mpi_err_info_key = 29
integer, private, parameter :: mpi_err_info_nokey = 31
integer, private, parameter :: mpi_err_info_value = 30
integer, private, parameter :: mpi_err_intern = 16
integer, private, parameter :: mpi_err_io = 32
integer, private, parameter :: mpi_err_keyval = 48
integer, private, parameter :: mpi_err_lastcode = 1073741823
integer, private, parameter :: mpi_err_locktype = 47
integer, private, parameter :: mpi_err_name = 33
integer, private, parameter :: mpi_err_no_mem = 34
integer, private, parameter :: mpi_err_no_space = 36
integer, private, parameter :: mpi_err_no_such_file = 37
integer, private, parameter :: mpi_err_not_same = 35
integer, private, parameter :: mpi_err_op = 9
integer, private, parameter :: mpi_err_other = 15
integer, private, parameter :: mpi_err_pending = 18
integer, private, parameter :: mpi_err_port = 38
integer, private, parameter :: mpi_err_quota = 39
integer, private, parameter :: mpi_err_rank = 6
integer, private, parameter :: mpi_err_read_only = 40
integer, private, parameter :: mpi_err_request = 19
integer, private, parameter :: mpi_err_rma_attach = 56
integer, private, parameter :: mpi_err_rma_conflict = 49
integer, private, parameter :: mpi_err_rma_flavor = 58
integer, private, parameter :: mpi_err_rma_range = 55
integer, private, parameter :: mpi_err_rma_shared = 57
integer, private, parameter :: mpi_err_rma_sync = 50
integer, private, parameter :: mpi_err_root = 7
integer, private, parameter :: mpi_err_service = 41
integer, private, parameter :: mpi_err_size = 51
integer, private, parameter :: mpi_err_spawn = 42
integer, private, parameter :: mpi_err_tag = 4
integer, private, parameter :: mpi_err_topology = 10
integer, private, parameter :: mpi_err_truncate = 14
integer, private, parameter :: mpi_err_type = 3
integer, private, parameter :: mpi_err_unknown = 13
integer, private, parameter :: mpi_err_unsupported_datarep = 43
integer, private, parameter :: mpi_err_unsupported_operation = 44
integer, private, parameter :: mpi_err_win = 45
integer, private, parameter :: mpi_errhandler_null = 335544320
integer, private, parameter :: mpi_error = 5
integer, private, parameter :: mpi_errors_are_fatal = 1409286144
integer, private, parameter :: mpi_errors_return = 1409286145
integer, private, parameter :: mpi_file_null = 0
integer, private, parameter :: mpi_float = 1275069450
integer, private, parameter :: mpi_float_int = -1946157056
integer, private, parameter :: mpi_graph = 1
integer, private, parameter :: mpi_group_empty = 1207959552
integer, private, parameter :: mpi_group_null = 134217728
integer, private, parameter :: mpi_host = 1681915908
integer, private, parameter :: mpi_ident = 0
integer, private, parameter :: mpi_info_env = 1543503873
integer, private, parameter :: mpi_info_null = 469762048
integer, private, parameter :: mpi_int = 1275069445
integer, private, parameter :: mpi_int16_t = 1275068984
integer, private, parameter :: mpi_int32_t = 1275069497
integer, private, parameter :: mpi_int64_t = 1275070522
integer, private, parameter :: mpi_int8_t = 1275068727
integer, private, parameter :: mpi_integer = 1275069467
integer, private, parameter :: mpi_integer1 = 1275068717
integer, private, parameter :: mpi_integer16 = mpi_datatype_null
integer, private, parameter :: mpi_integer2 = 1275068975
integer, private, parameter :: mpi_integer4 = 1275069488
integer, private, parameter :: mpi_integer8 = 1275070513
integer, private, parameter :: mpi_integer_kind = 4
integer, private, parameter :: mpi_io = 1681915910
integer, private, parameter :: mpi_keyval_invalid = 603979776
integer, private, parameter :: mpi_land = 1476395013
integer, private, parameter :: mpi_lastusedcode = 1681915916
integer, private, parameter :: mpi_lb = 1275068432
integer, private, parameter :: mpi_lock_exclusive = 234
integer, private, parameter :: mpi_lock_shared = 235
integer, private, parameter :: mpi_logical = 1275069469
integer, private, parameter :: mpi_long = 1275070471
integer, private, parameter :: mpi_long_double = 1275072524
integer, private, parameter :: mpi_long_double_int = -1946157052
integer, private, parameter :: mpi_long_int = -1946157054
integer, private, parameter :: mpi_long_long = 1275070473
integer, private, parameter :: mpi_long_long_int = 1275070473
integer, private, parameter :: mpi_lor = 1476395015
integer, private, parameter :: mpi_lxor = 1476395017
integer, private, parameter :: mpi_max = 1476395009
integer, private, parameter :: mpi_max_datarep_string = 127
integer, private, parameter :: mpi_max_error_string = 512-1
integer, private, parameter :: mpi_max_info_key = 254
integer, private, parameter :: mpi_max_info_val = 1023
integer, private, parameter :: mpi_max_library_version_string = 8192-1
integer, private, parameter :: mpi_max_object_name = 127
integer, private, parameter :: mpi_max_port_name = 255
integer, private, parameter :: mpi_max_processor_name = 128-1
integer, private, parameter :: mpi_maxloc = 1476395020
integer, private, parameter :: mpi_message_no_proc = 1811939328
integer, private, parameter :: mpi_message_null = 738197504
integer, private, parameter :: mpi_min = 1476395010
integer, private, parameter :: mpi_minloc = 1476395019
integer, private, parameter :: mpi_mode_append = 128
integer, private, parameter :: mpi_mode_create = 1
integer, private, parameter :: mpi_mode_delete_on_close = 16
integer, private, parameter :: mpi_mode_excl = 64
integer, private, parameter :: mpi_mode_nocheck = 1024
integer, private, parameter :: mpi_mode_noprecede = 8192
integer, private, parameter :: mpi_mode_noput = 4096
integer, private, parameter :: mpi_mode_nostore = 2048
integer, private, parameter :: mpi_mode_nosucceed = 16384
integer, private, parameter :: mpi_mode_rdonly = 2
integer, private, parameter :: mpi_mode_rdwr = 8
integer, private, parameter :: mpi_mode_sequential = 256
integer, private, parameter :: mpi_mode_unique_open = 32
integer, private, parameter :: mpi_mode_wronly = 4
integer, private, parameter :: mpi_no_op = 1476395022
integer, private, parameter :: mpi_offset = 1275070532
integer, private, parameter :: mpi_offset_kind = 8
integer, private, parameter :: mpi_op_null = 402653184
integer, private, parameter :: mpi_order_c = 56
integer, private, parameter :: mpi_order_fortran = 57
integer, private, parameter :: mpi_packed = 1275068687
integer, private, parameter :: mpi_proc_null = -1
integer, private, parameter :: mpi_prod = 1476395012
integer, private, parameter :: mpi_real = 1275069468
integer, private, parameter :: mpi_real16 = 1275072555
integer, private, parameter :: mpi_real4 = 1275069479
integer, private, parameter :: mpi_real8 = 1275070505
integer, private, parameter :: mpi_replace = 1476395021
integer, private, parameter :: mpi_request_null = 738197504
integer, private, parameter :: mpi_root = -3
integer, private, parameter :: mpi_seek_cur = 602
integer, private, parameter :: mpi_seek_end = 604
integer, private, parameter :: mpi_seek_set = 600
integer, private, parameter :: mpi_short = 1275068931
integer, private, parameter :: mpi_short_int = -1946157053
integer, private, parameter :: mpi_signed_char = 1275068696
integer, private, parameter :: mpi_similar = 2
integer, private, parameter :: mpi_source = 3
integer, private, parameter :: mpi_status_size = 5
logical, private, parameter :: mpi_subarrays_supported =  .false. 
integer, private, parameter :: mpi_subversion = 1
integer, private, parameter :: mpi_success = 0
integer, private, parameter :: mpi_sum = 1476395011
integer, private, parameter :: mpi_tag = 4
integer, private, parameter :: mpi_tag_ub = 1681915906
integer, private, parameter :: mpi_thread_funneled = 1
integer, private, parameter :: mpi_thread_multiple = 3
integer, private, parameter :: mpi_thread_serialized = 2
integer, private, parameter :: mpi_thread_single = 0
integer, private, parameter :: mpi_typeclass_complex = 3
integer, private, parameter :: mpi_typeclass_integer = 2
integer, private, parameter :: mpi_typeclass_real = 1
integer, private, parameter :: mpi_ub = 1275068433
integer, private, parameter :: mpi_uint16_t = 1275068988
integer, private, parameter :: mpi_uint32_t = 1275069501
integer, private, parameter :: mpi_uint64_t = 1275070526
integer, private, parameter :: mpi_uint8_t = 1275068731
integer, private, parameter :: mpi_undefined = -32766
integer, private, parameter :: mpi_unequal = 3
integer, private, parameter :: mpi_universe_size = 1681915914
integer, private, parameter :: mpi_unsigned = 1275069446
integer, private, parameter :: mpi_unsigned_char = 1275068674
integer, private, parameter :: mpi_unsigned_long = 1275070472
integer, private, parameter :: mpi_unsigned_long_long = 1275070489
integer, private, parameter :: mpi_unsigned_short = 1275068932
integer, private, parameter :: mpi_version = 3
integer, private, parameter :: mpi_wchar = 1275069454
integer, private, parameter :: mpi_win_base = 1711276034
integer, private, parameter :: mpi_win_create_flavor = 1711276040
integer, private, parameter :: mpi_win_disp_unit = 1711276038
integer, private, parameter :: mpi_win_flavor_allocate = 2
integer, private, parameter :: mpi_win_flavor_create = 1
integer, private, parameter :: mpi_win_flavor_dynamic = 3
integer, private, parameter :: mpi_win_flavor_shared = 4
integer, private, parameter :: mpi_win_model = 1711276042
integer, private, parameter :: mpi_win_null = 536870912
integer, private, parameter :: mpi_win_separate = 1
integer, private, parameter :: mpi_win_size = 1711276036
integer, private, parameter :: mpi_win_unified = 2
integer, private, parameter :: mpi_wtime_is_global = 1681915912
integer, private, parameter :: nfilesmax_ihop = 1
integer, private, parameter :: nobsmax_ihop = 10
integer, private, parameter :: npx = 1
integer, private, parameter :: npy = 1
integer, private, parameter :: nr = 15
integer, private, parameter :: nrd = 1
integer, private, parameter :: nrr = 1
integer, private, parameter :: nsd = 1
integer, private, parameter :: nsx = 1
integer, private, parameter :: nsy = 1
integer, private, parameter :: nts = 1080
integer, private, parameter :: null_tile = -1
integer, private, parameter :: snx = 62
integer, private, parameter :: nx = snx*nsx*npx
integer, private, parameter :: sny = 62
integer, private, parameter :: ny = sny*nsy*npy
double precision, private, parameter :: onerl = 1.0d0
double precision, private, parameter :: oners = 1.0d0
integer, private, parameter :: precfloat32 = 32
integer, private, parameter :: precfloat64 = 64
character(len=*), private, parameter :: print_map_xy = 'XY'
character(len=*), private, parameter :: print_map_xz = 'XZ'
character(len=*), private, parameter :: print_map_yz = 'YZ'
character(len=*), private, parameter :: process_header = 'PID.TID'
integer, private, parameter :: reverse_simulation = 1
character(len=*), private, parameter :: squeeze_both = 'B'
character(len=*), private, parameter :: squeeze_left = 'L'
character(len=*), private, parameter :: squeeze_right = 'R'
integer, private, parameter :: tangent_simulation = 2
double precision, private, parameter :: tworl = 2.0d0
double precision, private, parameter :: twors = 2.0d0
real, private, parameter :: unset_float4 = 1.234567e5
double precision, private, parameter :: unset_float8 = 1.234567d5
integer, private, parameter :: unset_i = 123456789
double precision, private, parameter :: unset_rl = 1.234567d5
double precision, private, parameter :: unset_rs = 1.234567d5
double precision, private, parameter :: zerorl = 0.0d0
double precision, private, parameter :: zerors = 0.0d0

!==============================================
! declare derived type definitions
!==============================================
type, private :: rxyz_vector
  real(kind=8), allocatable :: r(:)
end type

type, private :: sspstructure
  integer :: npts
  integer :: nr
  integer :: nx
  integer :: ny
  integer :: nz
  real(kind=8) :: z(maxssp)
  real(kind=8) :: rho(maxssp)
  complex(kind=8) :: c(maxssp)
  complex(kind=8) :: cz(maxssp)
  real(kind=8), allocatable :: cmat(:,:)
  real(kind=8), allocatable :: czmat(:,:)
  type(rxyz_vector) :: seg
  character(len=1) :: type
  character(len=2) :: attenunit
end type

type, private :: sspstructure_tl
  complex(kind=8) :: c_tl(maxssp)
  complex(kind=8) :: cz_tl(maxssp)
  real(kind=8), allocatable :: cmat_tl(:,:)
  real(kind=8), allocatable :: czmat_tl(:,:)
end type

!==============================================
! declare common blocks
!==============================================
integer, private :: eedataunit
integer, private :: errormessageunit
integer, private :: ioerrorcount(max_no_threads)
integer, private :: maxlengthprt1d
integer, private :: modeldataunit
integer, private :: mybxhi(max_no_threads)
integer, private :: mybxlo(max_no_threads)
integer, private :: mybyhi(max_no_threads)
integer, private :: mybylo(max_no_threads)
integer, private :: myprocid
integer, private :: mypx
integer, private :: mypy
integer, private :: myxgloballo
integer, private :: myygloballo
integer, private :: nthreads
integer, private :: ntx
integer, private :: nty
integer, private :: numberofprocs
integer, private :: pidio
integer, private :: scrunit1
integer, private :: scrunit2
integer, private :: standardmessageunit
common /eeparams_i/ errormessageunit, standardmessageunit, maxlengthprt1d, scrunit1, scrunit2, eedataunit, modeldataunit, numberofprocs, pidio, &
&myprocid, mypx, mypy, myxgloballo, myygloballo, nthreads, mybxlo, mybxhi, mybylo, mybyhi, ntx, nty, ioerrorcount

logical, private :: debugmode
logical, private :: eebooterror
logical, private :: eeenderror
logical, private :: fatalerror
logical, private :: printmapincludeszeros
logical, private :: usecoupler
logical, private :: usecubedsphereexchange
logical, private :: usenest2w_child
logical, private :: usenest2w_parent
logical, private :: usenest_child
logical, private :: usenest_parent
logical, private :: useoasis
logical, private :: usesetrlstk
logical, private :: usesigreg
logical, private :: usesinglecpuinput
logical, private :: usesinglecpuio
common /eeparams_l/ eebooterror, eeenderror, fatalerror, debugmode, usesinglecpuio, usesinglecpuinput, printmapincludeszeros, usecubedsphereexchange,&
& usecoupler, usenest_parent, usenest_child, usenest2w_parent, usenest2w_child, useoasis, usesetrlstk, usesigreg

character(len=128), private :: myprocessstr
common /eesupp_c/ myprocessstr

character(len=10), private :: commname(max_num_comm_modes)
common /eesupp_commname/ commname

integer, private :: mypid
integer, private :: nprocs
integer, private :: pide
integer, private :: pidn
integer, private :: pids
integer, private :: pidw
integer, private :: tilebie(nsx,nsy)
integer, private :: tilebin(nsx,nsy)
integer, private :: tilebis(nsx,nsy)
integer, private :: tilebiw(nsx,nsy)
integer, private :: tilebje(nsx,nsy)
integer, private :: tilebjn(nsx,nsy)
integer, private :: tilebjs(nsx,nsy)
integer, private :: tilebjw(nsx,nsy)
integer, private :: tilecommmodee(nsx,nsy)
integer, private :: tilecommmoden(nsx,nsy)
integer, private :: tilecommmodes(nsx,nsy)
integer, private :: tilecommmodew(nsx,nsy)
integer, private :: tileno(nsx,nsy)
integer, private :: tilenoe(nsx,nsy)
integer, private :: tilenon(nsx,nsy)
integer, private :: tilenos(nsx,nsy)
integer, private :: tilenow(nsx,nsy)
integer, private :: tilepide(nsx,nsy)
integer, private :: tilepidn(nsx,nsy)
integer, private :: tilepids(nsx,nsy)
integer, private :: tilepidw(nsx,nsy)
integer, private :: tiletagrecve(nsx,nsy)
integer, private :: tiletagrecvn(nsx,nsy)
integer, private :: tiletagrecvs(nsx,nsy)
integer, private :: tiletagrecvw(nsx,nsy)
integer, private :: tiletagsende(nsx,nsy)
integer, private :: tiletagsendn(nsx,nsy)
integer, private :: tiletagsends(nsx,nsy)
integer, private :: tiletagsendw(nsx,nsy)
common /eesupp_i/ mypid, nprocs, pidw, pide, pidn, pids, tilecommmodew, tilecommmodee, tilecommmoden, tilecommmodes, tileno, tilenow, tilenoe, &
&tilenos, tilenon, tilepidw, tilepide, tilepids, tilepidn, tilebiw, tilebie, tilebis, tilebin, tilebjw, tilebje, tilebjs, tilebjn, tiletagsendw, &
&tiletagsende, tiletagsends, tiletagsendn, tiletagrecvw, tiletagrecve, tiletagrecvs, tiletagrecvn

logical, private :: allmyedgesaresharedmemory(max_no_threads)
logical, private :: notusingxperiodicity
logical, private :: notusingyperiodicity
logical, private :: therror(max_no_threads)
logical, private :: threadiscomplete(max_no_threads)
logical, private :: threadisrunning(max_no_threads)
logical, private :: usingmpi
logical, private :: usingsyncmessages
common /eesupp_l/ therror, threadisrunning, threadiscomplete, allmyedgesaresharedmemory, usingmpi, usingsyncmessages, notusingxperiodicity, &
&notusingyperiodicity

integer, private :: mpicomm
integer, private :: mpimyid
integer, private :: mpinprocs
integer, private :: mpipide
integer, private :: mpipidio
integer, private :: mpipidn
integer, private :: mpipidne
integer, private :: mpipidnw
integer, private :: mpipids
integer, private :: mpipidse
integer, private :: mpipidsw
integer, private :: mpipidw
integer, private :: mpipx
integer, private :: mpipy
integer, private :: mpitage
integer, private :: mpitagn
integer, private :: mpitagne
integer, private :: mpitagnw
integer, private :: mpitags
integer, private :: mpitagse
integer, private :: mpitagsw
integer, private :: mpitagw
integer, private :: mpitypexfaceblock_xy_r4
integer, private :: mpitypexfaceblock_xy_r8
integer, private :: mpitypexfaceblock_xyz_r4
integer, private :: mpitypexfaceblock_xyz_r8
integer, private :: mpitypexfacethread_xy_r4(max_no_threads)
integer, private :: mpitypexfacethread_xy_r8(max_no_threads)
integer, private :: mpitypexfacethread_xyz_r4(max_no_threads)
integer, private :: mpitypexfacethread_xyz_r8(max_no_threads)
integer, private :: mpitypeyfaceblock_xy_r4
integer, private :: mpitypeyfaceblock_xy_r8
integer, private :: mpitypeyfaceblock_xyz_r4
integer, private :: mpitypeyfaceblock_xyz_r8
integer, private :: mpitypeyfacethread_xy_r4(max_no_threads)
integer, private :: mpitypeyfacethread_xy_r8(max_no_threads)
integer, private :: mpitypeyfacethread_xyz_r4(max_no_threads)
integer, private :: mpitypeyfacethread_xyz_r8(max_no_threads)
integer, private :: mpixgloballo
integer, private :: mpiygloballo
common /eesupp_mpi_i/ mpipidw, mpipide, mpipids, mpipidn, mpipidse, mpipidsw, mpipidne, mpipidnw, mpipidio, mpimyid, mpinprocs, mpicomm, mpipx, &
&mpipy, mpixgloballo, mpiygloballo, mpitypexfaceblock_xy_r4, mpitypexfaceblock_xy_r8, mpitypeyfaceblock_xy_r4, mpitypeyfaceblock_xy_r8, &
&mpitypexfaceblock_xyz_r4, mpitypexfaceblock_xyz_r8, mpitypeyfaceblock_xyz_r4, mpitypeyfaceblock_xyz_r8, mpitypexfacethread_xy_r4, &
&mpitypexfacethread_xy_r8, mpitypeyfacethread_xy_r4, mpitypeyfacethread_xy_r8, mpitypexfacethread_xyz_r4, mpitypexfacethread_xyz_r8, &
&mpitypeyfacethread_xyz_r4, mpitypeyfacethread_xyz_r8, mpitage, mpitagw, mpitagn, mpitags, mpitagse, mpitagsw, mpitagnw, mpitagne

integer, private :: klowc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfs(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_i/ ksurfc, ksurfw, ksurfs, klowc

double precision, private :: cosfacu(1-oly:sny+oly,nsx,nsy)
double precision, private :: cosfacv(1-oly:sny+oly,nsx,nsy)
double precision, private :: deepfac2c(nr)
double precision, private :: deepfac2f(nr+1)
double precision, private :: deepfacc(nr)
double precision, private :: deepfacf(nr+1)
double precision, private :: globalarea
double precision, private :: gravitysign
double precision, private :: recip_deepfac2c(nr)
double precision, private :: recip_deepfac2f(nr+1)
double precision, private :: recip_deepfacc(nr)
double precision, private :: recip_deepfacf(nr+1)
double precision, private :: rksign
double precision, private :: sqcosfacu(1-oly:sny+oly,nsx,nsy)
double precision, private :: sqcosfacv(1-oly:sny+oly,nsx,nsy)
common /grid_rl/ cosfacu, cosfacv, sqcosfacu, sqcosfacv, deepfacc, deepfac2c, recip_deepfacc, recip_deepfac2c, deepfacf, deepfac2f, recip_deepfacf, &
&recip_deepfac2f, gravitysign, rksign, globalarea

double precision, private :: ahybsigmc(nr)
double precision, private :: ahybsigmf(nr+1)
double precision, private :: anglecosc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: anglesinc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: bhybsigmc(nr)
double precision, private :: bhybsigmf(nr+1)
double precision, private :: dahybsigc(nr+1)
double precision, private :: dahybsigf(nr)
double precision, private :: dbhybsigc(nr+1)
double precision, private :: dbhybsigf(nr)
double precision, private :: drc(nr+1)
double precision, private :: drf(nr)
double precision, private :: dxc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcori(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcoricos(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcorig(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: maskinc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskins(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskinw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: masks(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: maskw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: ra(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: ras(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: raw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: raz(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rc(nr)
double precision, private :: recip_drc(nr+1)
double precision, private :: recip_drf(nr)
double precision, private :: recip_dxc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_ra(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_ras(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_raw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_raz(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rf(nr+1)
double precision, private :: rlows(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rloww(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: ro_surf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rsurfs(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rsurfw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: tanphiatu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: tanphiatv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: u2zondir(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: v2zondir(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: xc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: xg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: yc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: yg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_rs/ dxc, dxf, dxg, dxv, dyc, dyf, dyg, dyu, rloww, rlows, ro_surf, rsurfw, rsurfs, recip_dxc, recip_dxf, recip_dxg, recip_dxv, &
&recip_dyc, recip_dyf, recip_dyg, recip_dyu, xc, yc, ra, raw, ras, raz, xg, yg, maskinc, maskinw, maskins, maskc, maskw, masks, recip_ra, recip_raw, &
&recip_ras, recip_raz, drc, drf, recip_drc, recip_drf, rc, rf, ahybsigmf, bhybsigmf, ahybsigmc, bhybsigmc, dahybsigf, dbhybsigf, dbhybsigc, &
&dahybsigc, tanphiatu, tanphiatv, anglecosc, anglesinc, u2zondir, v2zondir, fcori, fcorig, fcoricos

double precision, private :: hfacc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: hfacs(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: hfacw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: r_low(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_hfacc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_hfacs(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_hfacw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_rcol(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_var_rs/ hfacc, hfacw, hfacs, recip_hfacc, recip_hfacw, recip_hfacs, r_low, recip_rcol

logical, private :: ihop_mdsio
logical, private :: ihop_mnc
common /ihop_package/ ihop_mnc, ihop_mdsio

character(len=2), private :: ihop_botopt
character(len=max_len_fnam), private :: ihop_fileroot
character(len=max_len_fnam), private :: ihop_interpfile
character(len=7), private :: ihop_runopt
character(len=max_len_fnam), private :: ihop_title
character(len=6), private :: ihop_topopt
common /ihop_params_c/ ihop_fileroot, ihop_title, ihop_topopt, ihop_botopt, ihop_runopt, ihop_interpfile

integer, private :: ihop_iter(nts)
integer, private :: ihop_nalpha
integer, private :: ihop_npts_idw
integer, private :: ihop_npts_range
integer, private :: ihop_nrd
integer, private :: ihop_nrr
integer, private :: ihop_nsd
integer, private :: ihop_nts
common /ihop_params_i/ ihop_nts, ihop_nsd, ihop_nrd, ihop_nrr, ihop_npts_range, ihop_npts_idw, ihop_nalpha, ihop_iter

logical, private :: usesspfile
logical, private :: writedelay
common /ihop_params_l/ writedelay, usesspfile

double precision, private :: ihop_alpha(2)
double precision, private :: ihop_bcsound
double precision, private :: ihop_bcsoundi
double precision, private :: ihop_bcsoundshear
double precision, private :: ihop_bcsoundsheari
double precision, private :: ihop_brho
double precision, private :: ihop_depth
double precision, private :: ihop_dumpfreq
double precision, private :: ihop_freq
double precision, private :: ihop_idw_weights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_ranges(ihop_max_range)
double precision, private :: ihop_rd(nrd)
double precision, private :: ihop_rr(nrr)
double precision, private :: ihop_sd(nsd)
double precision, private :: ihop_step
double precision, private :: ihop_sumweights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_xc(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_yc(ihop_max_range,ihop_max_nc_size)
common /ihop_params_r/ ihop_dumpfreq, ihop_freq, ihop_depth, ihop_bcsound, ihop_bcsoundshear, ihop_brho, ihop_bcsoundi, ihop_bcsoundsheari, ihop_sd, &
&ihop_rd, ihop_rr, ihop_alpha, ihop_step, ihop_yc, ihop_xc, ihop_idw_weights, ihop_ranges, ihop_sumweights

double precision, private :: ihop_sld(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /ihop_state_2d/ ihop_sld

double precision, private :: ihop_ssp(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d/ ihop_ssp

double precision, private :: ihop_ssp_tl(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d_tl/ ihop_ssp_tl

integer, private :: mpi_comm_model
common /mpi_comms/ mpi_comm_model

integer, private :: mpi_myxgloballo(npx*npy)
integer, private :: mpi_myygloballo(npx*npy)
common /mpi_fullmap_i/ mpi_myxgloballo, mpi_myygloballo

integer, private :: mpi_unweighted
common /mpifcmb5/ mpi_unweighted

integer, private :: mpi_weights_empty
common /mpifcmb9/ mpi_weights_empty

integer, private :: mpi_bottom
integer, private :: mpi_in_place
integer, private :: mpi_status_ignore(mpi_status_size)
common /mpipriv1/ mpi_bottom, mpi_in_place, mpi_status_ignore

integer, private :: mpi_errcodes_ignore(1)
integer, private :: mpi_statuses_ignore(mpi_status_size,1)
common /mpipriv2/ mpi_statuses_ignore, mpi_errcodes_ignore

character(len=1), private :: mpi_argv_null(1)
character(len=1), private :: mpi_argvs_null(1,1)
common /mpiprivc/ mpi_argvs_null, mpi_argv_null

double precision, private :: heatcapacity_cp
common /parm_a/ heatcapacity_cp

double precision, private :: atm_cp
double precision, private :: atm_kappa
double precision, private :: atm_po
double precision, private :: atm_rd
double precision, private :: atm_rq
double precision, private :: celsius2k
integer, private :: integr_geopot
integer, private :: selectfindrosurf
common /parm_atm/ celsius2k, atm_cp, atm_rd, atm_kappa, atm_rq, atm_po, integr_geopot, selectfindrosurf

character(len=max_len_fnam), private :: addmassfile
character(len=max_len_fnam), private :: addswallfile
character(len=max_len_fnam), private :: addwwallfile
character(len=max_len_fnam), private :: adtapedir
character(len=max_len_fnam), private :: bathyfile
character(len=max_len_fnam), private :: buoyancyrelation
character(len=max_len_fnam), private :: delrcfile
character(len=max_len_fnam), private :: delrfile
character(len=max_len_fnam), private :: delxfile
character(len=max_len_fnam), private :: delyfile
character(len=max_len_fnam), private :: diffkrfile
character(len=max_len_fnam), private :: eddypsixfile
character(len=max_len_fnam), private :: eddypsiyfile
character(len=max_len_fnam), private :: empmrfile
character(len=6), private :: eostype
character(len=max_len_fnam), private :: geopotanomfile
character(len=max_len_fnam), private :: geothermalfile
character(len=max_len_fnam), private :: gravityfile
character(len=max_len_fnam), private :: horizgridfile
character(len=max_len_fnam), private :: hybsigmfile
character(len=max_len_fnam), private :: hydrogsaltfile
character(len=max_len_fnam), private :: hydrogthetafile
character(len=max_len_fnam), private :: lambdasaltfile
character(len=max_len_fnam), private :: lambdathetafile
character(len=max_len_fnam), private :: mdsiolocaldir
character(len=max_len_fnam), private :: meridwindfile
character(len=10), private :: pickupsuff
character(len=max_len_fnam), private :: ploadfile
character(len=max_len_fnam), private :: psurfinitfile
character(len=max_len_fnam), private :: rhoreffile
character(len=max_len_fnam), private :: saltclimfile
character(len=max_len_fnam), private :: saltfluxfile
character(len=max_len_fnam), private :: sreffile
character(len=max_len_fnam), private :: surfqfile
character(len=max_len_fnam), private :: surfqnetfile
character(len=max_len_fnam), private :: surfqswfile
character(len=max_len_prec/2), private :: the_run_name
character(len=max_len_fnam), private :: thetaclimfile
character(len=max_len_fnam), private :: topofile
character(len=max_len_fnam), private :: treffile
character(len=max_len_fnam), private :: uvelinitfile
character(len=max_len_fnam), private :: visca4dfile
character(len=max_len_fnam), private :: visca4zfile
character(len=max_len_fnam), private :: viscahdfile
character(len=max_len_fnam), private :: viscahzfile
character(len=max_len_fnam), private :: vvelinitfile
character(len=max_len_fnam), private :: wghtbalancefile
character(len=max_len_fnam), private :: zonalwindfile
common /parm_c/ buoyancyrelation, eostype, pickupsuff, mdsiolocaldir, adtapedir, treffile, sreffile, rhoreffile, gravityfile, delrfile, delrcfile, &
&hybsigmfile, delxfile, delyfile, horizgridfile, bathyfile, topofile, addwwallfile, addswallfile, viscahdfile, viscahzfile, visca4dfile, visca4zfile,&
& hydrogthetafile, hydrogsaltfile, diffkrfile, zonalwindfile, meridwindfile, thetaclimfile, saltclimfile, empmrfile, saltfluxfile, surfqfile, &
&surfqnetfile, surfqswfile, uvelinitfile, vvelinitfile, psurfinitfile, ploadfile, geopotanomfile, addmassfile, eddypsixfile, eddypsiyfile, &
&geothermalfile, lambdathetafile, lambdasaltfile, wghtbalancefile, the_run_name

integer, private :: cg2dmaxiters
integer, private :: cg2dminitersnsa
integer, private :: cg2dprecondfreq
integer, private :: cg2duseminressol
integer, private :: cg3dmaxiters
integer, private :: debuglevel
integer, private :: momforcingoutab
integer, private :: monitorselect
integer, private :: nenditer
integer, private :: niter0
integer, private :: nonlinfreesurf
integer, private :: ntimesteps
integer, private :: ntimesteps_l2
integer, private :: pcellmix_select
integer, private :: plotlevel
integer, private :: printresidualfreq
integer, private :: readbinaryprec
integer, private :: rwsuffixtype
integer, private :: saltadvscheme
integer, private :: saltvertadvscheme
integer, private :: select3dcorischeme
integer, private :: select_rstar
integer, private :: selectaddfluid
integer, private :: selectbalanceempmr
integer, private :: selectbotdragquadr
integer, private :: selectcorimap
integer, private :: selectcorischeme
integer, private :: selectimplicitdrag
integer, private :: selectkescheme
integer, private :: selectmetricterms
integer, private :: selectnhfreesurf
integer, private :: selectp_ineos_zc
integer, private :: selectpenetratingsw
integer, private :: selectsigmacoord
integer, private :: selectvortscheme
integer, private :: tempadvscheme
integer, private :: tempvertadvscheme
integer, private :: tracforcingoutab
integer, private :: writebinaryprec
common /parm_i/ cg2dmaxiters, cg2dminitersnsa, cg2dprecondfreq, cg2duseminressol, cg3dmaxiters, printresidualfreq, niter0, ntimesteps, ntimesteps_l2,&
& nenditer, selectcorimap, selectsigmacoord, nonlinfreesurf, select_rstar, selectnhfreesurf, selectp_ineos_zc, selectaddfluid, selectbalanceempmr, &
&selectimplicitdrag, momforcingoutab, tracforcingoutab, tempadvscheme, tempvertadvscheme, saltadvscheme, saltvertadvscheme, selectkescheme, &
&selectvortscheme, selectmetricterms, selectcorischeme, select3dcorischeme, selectbotdragquadr, selectpenetratingsw, pcellmix_select, readbinaryprec,&
& writebinaryprec, rwsuffixtype, monitorselect, debuglevel, plotlevel

logical, private :: addfrictionheating
logical, private :: allowfreezing
logical, private :: applyexchuv_early
logical, private :: balanceprintmean
logical, private :: balanceqnet
logical, private :: balancesaltclimrelax
logical, private :: balancethetaclimrelax
logical, private :: bottomvisc_pcell
logical, private :: calc_wvelocity
logical, private :: checkinisalt
logical, private :: checkinitemp
logical, private :: deepatmosphere
logical, private :: doab_ongtgs
logical, private :: doresethfactors
logical, private :: dosaltclimrelax
logical, private :: dothetaclimrelax
logical, private :: dumpinitandlast
logical, private :: exactconserv
logical, private :: fluidisair
logical, private :: fluidiswater
logical, private :: globalfiles
logical, private :: haswetcscorners
logical, private :: highordervorticity
logical, private :: implicitdiffusion
logical, private :: implicitfreesurface
logical, private :: implicitintgravwave
logical, private :: implicitviscosity
logical, private :: interdiffkr_pcell
logical, private :: interviscar_pcell
logical, private :: linfsconservetr
logical, private :: maskinisalt
logical, private :: maskinitemp
logical, private :: momadvection
logical, private :: momdissip_in_ab
logical, private :: momforcing
logical, private :: momimplvertadv
logical, private :: mompressureforcing
logical, private :: momstepping
logical, private :: momtidalforcing
logical, private :: momviscosity
logical, private :: monitor_stdio
logical, private :: multidimadvection
logical, private :: no_slip_bottom
logical, private :: no_slip_sides
logical, private :: nonhydrostatic
logical, private :: outputtypesinclusive
logical, private :: periodicexternalforcing
logical, private :: pickup_read_mdsio
logical, private :: pickup_write_immed
logical, private :: pickup_write_mdsio
logical, private :: pickupstrictlymatch
logical, private :: quasihydrostatic
logical, private :: rigidlid
logical, private :: rotategrid
logical, private :: salt_staypositive
logical, private :: saltadvection
logical, private :: saltforcing
logical, private :: saltimplvertadv
logical, private :: saltisactivetr
logical, private :: saltstepping
logical, private :: saltvertdiff4
logical, private :: setcenterdr
logical, private :: setinterfdr
logical, private :: snapshot_mdsio
logical, private :: staggertimestep
logical, private :: startfrompickupab2
logical, private :: storephihyd4phys
logical, private :: temp_staypositive
logical, private :: tempadvection
logical, private :: tempforcing
logical, private :: tempimplvertadv
logical, private :: tempisactivetr
logical, private :: tempstepping
logical, private :: tempvertdiff4
logical, private :: timeave_mdsio
logical, private :: uniformfreesurflev
logical, private :: uniformlin_phisurf
logical, private :: upwindshear
logical, private :: upwindvorticity
logical, private :: use3dsolver
logical, private :: useabsvorticity
logical, private :: useareavisclength
logical, private :: usecdscheme
logical, private :: usecoriolis
logical, private :: usefullleith
logical, private :: usejamartmomadv
logical, private :: usemin4hfacedges
logical, private :: usemultidimadvec
logical, private :: usenhmterms
logical, private :: usensacgsolver
logical, private :: usepickupbeforec54
logical, private :: userealfreshwaterflux
logical, private :: usesmag3d
logical, private :: usesrcgsolver
logical, private :: usestraintensionvisc
logical, private :: usingcartesiangrid
logical, private :: usingcurvilineargrid
logical, private :: usingcylindricalgrid
logical, private :: usingpcoords
logical, private :: usingsphericalpolargrid
logical, private :: usingzcoords
logical, private :: vectorinvariantmomentum
logical, private :: writepickupatend
common /parm_l/ fluidisair, fluidiswater, usingpcoords, usingzcoords, usingcartesiangrid, usingsphericalpolargrid, rotategrid, usingcylindricalgrid, &
&usingcurvilineargrid, haswetcscorners, deepatmosphere, setinterfdr, setcenterdr, usemin4hfacedges, interviscar_pcell, interdiffkr_pcell, &
&no_slip_sides, no_slip_bottom, bottomvisc_pcell, usesmag3d, usefullleith, usestraintensionvisc, useareavisclength, momviscosity, momadvection, &
&momforcing, momtidalforcing, mompressureforcing, usenhmterms, usecoriolis, usecdscheme, vectorinvariantmomentum, usejamartmomadv, upwindvorticity, &
&highordervorticity, useabsvorticity, upwindshear, momstepping, calc_wvelocity, tempstepping, saltstepping, addfrictionheating, temp_staypositive, &
&salt_staypositive, tempadvection, tempvertdiff4, tempisactivetr, tempforcing, saltadvection, saltvertdiff4, saltisactivetr, saltforcing, &
&maskinitemp, maskinisalt, checkinitemp, checkinisalt, usensacgsolver, usesrcgsolver, rigidlid, implicitfreesurface, uniformlin_phisurf, &
&uniformfreesurflev, exactconserv, linfsconservetr, userealfreshwaterflux, storephihyd4phys, quasihydrostatic, nonhydrostatic, use3dsolver, &
&implicitintgravwave, staggertimestep, applyexchuv_early, doresethfactors, implicitdiffusion, implicitviscosity, tempimplvertadv, saltimplvertadv, &
&momimplvertadv, multidimadvection, usemultidimadvec, momdissip_in_ab, doab_ongtgs, balanceqnet, balanceprintmean, balancethetaclimrelax, &
&balancesaltclimrelax, dothetaclimrelax, dosaltclimrelax, allowfreezing, periodicexternalforcing, globalfiles, pickupstrictlymatch, &
&usepickupbeforec54, startfrompickupab2, pickup_read_mdsio, pickup_write_mdsio, pickup_write_immed, writepickupatend, timeave_mdsio, snapshot_mdsio, &
&monitor_stdio, outputtypesinclusive, dumpinitandlast

logical, private :: useaim
logical, private :: useatm2d
logical, private :: useatm_phys
logical, private :: useautodiff
logical, private :: usebbl
logical, private :: usebulkforce
logical, private :: usecal
logical, private :: usecheapaml
logical, private :: usectrl
logical, private :: usediagnostics
logical, private :: usedown_slope
logical, private :: useebm
logical, private :: useecco
logical, private :: useembed_files
logical, private :: useexf
logical, private :: usefizhi
logical, private :: useflt
logical, private :: usefrazil
logical, private :: usegad
logical, private :: usegchem
logical, private :: useggl90
logical, private :: usegmredi
logical, private :: usegrdchk
logical, private :: usegridalt
logical, private :: useicefront
logical, private :: useihop
logical, private :: usekl10
logical, private :: usekpp
logical, private :: useland
logical, private :: uselayers
logical, private :: usematrix
logical, private :: usemnc
logical, private :: usemy82
logical, private :: usemypackage
logical, private :: useobcs
logical, private :: useoffline
logical, private :: useopps
logical, private :: usepp81
logical, private :: useprofiles
logical, private :: useptracers
logical, private :: userbcs
logical, private :: useregrid
logical, private :: userunclock
logical, private :: usesalt_plume
logical, private :: usesbo
logical, private :: useseaice
logical, private :: useshap_filt
logical, private :: useshelfice
logical, private :: usesmooth
logical, private :: usestic
logical, private :: usestreamice
logical, private :: usethsice
logical, private :: usezonal_filt
common /parm_packages/ usegad, useobcs, useshap_filt, usezonal_filt, useopps, usepp81, usekl10, usemy82, useggl90, usekpp, usegmredi, usebbl, &
&usedown_slope, usecal, useexf, usebulkforce, useebm, usecheapaml, usegrdchk, usesmooth, useprofiles, useecco, usectrl, usesbo, useflt, useautodiff, &
&useptracers, usegchem, userbcs, useoffline, usematrix, usefrazil, useseaice, usesalt_plume, useshelfice, usestic, usestreamice, useicefront, &
&usethsice, useland, useatm2d, useaim, useatm_phys, usefizhi, usegridalt, usediagnostics, useregrid, uselayers, usemnc, userunclock, useembed_files, &
&usemypackage, useihop

double precision, private :: abeps
double precision, private :: adjdumpfreq
double precision, private :: adjmonitorfreq
double precision, private :: affacmom
double precision, private :: alph_ab
double precision, private :: basetime
double precision, private :: beta
double precision, private :: beta_ab
double precision, private :: bl79latvary
double precision, private :: bottomdraglinear
double precision, private :: bottomdragquadratic
double precision, private :: cadjfreq
double precision, private :: cffacmom
double precision, private :: cg2dpcoffdfac
double precision, private :: cg2dtargetresidual
double precision, private :: cg2dtargetreswunit
double precision, private :: cg3dtargetresidual
double precision, private :: cg3dtargetreswunit
double precision, private :: chkptfreq
double precision, private :: convertfw2salt
double precision, private :: cospower
double precision, private :: dbdrref(nr)
double precision, private :: delr(nr)
double precision, private :: delrc(nr+1)
double precision, private :: deltat
double precision, private :: deltatclock
double precision, private :: deltatfreesurf
double precision, private :: deltatmom
double precision, private :: diagfreq
double precision, private :: diffk4s
double precision, private :: diffk4t
double precision, private :: diffkhs
double precision, private :: diffkht
double precision, private :: diffkr4s(nr)
double precision, private :: diffkr4t(nr)
double precision, private :: diffkrbl79deep
double precision, private :: diffkrbl79ho
double precision, private :: diffkrbl79scl
double precision, private :: diffkrbl79surf
double precision, private :: diffkrbleqdeep
double precision, private :: diffkrbleqho
double precision, private :: diffkrbleqscl
double precision, private :: diffkrbleqsurf
double precision, private :: diffkrnrs(nr)
double precision, private :: diffkrnrt(nr)
double precision, private :: drhosmall
double precision, private :: dttracerlev(nr)
double precision, private :: dumpfreq
double precision, private :: endtime
double precision, private :: epsab_cd
double precision, private :: externforcingcycle
double precision, private :: externforcingperiod
double precision, private :: f0
double precision, private :: fofacmom
double precision, private :: fprime
double precision, private :: freesurffac
double precision, private :: gbaro
double precision, private :: gravfacc(nr)
double precision, private :: gravfacf(nr+1)
double precision, private :: gravity
double precision, private :: hfacinf
double precision, private :: hfacmin
double precision, private :: hfacmindp
double precision, private :: hfacmindr
double precision, private :: hfacmindz
double precision, private :: hfacsup
double precision, private :: hmixcriteria
double precision, private :: hmixsmooth
double precision, private :: implicdiv2dflow
double precision, private :: implicitnhpress
double precision, private :: implicsurfpress
double precision, private :: ivdc_kappa
double precision, private :: latbandclimrelax
double precision, private :: mass2runit
double precision, private :: monitorfreq
double precision, private :: mtfacmom
double precision, private :: nh_am2
double precision, private :: omega
double precision, private :: pcellmix_delr
double precision, private :: pcellmix_diffkr(nr)
double precision, private :: pcellmix_maxfac
double precision, private :: pcellmix_viscar(nr)
double precision, private :: pchkptfreq
double precision, private :: pffacmom
double precision, private :: phieuler
double precision, private :: phiref(2*nr+1)
double precision, private :: pref4eos(nr)
double precision, private :: psieuler
double precision, private :: radius_fromhorizgrid
double precision, private :: rcd
double precision, private :: recip_gravfacc(nr)
double precision, private :: recip_gravfacf(nr+1)
double precision, private :: recip_gravity
double precision, private :: recip_rhoconst
double precision, private :: recip_rhofacc(nr)
double precision, private :: recip_rhofacf(nr+1)
double precision, private :: recip_rsphere
double precision, private :: rho1ref(nr)
double precision, private :: rhoconst
double precision, private :: rhoconstfresh
double precision, private :: rhofacc(nr)
double precision, private :: rhofacf(nr+1)
double precision, private :: rhonil
double precision, private :: rhoref(nr)
double precision, private :: rotationperiod
double precision, private :: rsigmabnd
double precision, private :: rsphere
double precision, private :: runit2mass
double precision, private :: runit2z(nr)
double precision, private :: rvel2wunit(nr+1)
double precision, private :: salt_addmass
double precision, private :: salt_evprrn
double precision, private :: sealev_z
double precision, private :: siceloadfac
double precision, private :: sidedragfactor
double precision, private :: smag3d_coeff
double precision, private :: smag3d_diffcoeff
double precision, private :: smoothabsfuncrange
double precision, private :: sref(nr)
double precision, private :: starttime
double precision, private :: surf_pref
double precision, private :: taucd
double precision, private :: tausaltclimrelax
double precision, private :: tauthetaclimrelax
double precision, private :: tave_lastiter
double precision, private :: tavefreq
double precision, private :: tcylin
double precision, private :: tcylout
double precision, private :: temp_addmass
double precision, private :: temp_evprrn
double precision, private :: thetaconst
double precision, private :: thetaeuler
double precision, private :: top_pres
double precision, private :: tref(nr)
double precision, private :: vffacmom
double precision, private :: visca4
double precision, private :: visca4d
double precision, private :: visca4grid
double precision, private :: visca4gridmax
double precision, private :: visca4gridmin
double precision, private :: visca4max
double precision, private :: visca4remax
double precision, private :: visca4w
double precision, private :: visca4z
double precision, private :: viscah
double precision, private :: viscahd
double precision, private :: viscahgrid
double precision, private :: viscahgridmax
double precision, private :: viscahgridmin
double precision, private :: viscahmax
double precision, private :: viscahremax
double precision, private :: viscahw
double precision, private :: viscahz
double precision, private :: viscarnr(nr)
double precision, private :: viscc2leith
double precision, private :: viscc2leithd
double precision, private :: viscc2leithqg
double precision, private :: viscc2smag
double precision, private :: viscc4leith
double precision, private :: viscc4leithd
double precision, private :: viscc4smag
double precision, private :: viscfacadj
double precision, private :: wunit2rvel(nr+1)
double precision, private :: xgorigin
double precision, private :: ygorigin
double precision, private :: z2runit(nr)
double precision, private :: zroughbot
common /parm_r/ cg2dtargetresidual, cg2dtargetreswunit, cg2dpcoffdfac, cg3dtargetresidual, cg3dtargetreswunit, delr, delrc, xgorigin, ygorigin, &
&rsphere, recip_rsphere, radius_fromhorizgrid, sealev_z, top_pres, rsigmabnd, deltat, deltatmom, dttracerlev, deltatfreesurf, deltatclock, abeps, &
&alph_ab, beta_ab, f0, beta, fprime, omega, rotationperiod, viscfacadj, viscah, viscahw, smag3d_coeff, smag3d_diffcoeff, viscahmax, viscahgrid, &
&viscahgridmax, viscahgridmin, viscc2leith, viscc2leithd, viscc2leithqg, viscc2smag, viscc4smag, viscahd, viscahz, visca4d, visca4z, visca4, visca4w,&
& visca4max, visca4grid, visca4gridmax, visca4gridmin, viscahremax, visca4remax, viscc4leith, viscc4leithd, viscarnr, diffkht, diffk4t, diffkrnrt, &
&diffkr4t, diffkhs, diffk4s, diffkrnrs, diffkr4s, diffkrbl79surf, diffkrbl79deep, diffkrbl79scl, diffkrbl79ho, bl79latvary, diffkrbleqsurf, &
&diffkrbleqdeep, diffkrbleqscl, diffkrbleqho, pcellmix_maxfac, pcellmix_delr, pcellmix_viscar, pcellmix_diffkr, taucd, rcd, epsab_cd, freesurffac, &
&implicsurfpress, implicdiv2dflow, implicitnhpress, hfacmin, hfacmindz, hfacinf, hfacsup, gravity, recip_gravity, gbaro, gravfacc, recip_gravfacc, &
&gravfacf, recip_gravfacf, rhonil, rhoconst, recip_rhoconst, rho1ref, rhofacc, recip_rhofacc, rhofacf, recip_rhofacf, rhoconstfresh, thetaconst, &
&tref, sref, rhoref, dbdrref, surf_pref, pref4eos, phiref, rvel2wunit, wunit2rvel, runit2z, z2runit, mass2runit, runit2mass, basetime, starttime, &
&endtime, chkptfreq, pchkptfreq, dumpfreq, adjdumpfreq, diagfreq, tavefreq, tave_lastiter, monitorfreq, adjmonitorfreq, affacmom, vffacmom, pffacmom,&
& cffacmom, fofacmom, mtfacmom, cospower, cadjfreq, tauthetaclimrelax, tausaltclimrelax, latbandclimrelax, externforcingcycle, externforcingperiod, &
&convertfw2salt, temp_evprrn, salt_evprrn, temp_addmass, salt_addmass, hfacmindr, hfacmindp, ivdc_kappa, hmixcriteria, drhosmall, hmixsmooth, &
&sidedragfactor, bottomdraglinear, bottomdragquadratic, zroughbot, nh_am2, smoothabsfuncrange, siceloadfac, tcylin, tcylout, phieuler, thetaeuler, &
&psieuler

!==============================================
! declare local variables
!==============================================
real(kind=8), public :: alphai = 0
real(kind=8), public :: alphar = 1500
real(kind=8), public :: alphar_tl = 0._ikind1
real(kind=8), public :: betai = 0
real(kind=8), public :: betar = 0
complex(kind=8), private :: ccoef(4,maxssp)
complex(kind=8), private :: ccoef_tl(4,maxssp)
complex(kind=8), private :: cspln(4,maxssp)
complex(kind=8), private :: cspln_tl(4,maxssp)
real(kind=8), private :: depth
logical, private :: foundr
logical, private :: foundz
integer, private :: iallocstat
integer, private :: iostat
integer, public :: isegr = 1
integer, public :: isegz = 1
integer, private :: iz
complex(kind=8), private :: n2(maxssp)
complex(kind=8), private :: n2_tl(maxssp)
complex(kind=8), private :: n2z(maxssp)
complex(kind=8), private :: n2z_tl(maxssp)
real(kind=8), public :: rhor = 1
real(kind=8), private :: w
real(kind=8), private :: w_tl

!==============================================
! declare derived type variables
!==============================================
type(sspstructure), public :: ssp
type(sspstructure_tl), public :: ssp_tl

!==============================================
! declare external procedures and functions
!==============================================
double precision, external :: chen_millero
private :: chen_millero
external :: chen_millero_tl
external :: mpi_comm_dup_fn
private :: mpi_comm_dup_fn
external :: mpi_comm_null_copy_fn
private :: mpi_comm_null_copy_fn
external :: mpi_comm_null_delete_fn
private :: mpi_comm_null_delete_fn
external :: mpi_conversion_fn_null
private :: mpi_conversion_fn_null
external :: mpi_dup_fn
private :: mpi_dup_fn
external :: mpi_null_copy_fn
private :: mpi_null_copy_fn
external :: mpi_null_delete_fn
private :: mpi_null_delete_fn
external :: mpi_type_dup_fn
private :: mpi_type_dup_fn
external :: mpi_type_null_copy_fn
private :: mpi_type_null_copy_fn
external :: mpi_type_null_delete_fn
private :: mpi_type_null_delete_fn
external :: mpi_win_dup_fn
private :: mpi_win_dup_fn
external :: mpi_win_null_copy_fn
private :: mpi_win_null_copy_fn
external :: mpi_win_null_delete_fn
private :: mpi_win_null_delete_fn
double precision, external :: mpi_wtick
private :: mpi_wtick
double precision, external :: mpi_wtime
private :: mpi_wtime
double precision, external :: pmpi_wtick
private :: pmpi_wtick
double precision, external :: pmpi_wtime
private :: pmpi_wtime

contains
  subroutine ccubic( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use splinec_mod, only : splineall

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: c_cmplx
  complex(kind=8) :: cz_cmplx
  complex(kind=8) :: czz_cmplx
  real(kind=8) :: hspline

  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  hspline = x(2)-ssp%z(isegz)
  call splineall( cspln(1,isegz),hspline,c_cmplx,cz_cmplx,czz_cmplx )
  c = dble(c_cmplx)
  cimag = aimag(c_cmplx)
  gradc = [ 0.0d0,dble(cz_cmplx) ]
  czz = dble(czz_cmplx)
  crr = 0.0d0
  crz = 0.0d0
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)
  end subroutine ccubic
  subroutine ccubic_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use splinec_mod, only : splineall,splineall_tl

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: c_tl
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: cimag_tl
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: crz_tl
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: czz_tl
  real(kind=8), intent(out) :: gradc(2)
  real(kind=8), intent(out) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(out) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: c_cmplx
  complex(kind=8) :: c_cmplx_tl
  complex(kind=8) :: cz_cmplx
  complex(kind=8) :: cz_cmplx_tl
  complex(kind=8) :: czz_cmplx
  complex(kind=8) :: czz_cmplx_tl
  real(kind=8) :: hspline
  real(kind=8) :: hspline_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  hspline_tl = x_tl(2)
  hspline = x(2)-ssp%z(isegz)
  call splineall_tl( cspln(1,isegz),cspln_tl(1,isegz),hspline,hspline_tl,c_cmplx,c_cmplx_tl,cz_cmplx,cz_cmplx_tl,czz_cmplx,czz_cmplx_tl )
  c_tl = real(c_cmplx_tl)
  c = dble(c_cmplx)
  cimag_tl = aimag(c_cmplx_tl)
  cimag = aimag(c_cmplx)
  gradc_tl = [ 0.d0,real(cz_cmplx_tl) ]
  gradc = [ 0.0d0,dble(cz_cmplx) ]
  czz_tl = real(czz_cmplx_tl)
  czz = dble(czz_cmplx)
  crr = 0.0d0
  crz_tl = 0._ikind2
  crz = 0.0d0
  w_tl = x_tl(2)/(ssp%z(isegz+1)-ssp%z(isegz))
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho_tl = w_tl*((-ssp%rho(isegz))+ssp%rho(isegz+1))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)

  end subroutine ccubic_tl
  subroutine clinear( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  c = real(ssp%c(isegz)+(x(2)-ssp%z(isegz))*ssp%cz(isegz))
  cimag = aimag(ssp%c(isegz)+(x(2)-ssp%z(isegz))*ssp%cz(isegz))
  gradc = [ 0.0d0,real(ssp%cz(isegz)) ]
  crr = 0.0d0
  crz = 0.0d0
  czz = 0.0d0
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)
  end subroutine clinear
  subroutine clinear_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: c_tl
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: cimag_tl
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: crz_tl
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: czz_tl
  real(kind=8), intent(out) :: gradc(2)
  real(kind=8), intent(out) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(out) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  c_tl = real(ssp_tl%c_tl(isegz)+ssp_tl%cz_tl(isegz)*(x(2)-ssp%z(isegz))+x_tl(2)*ssp%cz(isegz))
  c = real(ssp%c(isegz)+(x(2)-ssp%z(isegz))*ssp%cz(isegz))
  cimag_tl = aimag(ssp_tl%c_tl(isegz))+aimag((x(2)-ssp%z(isegz))*ssp_tl%cz_tl(isegz))+aimag(ssp%cz(isegz)*x_tl(2))
  cimag = aimag(ssp%c(isegz)+(x(2)-ssp%z(isegz))*ssp%cz(isegz))
  gradc_tl = [ 0.d0,real(ssp_tl%cz_tl(isegz)) ]
  gradc = [ 0.0d0,real(ssp%cz(isegz)) ]
  crr = 0.0d0
  crz_tl = 0._ikind3
  crz = 0.0d0
  czz_tl = 0._ikind2
  czz = 0.0d0
  w_tl = x_tl(2)/(ssp%z(isegz+1)-ssp%z(isegz))
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho_tl = w_tl*((-ssp%rho(isegz))+ssp%rho(isegz+1))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)

  end subroutine clinear_tl
  subroutine cpchip( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: c_cmplx
  real(kind=8) :: xt

  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  xt = x(2)-ssp%z(isegz)
  c_cmplx = ccoef(1,isegz)+(ccoef(2,isegz)+(ccoef(3,isegz)+ccoef(4,isegz)*xt)*xt)*xt
  c = real(c_cmplx)
  cimag = aimag(c_cmplx)
  gradc = [ 0.0d0,real(ccoef(2,isegz)+(2.0d0*ccoef(3,isegz)+3.0d0*ccoef(4,isegz)*xt)*xt) ]
  crr = 0.0d0
  crz = 0.0d0
  czz = real(2.0d0*ccoef(3,isegz)+6.0d0*ccoef(4,isegz)*xt)
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)
  end subroutine cpchip
  subroutine cpchip_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: c_tl
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: cimag_tl
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: crz_tl
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: czz_tl
  real(kind=8), intent(out) :: gradc(2)
  real(kind=8), intent(out) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(out) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: c_cmplx
  complex(kind=8) :: c_cmplx_tl
  real(kind=8) :: xt
  real(kind=8) :: xt_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  xt_tl = x_tl(2)
  xt = x(2)-ssp%z(isegz)
  c_cmplx_tl = ((ccoef_tl(4,isegz)*xt+ccoef_tl(3,isegz))*xt+ccoef_tl(2,isegz))*xt+ccoef_tl(1,isegz)+xt_tl*(ccoef(2,isegz)+(ccoef(3,isegz)+ccoef(4,&
&isegz)*xt)*xt+(ccoef(3,isegz)+ccoef(4,isegz)*xt+ccoef(4,isegz)*xt)*xt)
  c_cmplx = ccoef(1,isegz)+(ccoef(2,isegz)+(ccoef(3,isegz)+ccoef(4,isegz)*xt)*xt)*xt
  c_tl = real(c_cmplx_tl)
  c = real(c_cmplx)
  cimag_tl = aimag(c_cmplx_tl)
  cimag = aimag(c_cmplx)
  gradc_tl = [ 0.d0,real((3*ccoef_tl(4,isegz)*xt+2*ccoef_tl(3,isegz))*xt+ccoef_tl(2,isegz)+xt_tl*(2.0d0*ccoef(3,isegz)+3.0d0*ccoef(4,isegz)*xt+3*&
&ccoef(4,isegz)*xt)) ]
  gradc = [ 0.0d0,real(ccoef(2,isegz)+(2.0d0*ccoef(3,isegz)+3.0d0*ccoef(4,isegz)*xt)*xt) ]
  crr = 0.0d0
  crz_tl = 0._ikind2
  crz = 0.0d0
  czz_tl = real(6*ccoef_tl(4,isegz)*xt+2*ccoef_tl(3,isegz)+6*xt_tl*ccoef(4,isegz))
  czz = real(2.0d0*ccoef(3,isegz)+6.0d0*ccoef(4,isegz)*xt)
  w_tl = x_tl(2)/(ssp%z(isegz+1)-ssp%z(isegz))
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho_tl = w_tl*((-ssp%rho(isegz))+ssp%rho(isegz+1))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)

  end subroutine cpchip_tl
  subroutine evalssp( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

!==============================================
! declare local variables
!==============================================
  character(len=max_len_mbuf) :: msgbuf

  select case ( ssp%type )
  case ('N')
    call n2linear( x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  case ('C')
    call clinear( x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  case ('P')
    call cpchip( x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  case ('S')
    call ccubic( x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  case ('Q')
    call quad( x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  case default
    write(unit=msgbuf,fmt='(2A)') 'Profile option: ',ssp%type
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    write(unit=msgbuf,fmt='(A)') 'SSPMOD evalSSP: Invalid SSP profile option'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R evalSSP'
    c = 0.
    cimag = 0.
    gradc = 0.
    crr = 0.
    crz = 0.
    czz = 0.
    rho = 0.
  end select
  end subroutine evalssp
  subroutine evalssp_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8
  integer, parameter :: ikind7 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(inout) :: c
  real(kind=8), intent(inout) :: c_tl
  real(kind=8), intent(inout) :: cimag
  real(kind=8), intent(inout) :: cimag_tl
  real(kind=8), intent(inout) :: crr
  real(kind=8), intent(inout) :: crz
  real(kind=8), intent(inout) :: crz_tl
  real(kind=8), intent(inout) :: czz
  real(kind=8), intent(inout) :: czz_tl
  real(kind=8), intent(inout) :: gradc(2)
  real(kind=8), intent(inout) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(inout) :: rho
  real(kind=8), intent(inout) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!==============================================
! declare local variables
!==============================================
  character(len=max_len_mbuf) :: msgbuf

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  select case ( ssp%type )
  case ('N')
    call n2linear_tl( x,x_tl,c,c_tl,cimag,cimag_tl,gradc,gradc_tl,crr,crz,crz_tl,czz,czz_tl,rho,rho_tl,mythid )
  case ('C')
    call clinear_tl( x,x_tl,c,c_tl,cimag,cimag_tl,gradc,gradc_tl,crr,crz,crz_tl,czz,czz_tl,rho,rho_tl,mythid )
  case ('P')
    call cpchip_tl( x,x_tl,c,c_tl,cimag,cimag_tl,gradc,gradc_tl,crr,crz,crz_tl,czz,czz_tl,rho,rho_tl,mythid )
  case ('S')
    call ccubic_tl( x,x_tl,c,c_tl,cimag,cimag_tl,gradc,gradc_tl,crr,crz,crz_tl,czz,czz_tl,rho,rho_tl,mythid )
  case ('Q')
    call quad_tl( x,x_tl,c,c_tl,cimag,cimag_tl,gradc,gradc_tl,crr,crz,crz_tl,czz,czz_tl,rho,rho_tl,mythid )
  case default
    write(unit=msgbuf,fmt='(2A)') 'Profile option: ',ssp%type
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    write(unit=msgbuf,fmt='(A)') 'SSPMOD evalSSP: Invalid SSP profile option'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R evalSSP'
    c_tl = 0._ikind7
    c = 0.
    cimag_tl = 0._ikind6
    cimag = 0.
    gradc_tl = 0._ikind5
    gradc = 0.
    crr = 0.
    crz_tl = 0._ikind4
    crz = 0.
    czz_tl = 0._ikind3
    czz = 0.
    rho_tl = 0._ikind2
    rho = 0.
  end select

  end subroutine evalssp_tl
  subroutine gcmssp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use atten_mod, only : crci
  use bdry_mod, only : bdry

  implicit none

!==============================================
! declare common blocks
!==============================================
  integer :: ikey_dynamics
  common /tamc_keys_i/ ikey_dynamics

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  integer :: bi
  integer :: bj
  real(kind=8) :: bpower
  real(kind=8) :: dcdz
  real(kind=8) :: ft
  real(kind=8), allocatable :: globssp(:)
  integer :: hkey
  integer :: i
  integer :: iallocstat
  integer :: ii
  integer :: ijkey
  logical :: interp_finished
  integer :: j
  integer :: jj
  integer :: k
  integer :: lockey
  character(len=max_len_mbuf) :: msgbuf
  integer :: njj(ihop_npts_range)
  integer :: nznr_size
  real(kind=8), allocatable :: tilessp(:,:,:,:)
  integer :: tkey
  real(kind=8), allocatable :: tmpssp(:,:,:)
  real(kind=8) :: tolerance

  bpower = 1.0
  ft = 1000.0
  interp_finished =  .false. 
  njj = 0
  dcdz = 0.0d0
  tolerance = 5d-5
  nznr_size = ssp%nz*ssp%nr
  if (allocated(tilessp)) then
    deallocate( tilessp )
  endif
  if (allocated(globssp)) then
    deallocate( globssp )
  endif
  allocate( tilessp(ssp%nz,ssp%nr,nsx,nsy),stat=iallocstat )
  allocate( tmpssp(nsx,nsy,nznr_size),stat=iallocstat )
  allocate( globssp(nznr_size),stat=iallocstat )
  if (iallocstat /= 0) then
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD gcmSSP: ','Insufficient memory to store tileSSP and/or globSSP'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R gcmSSP'
  endif
  tilessp = 0.0d0
  tmpssp = 0.0d0
  globssp = 0.0d0
  do bj = mybylo(mythid), mybyhi(mythid)
    do bi = mybxlo(mythid), mybxhi(mythid)
      tkey = bi+(bj-1)*nsx+(ikey_dynamics-1)*nsx*nsy
      do j = 1, sny
        do i = 1, snx
          ijkey = i+(j-1)*snx+(tkey-1)*snx*sny
          do ii = 1, ihop_npts_range
            interp_finished =  .false. 
            do jj = 1, ihop_npts_idw
              if (abs(xc(i,j,bi,bj)-ihop_xc(ii,jj)) <= tolerance .and. abs(yc(i,j,bi,bj)-ihop_yc(ii,jj)) <= tolerance .and. ( .not. interp_finished))&
& then
njj(ii) = njj(ii)+1
do iz = 1, ssp%nz-1
  hkey = jj+(ii-1)*ihop_npts_idw+(ijkey-1)*sny*snx*nsy*nsx
  lockey = iz+(hkey-1)*(ssp%nz-1)*ihop_npts_idw*ihop_npts_range*snx*sny*nsx*nsy
  if (iz == 1) then
    tilessp(1,ii,bi,bj) = tilessp(1,ii,bi,bj)+chen_millero(i,j,0,bi,bj,mythid)*ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz)
  else
    if (ihop_sumweights(ii,iz-1) > 0.) then
      if (ihop_idw_weights(ii,jj) == 0.) then
        njj(ii) = ihop_npts_idw+1
      endif
      if (ihop_idw_weights(ii,jj) == 0.) then
        tilessp(iz,ii,bi,bj) = ihop_ssp(i,j,iz-1,bi,bj)
      else if (njj(ii) <= ihop_npts_idw) then
        tilessp(iz,ii,bi,bj) = tilessp(iz,ii,bi,bj)+ihop_ssp(i,j,iz-1,bi,bj)*ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz-1)
      else
        tilessp(iz,ii,bi,bj) = tilessp(iz,ii,bi,bj)
      endif
    endif
    if (iz == ssp%nz-1 .or. ihop_sumweights(ii,iz-1) == 0.0) then
      k = iz
      if (njj(ii) >= ihop_npts_idw) then
        if (iz == ssp%nz-1 .and. ihop_sumweights(ii,iz-1) /= 0.) then
          k = k+1
        endif
        dcdz = (tilessp(k-1,ii,bi,bj)-tilessp(k-2,ii,bi,bj))/(ssp%z(k-1)-ssp%z(k-2))
        tilessp(k:ssp%nz,ii,bi,bj) = tilessp(k-1,ii,bi,bj)+dcdz*ssp%z(k:ssp%nz)
        interp_finished =  .true. 
      else
        interp_finished =  .false. 
      endif
    endif
  endif
end do
              endif
            end do
          end do
        end do
      end do
    end do
  end do
  do bj = mybylo(mythid), mybyhi(mythid)
    do bi = mybxlo(mythid), mybxhi(mythid)
      k = 1
      do jj = 1, ssp%nr
        do ii = 1, ssp%nz
          tmpssp(bi,bj,k) = tilessp(ii,jj,bi,bj)
          k = k+1
        end do
      end do
    end do
  end do
  call global_sum_vector_rl( nznr_size,tmpssp,globssp,mythid )
  k = 1
  do jj = 1, ssp%nr
    do ii = 1, ssp%nz
      ssp%cmat(ii,jj) = globssp(k)
      k = k+1
    end do
  end do
  if (allocated(tilessp)) then
    deallocate( tilessp )
  endif
  if (allocated(tmpssp)) then
    deallocate( tmpssp )
  endif
  if (allocated(globssp)) then
    deallocate( globssp )
  endif
  if ( .not. usesspfile) then
    do iz = 1, ssp%nz
      alphar = ssp%cmat(iz,1)
      ssp%c(iz) = crci(ssp%z(iz),alphar,alphai,ssp%attenunit,bpower,ft,mythid)
      ssp%rho(iz) = rhor
      if (iz > 1) then
        if (ssp%z(iz) <= ssp%z(iz-1)) then
          write(unit=msgbuf,fmt='(2A)') 'SSPMOD gcmSSP: ','The depths in the SSP must be monotone increasing'
          call print_error( msgbuf,mythid )
          stop 'ABNORMAL END: S/R gcmSSP'
        endif
      endif
      if (iz > 1) then
        ssp%cz(iz-1) = (ssp%c(iz)-ssp%c(iz-1))/(ssp%z(iz)-ssp%z(iz-1))
      endif
    end do
  endif
  end subroutine gcmssp
  subroutine gcmssp_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use atten_mod, only : crci,crci_tl
  use bdry_mod, only : bdry

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8

!==============================================
! declare common blocks
!==============================================
  integer :: ikey_dynamics
  common /tamc_keys_i/ ikey_dynamics

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  integer :: bi
  integer :: bj
  real(kind=8) :: bpower
  real(kind=8) :: dcdz
  real(kind=8) :: dcdz_tl
  real(kind=8) :: ft
  real(kind=8), allocatable :: globssp(:)
  real(kind=8), allocatable :: globssp_tl(:)
  integer :: hkey
  integer :: i
  integer :: iallocstat
  integer :: ii
  integer :: ijkey
  logical :: interp_finished
  integer :: j
  integer :: jj
  integer :: k
  integer :: lockey
  character(len=max_len_mbuf) :: msgbuf
  integer :: njj(ihop_npts_range)
  integer :: nznr_size
  real(kind=8), allocatable :: tilessp(:,:,:,:)
  real(kind=8), allocatable :: tilessp_tl(:,:,:,:)
  double precision :: tilessph
  double precision :: tilessph_tl
  integer :: tkey
  real(kind=8), allocatable :: tmpssp(:,:,:)
  real(kind=8), allocatable :: tmpssp_tl(:,:,:)
  real(kind=8) :: tolerance

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  bpower = 1.0
  ft = 1000.0
  interp_finished =  .false. 
  njj = 0
  dcdz_tl = 0._ikind5
  dcdz = 0.0d0
  tolerance = 5d-5
  nznr_size = ssp%nz*ssp%nr
  if (allocated(tilessp_tl)) then
    deallocate( tilessp_tl )
  endif
  if (allocated(tilessp)) then
    deallocate( tilessp )
  endif
  if (allocated(globssp_tl)) then
    deallocate( globssp_tl )
  endif
  if (allocated(globssp)) then
    deallocate( globssp )
  endif
  allocate( tilessp_tl(ssp%nz,ssp%nr,nsx,nsy) )
  allocate( tilessp(ssp%nz,ssp%nr,nsx,nsy),stat=iallocstat )
  allocate( tmpssp_tl(nsx,nsy,nznr_size) )
  allocate( tmpssp(nsx,nsy,nznr_size),stat=iallocstat )
  allocate( globssp_tl(nznr_size) )
  allocate( globssp(nznr_size),stat=iallocstat )
  if (iallocstat /= 0) then
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD gcmSSP: ','Insufficient memory to store tileSSP and/or globSSP'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R gcmSSP'
  endif
  tilessp_tl = 0._ikind4
  tilessp = 0.0d0
  tmpssp_tl = 0._ikind3
  tmpssp = 0.0d0
  globssp_tl = 0._ikind2
  globssp = 0.0d0
  do bj = mybylo(mythid), mybyhi(mythid)
    do bi = mybxlo(mythid), mybxhi(mythid)
      tkey = bi+(bj-1)*nsx+(ikey_dynamics-1)*nsx*nsy
      do j = 1, sny
        do i = 1, snx
          ijkey = i+(j-1)*snx+(tkey-1)*snx*sny
          do ii = 1, ihop_npts_range
            interp_finished =  .false. 
            do jj = 1, ihop_npts_idw
              if (abs(xc(i,j,bi,bj)-ihop_xc(ii,jj)) <= tolerance .and. abs(yc(i,j,bi,bj)-ihop_yc(ii,jj)) <= tolerance .and. ( .not. interp_finished))&
& then
njj(ii) = njj(ii)+1
do iz = 1, ssp%nz-1
  hkey = jj+(ii-1)*ihop_npts_idw+(ijkey-1)*sny*snx*nsy*nsx
  lockey = iz+(hkey-1)*(ssp%nz-1)*ihop_npts_idw*ihop_npts_range*snx*sny*nsx*nsy
  if (iz == 1) then
    call chen_millero_tl( tilessph,tilessph_tl,i,j,0,bi,bj,mythid )
    tilessp_tl(1,ii,bi,bj) = tilessp_tl(1,ii,bi,bj)+tilessph_tl*(ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz))
    tilessp(1,ii,bi,bj) = tilessp(1,ii,bi,bj)+tilessph*ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz)
  else
    if (ihop_sumweights(ii,iz-1) > 0.) then
      if (ihop_idw_weights(ii,jj) == 0.) then
        njj(ii) = ihop_npts_idw+1
      endif
      if (ihop_idw_weights(ii,jj) == 0.) then
        tilessp_tl(iz,ii,bi,bj) = ihop_ssp_tl(i,j,iz-1,bi,bj)
        tilessp(iz,ii,bi,bj) = ihop_ssp(i,j,iz-1,bi,bj)
      else if (njj(ii) <= ihop_npts_idw) then
        tilessp_tl(iz,ii,bi,bj) = ihop_ssp_tl(i,j,iz-1,bi,bj)*(ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz-1))+tilessp_tl(iz,ii,bi,bj)
        tilessp(iz,ii,bi,bj) = tilessp(iz,ii,bi,bj)+ihop_ssp(i,j,iz-1,bi,bj)*ihop_idw_weights(ii,jj)/ihop_sumweights(ii,iz-1)
      endif
    endif
    if (iz == ssp%nz-1 .or. ihop_sumweights(ii,iz-1) == 0.0) then
      k = iz
      if (njj(ii) >= ihop_npts_idw) then
        if (iz == ssp%nz-1 .and. ihop_sumweights(ii,iz-1) /= 0.) then
          k = k+1
        endif
        dcdz_tl = (-(tilessp_tl(k-2,ii,bi,bj)/(ssp%z(k-1)-ssp%z(k-2))))+tilessp_tl(k-1,ii,bi,bj)/(ssp%z(k-1)-ssp%z(k-2))
        dcdz = (tilessp(k-1,ii,bi,bj)-tilessp(k-2,ii,bi,bj))/(ssp%z(k-1)-ssp%z(k-2))
        tilessp_tl(k:ssp%nz,ii,bi,bj) = dcdz_tl*ssp%z(k:ssp%nz)+tilessp_tl(k-1,ii,bi,bj)
        tilessp(k:ssp%nz,ii,bi,bj) = tilessp(k-1,ii,bi,bj)+dcdz*ssp%z(k:ssp%nz)
        interp_finished =  .true. 
      else
        interp_finished =  .false. 
      endif
    endif
  endif
end do
              endif
            end do
          end do
        end do
      end do
    end do
  end do
  do bj = mybylo(mythid), mybyhi(mythid)
    do bi = mybxlo(mythid), mybxhi(mythid)
      k = 1
      do jj = 1, ssp%nr
        do ii = 1, ssp%nz
          tmpssp_tl(bi,bj,k) = tilessp_tl(ii,jj,bi,bj)
          tmpssp(bi,bj,k) = tilessp(ii,jj,bi,bj)
          k = k+1
        end do
      end do
    end do
  end do
  call global_sum_vector_rl( nznr_size,tmpssp_tl,globssp_tl,mythid )
  call global_sum_vector_rl( nznr_size,tmpssp,globssp,mythid )
  k = 1
  do jj = 1, ssp%nr
    do ii = 1, ssp%nz
      ssp_tl%cmat_tl(ii,jj) = globssp_tl(k)
      ssp%cmat(ii,jj) = globssp(k)
      k = k+1
    end do
  end do
  if (allocated(tilessp_tl)) then
    deallocate( tilessp_tl )
  endif
  if (allocated(tilessp)) then
    deallocate( tilessp )
  endif
  if (allocated(tmpssp_tl)) then
    deallocate( tmpssp_tl )
  endif
  if (allocated(tmpssp)) then
    deallocate( tmpssp )
  endif
  if (allocated(globssp_tl)) then
    deallocate( globssp_tl )
  endif
  if (allocated(globssp)) then
    deallocate( globssp )
  endif
  if ( .not. usesspfile) then
    do iz = 1, ssp%nz
      alphar_tl = ssp_tl%cmat_tl(iz,1)
      alphar = ssp%cmat(iz,1)
      call crci_tl( ssp%c(iz),ssp_tl%c_tl(iz),ssp%z(iz),alphar,alphar_tl,alphai,ssp%attenunit,bpower,ft,mythid )
      ssp%rho(iz) = rhor
      if (iz > 1) then
        if (ssp%z(iz) <= ssp%z(iz-1)) then
          write(unit=msgbuf,fmt='(2A)') 'SSPMOD gcmSSP: ','The depths in the SSP must be monotone increasing'
          call print_error( msgbuf,mythid )
          stop 'ABNORMAL END: S/R gcmSSP'
        endif
      endif
      if (iz > 1) then
        ssp_tl%cz_tl(iz-1) = (-(ssp_tl%c_tl(iz-1)/(ssp%z(iz)-ssp%z(iz-1))))+ssp_tl%c_tl(iz)/(ssp%z(iz)-ssp%z(iz-1))
        ssp%cz(iz-1) = (ssp%c(iz)-ssp%c(iz-1))/(ssp%z(iz)-ssp%z(iz-1))
      endif
    end do
  endif

  end subroutine gcmssp_tl
  subroutine init_fixed_ssp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use bdry_mod, only : bdry

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  integer :: bi
  integer :: bj
  integer :: i
  integer :: iallocstat
  integer :: ii
  integer :: j
  integer :: jj
  integer :: k
  character(len=max_len_mbuf) :: msgbuf
  integer :: nii(ihop_npts_range)
  integer :: njj(ihop_npts_range)
  logical :: skip_range
  real(kind=8) :: tolerance

  skip_range =  .false. 
  nii(:) = 0
  njj(:) = 0
  tolerance = 5d-5
  ssp%npts = -1
  ssp%z = -999.
  ssp%rho = -999.
  ssp%c = (-999.,0.)
  ssp%cz = (-999.,0.)
  ssp%nz = nr+2
  ssp%nr = ihop_npts_range
  ssp%npts = ssp%nz
  ssp%z(1) = 0.0d0
  ssp%z(2:ssp%nz-1) = rksign*rc(1:nr)
  ssp%z(ssp%nz) = bdry%bot%hs%depth
  allocate( ssp%seg%r(ssp%nr),stat=iallocstat )
  if (iallocstat /= 0) then
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD init_fixed_SSP: ','Insufficient memory to store SSP%Seg%R'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R init_fixed_SSP'
  endif
  ssp%seg%r(1:ssp%nr) = ihop_ranges(1:ssp%nr)
  ssp%seg%r = 1000.0*ssp%seg%r
  allocate( ssp%cmat(ssp%nz,ssp%nr),stat=iallocstat )
  allocate( ssp%czmat(ssp%nz-1,ssp%nr),stat=iallocstat )
  if (iallocstat /= 0) then
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD init_fixed_SSP: ','Insufficient memory to store SSP%cmat, SSP%czmat'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R init_fixed_SSP'
  endif
  ssp%cmat = -99.d0
  ssp%czmat = -99.d0

  allocate( ssp_tl%cmat_tl(ssp%nz,ssp%nr),stat=iallocstat )
  allocate( ssp_tl%czmat_tl(ssp%nz-1,ssp%nr),stat=iallocstat )
  ssp_tl%cmat_tl = -99.d0
  ssp_tl%czmat_tl = -99.d0

  do ii = 1, ssp%nr
    ihop_sumweights(ii,:) = sum(ihop_idw_weights(ii,:))
  end do
  do bj = mybylo(mythid), mybyhi(mythid)
    do bi = mybxlo(mythid), mybxhi(mythid)
      do j = 1, sny
        do i = 1, snx
          do ii = 1, ssp%nr
            skip_range =  .false. 
            do jj = 1, ihop_npts_idw
              if (abs(xc(i,j,bi,bj)-ihop_xc(ii,jj)) <= tolerance .and. abs(yc(i,j,bi,bj)-ihop_yc(ii,jj)) <= tolerance) then
do k = 1, nr
  if (nii(ii) == 1 .and. k > njj(ii)) then
    skip_range =  .true. 
  endif
  if ( .not. skip_range) then
    if (hfacc(i,j,k,bi,bj) == 0.) then
      ihop_sumweights(ii,k) = ihop_sumweights(ii,k)-ihop_idw_weights(ii,jj)
      if (ihop_idw_weights(ii,jj) == 0.) then
        ihop_sumweights(ii,k:nr) = 0.0
        nii(ii) = 1
        njj(ii) = k
      endif
    endif
    if (ihop_sumweights(ii,k) < 1d-13) then
      ihop_sumweights(ii,k) = 0.0
    endif
  endif
end do
              endif
            end do
          end do
        end do
      end do
    end do
  end do
  end subroutine init_fixed_ssp
  subroutine initssp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

  if (usesspfile) then
    call readssp( mythid )
  else
    call init_fixed_ssp( mythid )
  endif
  end subroutine initssp
  subroutine n2linear( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  c = real(1.0d0/sqrt((1.0d0-w)*n2(isegz)+w*n2(isegz+1)))
  cimag = aimag(1.0d0/sqrt((1.0d0-w)*n2(isegz)+w*n2(isegz+1)))
  gradc = [ 0.0d0,-(0.5d0*c*c*c*real(n2z(isegz))) ]
  crr = 0.0d0
  crz = 0.0d0
  czz = 3.0d0*gradc(2)*gradc(2)/c
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)
  end subroutine n2linear
  subroutine n2linear_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(inout) :: c
  real(kind=8), intent(inout) :: c_tl
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: cimag_tl
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: crz_tl
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: czz_tl
  real(kind=8), intent(inout) :: gradc(2)
  real(kind=8), intent(inout) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(out) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: ch
  complex(kind=8) :: cimagh
  real :: gradch

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%npts
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  w_tl = x_tl(2)/(ssp%z(isegz+1)-ssp%z(isegz))
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  ch = (1.0d0-w)*n2(isegz)+w*n2(isegz+1)
  c_tl = real(-((n2_tl(isegz+1)*w+n2_tl(isegz)*(1.0d0-w)+w_tl*((-n2(isegz))+n2(isegz+1)))*(1.0d0*(1._8/(2._8*sqrt(ch)))/sqrt(ch)/sqrt(ch))))
  c = real(1.0d0/sqrt(ch))
  cimagh = (1.0d0-w)*n2(isegz)+w*n2(isegz+1)
  cimag_tl = aimag(-(1.0d0*(1._8/(2._8*sqrt(cimagh)))/sqrt(cimagh)/sqrt(cimagh)*(n2_tl(isegz+1)*w+n2_tl(isegz)*(1.0d0-w)+w_tl*((-n2(isegz))+n2(isegz+&
&1)))))
  cimag = aimag(1.0d0/sqrt(cimagh))
  gradch = real(n2z(isegz))
  gradc_tl = [ 0.d0,(-(1.5d0*c*c*gradch*c_tl))-0.5d0*c*c*c*real(n2z_tl(isegz)) ]
  gradc = [ 0.0d0,-(0.5d0*c*c*c*gradch) ]
  crr = 0.0d0
  crz_tl = 0._ikind2
  crz = 0.0d0
  czz_tl = (-(c_tl*(3.0d0*gradc(2)*gradc(2)/c/c)))+gradc_tl(2)*(6*gradc(2)/c)
  czz = 3.0d0*gradc(2)*gradc(2)/c
  rho_tl = w_tl*((-ssp%rho(isegz))+ssp%rho(isegz+1))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)

  end subroutine n2linear_tl
  subroutine quad( x, c, cimag, gradc, crr, crz, czz, rho, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: gradc(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(in) :: x(2)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: c1
  real(kind=8) :: c2
  real(kind=8) :: cr
  real(kind=8) :: cz
  real(kind=8) :: cz1
  real(kind=8) :: cz2
  real(kind=8) :: delta_r
  real(kind=8) :: delta_z
  integer :: irt
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: s1
  real(kind=8) :: s2

  c1 = 0.
  c2 = 0.
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%nz
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  if (x(1) < ssp%seg%r(1) .or. x(1) > ssp%seg%r(ssp%nr)) then
    if (ihop_dumpfreq >= 0) then
      write(unit=msgbuf,fmt='(2A)') 'ray is outside the box where ocean ','soundspeed is defined'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(A,2F13.4)') ' x = ( r, z ) = ',x
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(2A)') 'SSPMOD Quad: ','ray is outside the box where the soundspeed is defined'
      call print_error( msgbuf,mythid )
    endif
    stop 'ABNORMAL END: S/R Quad'
  endif
  isegr = 1
  if (x(1) < ssp%seg%r(isegr) .or. x(1) >= ssp%seg%r(isegr+1)) then
    foundr =  .false. 
    do irt = 2, ssp%nr
      if (x(1) < ssp%seg%r(irt) .and. ( .not. foundr)) then
        isegr = irt-1
        foundr =  .true. 
      endif
    end do
  endif
  s2 = x(2)-ssp%z(isegz)
  delta_z = ssp%z(isegz+1)-ssp%z(isegz)
  if (delta_z <= 0 .or. s2 > delta_z) then
    write(unit=msgbuf,fmt=*) delta_z,s2,isegz,ssp%z(isegz)
    call print_error( msgbuf,mythid )
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD Quad: ','depth is not monotonically increasing in SSP%Z'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Quad'
  endif
  cz1 = ssp%czmat(isegz,isegr)
  cz2 = ssp%czmat(isegz,isegr+1)
  c1 = ssp%cmat(isegz,isegr)+s2*cz1
  c2 = ssp%cmat(isegz,isegr+1)+s2*cz2
  if (c1 == 0 .or. c2 == 0) then
    stop 'ABNORMAL END: S/R QUAD'
  endif
  delta_r = ssp%seg%r(isegr+1)-ssp%seg%r(isegr)
  s1 = (x(1)-ssp%seg%r(isegr))/delta_r
  s1 = min(s1,1.0d0)
  s1 = max(s1,0.0d0)
  c = (1.0d0-s1)*c1+s1*c2
  s2 = s2/delta_z
  cimag = aimag((1.0d0-s2)*ssp%c(isegz)+s2*ssp%c(isegz+1))
  cz = (1.0d0-s1)*cz1+s1*cz2
  cr = (c2-c1)/delta_r
  crz = (cz2-cz1)/delta_r
  gradc = [ cr,cz ]
  crr = 0.0
  czz = 0.0
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)
  end subroutine quad
  subroutine quad_tl( x, x_tl, c, c_tl, cimag, cimag_tl, gradc, gradc_tl, crr, crz, crz_tl, czz, czz_tl, rho, rho_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind7 = 8
  integer, parameter :: ikind8 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: c
  real(kind=8), intent(out) :: c_tl
  real(kind=8), intent(out) :: cimag
  real(kind=8), intent(out) :: cimag_tl
  real(kind=8), intent(out) :: crr
  real(kind=8), intent(out) :: crz
  real(kind=8), intent(out) :: crz_tl
  real(kind=8), intent(out) :: czz
  real(kind=8), intent(out) :: czz_tl
  real(kind=8), intent(out) :: gradc(2)
  real(kind=8), intent(out) :: gradc_tl(2)
  integer, intent(in) :: mythid
  real(kind=8), intent(out) :: rho
  real(kind=8), intent(out) :: rho_tl
  real(kind=8), intent(in) :: x(2)
  real(kind=8), intent(in) :: x_tl(2)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: c1
  real(kind=8) :: c1_tl
  real(kind=8) :: c2
  real(kind=8) :: c2_tl
  real(kind=8) :: cr
  real(kind=8) :: cr_tl
  real(kind=8) :: cz
  real(kind=8) :: cz1
  real(kind=8) :: cz1_tl
  real(kind=8) :: cz2
  real(kind=8) :: cz2_tl
  real(kind=8) :: cz_tl
  real(kind=8) :: delta_r
  real(kind=8) :: delta_z
  integer :: irt
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: s1
  real(kind=8) :: s1_tl
  real(kind=8) :: s2
  real(kind=8) :: s2_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  c1_tl = 0._ikind8
  c1 = 0.
  c2_tl = 0._ikind7
  c2 = 0.
  isegz = 1
  if (x(2) < ssp%z(isegz) .or. x(2) > ssp%z(isegz+1)) then
    foundz =  .false. 
    do iz = 2, ssp%nz
      if (x(2) < ssp%z(iz) .and. ( .not. foundz)) then
        isegz = iz-1
        foundz =  .true. 
      endif
    end do
  endif
  if (x(1) < ssp%seg%r(1) .or. x(1) > ssp%seg%r(ssp%nr)) then
    if (ihop_dumpfreq >= 0) then
      write(unit=msgbuf,fmt='(2A)') 'ray is outside the box where ocean ','soundspeed is defined'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(A,2F13.4)') ' x = ( r, z ) = ',x
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(2A)') 'SSPMOD Quad: ','ray is outside the box where the soundspeed is defined'
      call print_error( msgbuf,mythid )
    endif
    stop 'ABNORMAL END: S/R Quad'
  endif
  isegr = 1
  if (x(1) < ssp%seg%r(isegr) .or. x(1) >= ssp%seg%r(isegr+1)) then
    foundr =  .false. 
    do irt = 2, ssp%nr
      if (x(1) < ssp%seg%r(irt) .and. ( .not. foundr)) then
        isegr = irt-1
        foundr =  .true. 
      endif
    end do
  endif
  s2_tl = x_tl(2)
  s2 = x(2)-ssp%z(isegz)
  delta_z = ssp%z(isegz+1)-ssp%z(isegz)
  if (delta_z <= 0 .or. s2 > delta_z) then
    write(unit=msgbuf,fmt=*) delta_z,s2,isegz,ssp%z(isegz)
    call print_error( msgbuf,mythid )
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD Quad: ','depth is not monotonically increasing in SSP%Z'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Quad'
  endif
  cz1_tl = ssp_tl%czmat_tl(isegz,isegr)
  cz1 = ssp%czmat(isegz,isegr)
  cz2_tl = ssp_tl%czmat_tl(isegz,isegr+1)
  cz2 = ssp%czmat(isegz,isegr+1)
  c1_tl = cz1_tl*s2+s2_tl*cz1+ssp_tl%cmat_tl(isegz,isegr)
  c1 = ssp%cmat(isegz,isegr)+s2*cz1
  c2_tl = cz2_tl*s2+s2_tl*cz2+ssp_tl%cmat_tl(isegz,isegr+1)
  c2 = ssp%cmat(isegz,isegr+1)+s2*cz2
  if (c1 == 0 .or. c2 == 0) then
    stop 'ABNORMAL END: S/R QUAD'
  endif
  delta_r = ssp%seg%r(isegr+1)-ssp%seg%r(isegr)
  s1_tl = x_tl(1)/delta_r
  s1 = (x(1)-ssp%seg%r(isegr))/delta_r
  s1_tl = s1_tl*(0.5+sign(0.5d0,1.0d0-s1))
  s1 = min(s1,1.0d0)
  s1_tl = s1_tl*(0.5+sign(0.5d0,s1-0.0d0))
  s1 = max(s1,0.0d0)
  c_tl = c1_tl*(1.0d0-s1)+c2_tl*s1+s1_tl*((-c1)+c2)
  c = (1.0d0-s1)*c1+s1*c2
  s2_tl = s2_tl/delta_z
  s2 = s2/delta_z
  cimag_tl = aimag(((-ssp%c(isegz))+ssp%c(isegz+1))*s2_tl)+aimag(s2*ssp_tl%c_tl(isegz+1))+aimag((1.0d0-s2)*ssp_tl%c_tl(isegz))
  cimag = aimag((1.0d0-s2)*ssp%c(isegz)+s2*ssp%c(isegz+1))
  cz_tl = cz1_tl*(1.0d0-s1)+cz2_tl*s1+s1_tl*((-cz1)+cz2)
  cz = (1.0d0-s1)*cz1+s1*cz2
  cr_tl = (-(c1_tl/delta_r))+c2_tl/delta_r
  cr = (c2-c1)/delta_r
  crz_tl = (-(cz1_tl/delta_r))+cz2_tl/delta_r
  crz = (cz2-cz1)/delta_r
  gradc_tl = [ cr_tl,cz_tl ]
  gradc = [ cr,cz ]
  crr = 0.0
  czz_tl = 0._ikind2
  czz = 0.0
  w_tl = x_tl(2)/(ssp%z(isegz+1)-ssp%z(isegz))
  w = (x(2)-ssp%z(isegz))/(ssp%z(isegz+1)-ssp%z(isegz))
  rho_tl = w_tl*((-ssp%rho(isegz))+ssp%rho(isegz+1))
  rho = (1.0d0-w)*ssp%rho(isegz)+w*ssp%rho(isegz+1)

  end subroutine quad_tl
  subroutine readssp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use atten_mod, only : crci
  use ihop_mod, only : sspfile
  use bdry_mod, only : bdry

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: bpower
  real(kind=8) :: depth
  real(kind=8) :: ft
  character(len=max_len_mbuf) :: msgbuf

  bpower = 1.0
  ft = 1000.0
  depth = bdry%bot%hs%depth
  if (mythid == 1) then
    open(file=trim(ihop_fileroot)//'.ssp',unit=sspfile,form='FORMATTED',status='OLD',iostat=iostat)
    if (iostat /= 0) then
      write(unit=msgbuf,fmt='(A)') 'SSPMOD ReadSSP: Unable to open the SSP file'
      call print_error( msgbuf,mythid )
      stop 'ABNORMAL END: S/R ReadSSP'
    endif
    read(unit=sspfile,fmt=*) ssp%nr,ssp%nz
    allocate( ssp%cmat(ssp%nz,ssp%nr),stat=iallocstat )
    allocate( ssp%czmat(ssp%nz-1,ssp%nr),stat=iallocstat )
    allocate( ssp%seg%r(ssp%nr),stat=iallocstat )
    if (iallocstat /= 0) then
      write(unit=msgbuf,fmt='(2A)') 'SSPMOD ReadSSP: ','Insufficient memory to store SSP'
      call print_error( msgbuf,mythid )
      stop 'ABNORMAL END: S/R ReadSSP'
    endif
    ssp%cmat = -99.d0
    ssp%czmat = -99.d0
    read(unit=sspfile,fmt=*) ssp%seg%r(1:ssp%nr)
    ssp%seg%r = 1000.0*ssp%seg%r
    read(unit=sspfile,fmt=*) ssp%z(1:ssp%nz)
    do iz = 1, ssp%nz
      read(unit=sspfile,fmt=*) ssp%cmat(iz,:)
    end do
    close(unit=sspfile)
    ssp%npts = 1
    do iz = 1, maxssp
      alphar = ssp%cmat(iz,1)
      ssp%c(iz) = crci(ssp%z(iz),alphar,alphai,ssp%attenunit,bpower,ft,mythid)
      ssp%rho(iz) = rhor
      if (iz > 1) then
        if (ssp%z(iz) <= ssp%z(iz-1)) then
          write(unit=msgbuf,fmt='(2A,F10.2)') 'SSPMOD ReadSSP: ','The depths in the SSP must be monotone increasing',ssp%z(iz)
          call print_error( msgbuf,mythid )
          stop 'ABNORMAL END: S/R ReadSSP'
        endif
      endif
      if (iz > 1) then
        ssp%cz(iz-1) = (ssp%c(iz)-ssp%c(iz-1))/(ssp%z(iz)-ssp%z(iz-1))
      endif
      if (abs(ssp%z(iz)-depth) < 100.*epsilon(1.0e0)) then
        if (ssp%npts == 1) then
          write(unit=msgbuf,fmt='(2A)') 'SSPMOD ReadSSP: ','The SSP must have at least 2 points'
          call print_error( msgbuf,mythid )
          stop 'ABNORMAL END: S/R ReadSSP'
        endif
        goto 99999
      endif
      ssp%npts = ssp%npts+1
    end do
    write(unit=msgbuf,fmt='(2A)') 'SSPMOD ReadSSP: ','Number of SSP points exceeds limit'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R ReadSSP'
  endif
  99999 continue
  end subroutine readssp
  subroutine setssp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use pchip_mod, only : pchip
  use splinec_mod, only : cspline

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  integer :: ir
  integer :: iz
  integer :: mpirc
  character(len=max_len_mbuf) :: msgbuf

  mpirc = 0
  n2 = (-1.,-1.)
  n2z = (-1.,-1.)
  cspln = (-1.,-1.)
  ccoef = (-1.,-1.)
  if ( .not. usesspfile) then
    call gcmssp( mythid )
  endif
  if ( .not. usingmpi) then
    call writessp( mythid )
  else
    call mpi_comm_rank( mpi_comm_model,mpimyid,mpirc )
    myprocid = mpimyid
    if (myprocid == 0) then
      call writessp( mythid )
    endif
  endif
  select case ( ssp%type )
  case ('N')
    n2(1:ssp%npts) = 1.0/ssp%c(1:ssp%npts)**2
    do iz = 2, ssp%npts
      n2z(iz-1) = (n2(iz)-n2(iz-1))/(ssp%z(iz)-ssp%z(iz-1))
    end do
  case ('C')
  case ('P')
    call pchip( ssp%z,ssp%c,ssp%npts,ccoef,cspln )
  case ('S')
    cspln(1,1:ssp%npts) = ssp%c(1:ssp%npts)
    call cspline( ssp%z,cspln(1,1),ssp%npts,0,0,ssp%npts )
  case ('Q')
    do ir = 1, ssp%nr
      do iz = 2, ssp%nz
        ssp%czmat(iz-1,ir) = (ssp%cmat(iz,ir)-ssp%cmat(iz-1,ir))/(ssp%z(iz)-ssp%z(iz-1))
      end do
    end do
  case default
    write(unit=msgbuf,fmt='(A)') 'SSPMOD setSSP: Invalid SSP profile option'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R setSSP'
  end select
  end subroutine setssp
  subroutine setssp_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use pchip_mod, only : pchip,pchip_tl
  use splinec_mod, only : cspline,cspline_tl

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  integer :: ir
  integer :: iz
  integer :: mpirc
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: ssph_tl(maxssp)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  mpirc = 0
  n2_tl = (0._ikind6,0._ikind6)
  n2 = (-1.,-1.)
  n2z_tl = (0._ikind5,0._ikind5)
  n2z = (-1.,-1.)
  cspln_tl = (0._ikind4,0._ikind4)
  cspln = (-1.,-1.)
  ccoef_tl = (0._ikind3,0._ikind3)
  ccoef = (-1.,-1.)
  if ( .not. usesspfile) then
    call gcmssp_tl( mythid )
  endif
  if ( .not. usingmpi) then
    call writessp( mythid )
  else
    call mpi_comm_rank( mpi_comm_model,mpimyid,mpirc )
    myprocid = mpimyid
    if (myprocid == 0) then
      call writessp( mythid )
    endif
  endif
  select case ( ssp%type )
  case ('N')
    n2_tl(1:ssp%npts) = -(ssp_tl%c_tl(1:ssp%npts)*(2*ssp%c(1:ssp%npts)/ssp%c(1:ssp%npts)**2/ssp%c(1:ssp%npts)**2))
    n2(1:ssp%npts) = 1.0/ssp%c(1:ssp%npts)**2
    do iz = 2, ssp%npts
      n2z_tl(iz-1) = (-(n2_tl(iz-1)/(ssp%z(iz)-ssp%z(iz-1))))+n2_tl(iz)/(ssp%z(iz)-ssp%z(iz-1))
      n2z(iz-1) = (n2(iz)-n2(iz-1))/(ssp%z(iz)-ssp%z(iz-1))
    end do
  case ('C')
  case ('P')
    ssph_tl = 0._ikind2
    call pchip_tl( ssp%z,ssph_tl,ssp%c,ssp_tl%c_tl,ssp%npts,ccoef,ccoef_tl,cspln,cspln_tl )
  case ('S')
    cspln_tl(1,1:ssp%npts) = ssp_tl%c_tl(1:ssp%npts)
    cspln(1,1:ssp%npts) = ssp%c(1:ssp%npts)
    call cspline_tl( ssp%z,cspln(1,1),cspln_tl(1,1),ssp%npts,0,0,ssp%npts )
  case ('Q')
    do ir = 1, ssp%nr
      do iz = 2, ssp%nz
        ssp_tl%czmat_tl(iz-1,ir) = (-(ssp_tl%cmat_tl(iz-1,ir)/(ssp%z(iz)-ssp%z(iz-1))))+ssp_tl%cmat_tl(iz,ir)/(ssp%z(iz)-ssp%z(iz-1))
        ssp%czmat(iz-1,ir) = (ssp%cmat(iz,ir)-ssp%cmat(iz-1,ir))/(ssp%z(iz)-ssp%z(iz-1))
      end do
    end do
  case default
    write(unit=msgbuf,fmt='(A)') 'SSPMOD setSSP: Invalid SSP profile option'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R setSSP'
  end select

  end subroutine setssp_tl
  subroutine writessp( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_mod, only : prtfile

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  character(len=80) :: fmtstr
  integer :: iz
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: ssptmp(ssp%nr)

  if (ihop_dumpfreq < 0) then
    goto 99999
  endif
  ssptmp = 0.0
  if (mythid == 1) then
    write(unit=msgbuf,fmt='(A)') '___________________________________________________________'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)') 'Sound Speed Field'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(2A)') 'Profile option: ',ssp%type
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    if (ssp%nr > 1) then
      write(unit=msgbuf,fmt='(A)') 'Using range-dependent sound speed'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    if (ssp%nr == 1) then
      write(unit=msgbuf,fmt='(A)') 'Using range-independent sound speed'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    write(unit=msgbuf,fmt='(A,I10)') 'Number of SSP ranges = ',ssp%nr
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A,I10)') 'Number of SSP depths = ',ssp%nz
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)') 'Profile ranges [km]:'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=fmtstr,fmt='(A,I10,A)') '(T11,',ssp%nr,'F10.2)'
    ssptmp = ssp%seg%r(1:ssp%nr)/1000.0
    write(unit=msgbuf,fmt=fmtstr) ssptmp
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)') 'Sound speed matrix:'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)') ' Depth [m ]     Soundspeed [m/s]'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    ssptmp = 0.0
    write(unit=fmtstr,fmt='(A,I10,A)') '(',ssp%nr+1,'F10.2)'
    do iz = 1, ssp%nz
      ssptmp = ssp%cmat(iz,:)
      write(unit=msgbuf,fmt=fmtstr) ssp%z(iz),ssptmp
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    end do
    if (usesspfile) then
      write(unit=msgbuf,fmt='(A)')
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(A)') 'Sound speed profile:'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(2A)') '      z         alphaR      betaR     rho      ','  alphaI     betaI'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(2A)') '     [m]         [m/s]      [m/s]   [g/cm^3]   ','   [m/s]     [m/s]'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(A)') '___________________________________________________________'
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      write(unit=msgbuf,fmt='(A)')
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
      do iz = 1, ssp%npts
        write(unit=msgbuf,fmt='( F10.2, 3X, 2F10.2, 3X, F6.2, 3X, 2F10.4)') ssp%z(iz),ssp%cmat(iz,1),betar,rhor,alphai,betai
        call print_message( msgbuf,prtfile,squeeze_right,mythid )
      end do
    endif
    write(unit=msgbuf,fmt='(A)') '___________________________________________________________'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
  endif
  call barrier( mythid )
  99999 continue
  end subroutine writessp
end module     ssp_mod
