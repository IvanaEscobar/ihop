!                           DISCLAIMER
! 
!   This file was generated by TAF version 6.8.11
! 
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
! 
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
! 
module     influence
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use ihop_mod, only : beam,nmax,nrz_per_range,onecmplx,prtfile,rad2deg,ray2d,srcdeclangle
use ihop_mod, only : ray2d_tl
use srpos_mod, only : pos

implicit none

!==============================================
! write visibility
!==============================================
private
public :: calculateinfluence
public :: calculateinfluence_tl
public :: scalepressure
public :: scalepressure_tl

!==============================================
! declare parameters
!==============================================
integer, private, parameter :: cachelinesize = 256
character(len=*), private, parameter :: commentcharacter = '#'
integer, private, parameter :: debleva = 1
integer, private, parameter :: deblevb = 2
integer, private, parameter :: deblevc = 3
integer, private, parameter :: deblevd = 4
integer, private, parameter :: debleve = 5
integer, private, parameter :: deblevzero = 0
double precision, private, parameter :: pi = 3.14159265358979323844d0
double precision, private, parameter :: deg2rad = 2.d0*pi/360.d0
integer, private, parameter :: exch_ignore_corners = 0
integer, private, parameter :: exch_update_corners = 1
integer, private, parameter :: forward_simulation = 0
integer, private, parameter :: gsvec_size = 1024
double precision, private, parameter :: halfrl = 0.5d0
double precision, private, parameter :: halfrs = 0.5d0
integer, private, parameter :: ihop_max_idw = 4
integer, private, parameter :: ihop_max_nc_size = 15
integer, private, parameter :: ihop_max_range = 6
integer, private, parameter :: index_i = 1
integer, private, parameter :: index_j = 2
integer, private, parameter :: index_k = 3
integer, private, parameter :: index_none = 4
integer, private, parameter :: lshare1 = cachelinesize
integer, private, parameter :: lshare4 = cachelinesize/4
integer, private, parameter :: lshare8 = cachelinesize/8
integer, private, parameter :: max_len_fnam = 512
integer, private, parameter :: max_len_mbuf = 512
integer, private, parameter :: max_len_prec = 200
integer, private, parameter :: max_no_threads = 4
integer, private, parameter :: olx = 3
integer, private, parameter :: max_olx = olx
integer, private, parameter :: oly = 3
integer, private, parameter :: max_oly = oly
integer, private, parameter :: nfilesmax_ihop = 1
integer, private, parameter :: nobsmax_ihop = 10
integer, private, parameter :: npx = 1
integer, private, parameter :: npy = 1
integer, private, parameter :: nr = 15
integer, private, parameter :: nrd = 1
integer, private, parameter :: nrr = 1
integer, private, parameter :: nsd = 1
integer, private, parameter :: nsx = 1
integer, private, parameter :: nsy = 1
integer, private, parameter :: nts = 1080
integer, private, parameter :: snx = 62
integer, private, parameter :: nx = snx*nsx*npx
integer, private, parameter :: sny = 62
integer, private, parameter :: ny = sny*nsy*npy
double precision, private, parameter :: onerl = 1.0d0
double precision, private, parameter :: oners = 1.0d0
integer, private, parameter :: precfloat32 = 32
integer, private, parameter :: precfloat64 = 64
character(len=*), private, parameter :: print_map_xy = 'XY'
character(len=*), private, parameter :: print_map_xz = 'XZ'
character(len=*), private, parameter :: print_map_yz = 'YZ'
integer, private, parameter :: reverse_simulation = 1
character(len=*), private, parameter :: squeeze_both = 'B'
character(len=*), private, parameter :: squeeze_left = 'L'
character(len=*), private, parameter :: squeeze_right = 'R'
integer, private, parameter :: tangent_simulation = 2
double precision, private, parameter :: tworl = 2.0d0
double precision, private, parameter :: twors = 2.0d0
real, private, parameter :: unset_float4 = 1.234567e5
double precision, private, parameter :: unset_float8 = 1.234567d5
integer, private, parameter :: unset_i = 123456789
double precision, private, parameter :: unset_rl = 1.234567d5
double precision, private, parameter :: unset_rs = 1.234567d5
double precision, private, parameter :: zerorl = 0.0d0
double precision, private, parameter :: zerors = 0.0d0

!==============================================
! declare common blocks
!==============================================
integer, private :: eedataunit
integer, private :: errormessageunit
integer, private :: ioerrorcount(max_no_threads)
integer, private :: maxlengthprt1d
integer, private :: modeldataunit
integer, private :: mybxhi(max_no_threads)
integer, private :: mybxlo(max_no_threads)
integer, private :: mybyhi(max_no_threads)
integer, private :: mybylo(max_no_threads)
integer, private :: myprocid
integer, private :: mypx
integer, private :: mypy
integer, private :: myxgloballo
integer, private :: myygloballo
integer, private :: nthreads
integer, private :: ntx
integer, private :: nty
integer, private :: numberofprocs
integer, private :: pidio
integer, private :: scrunit1
integer, private :: scrunit2
integer, private :: standardmessageunit
common /eeparams_i/ errormessageunit, standardmessageunit, maxlengthprt1d, scrunit1, scrunit2, eedataunit, modeldataunit, numberofprocs, pidio, &
&myprocid, mypx, mypy, myxgloballo, myygloballo, nthreads, mybxlo, mybxhi, mybylo, mybyhi, ntx, nty, ioerrorcount

logical, private :: debugmode
logical, private :: eebooterror
logical, private :: eeenderror
logical, private :: fatalerror
logical, private :: printmapincludeszeros
logical, private :: usecoupler
logical, private :: usecubedsphereexchange
logical, private :: usenest2w_child
logical, private :: usenest2w_parent
logical, private :: usenest_child
logical, private :: usenest_parent
logical, private :: useoasis
logical, private :: usesetrlstk
logical, private :: usesigreg
logical, private :: usesinglecpuinput
logical, private :: usesinglecpuio
common /eeparams_l/ eebooterror, eeenderror, fatalerror, debugmode, usesinglecpuio, usesinglecpuinput, printmapincludeszeros, usecubedsphereexchange,&
& usecoupler, usenest_parent, usenest_child, usenest2w_parent, usenest2w_child, useoasis, usesetrlstk, usesigreg

logical, private :: ihop_mdsio
logical, private :: ihop_mnc
common /ihop_package/ ihop_mnc, ihop_mdsio

character(len=2), private :: ihop_botopt
character(len=max_len_fnam), private :: ihop_fileroot
character(len=max_len_fnam), private :: ihop_interpfile
character(len=7), private :: ihop_runopt
character(len=max_len_fnam), private :: ihop_title
character(len=6), private :: ihop_topopt
common /ihop_params_c/ ihop_fileroot, ihop_title, ihop_topopt, ihop_botopt, ihop_runopt, ihop_interpfile

integer, private :: ihop_iter(nts)
integer, private :: ihop_nalpha
integer, private :: ihop_npts_idw
integer, private :: ihop_npts_range
integer, private :: ihop_nrd
integer, private :: ihop_nrr
integer, private :: ihop_nsd
integer, private :: ihop_nts
common /ihop_params_i/ ihop_nts, ihop_nsd, ihop_nrd, ihop_nrr, ihop_npts_range, ihop_npts_idw, ihop_nalpha, ihop_iter

logical, private :: usesspfile
logical, private :: writedelay
common /ihop_params_l/ writedelay, usesspfile

double precision, private :: ihop_alpha(2)
double precision, private :: ihop_bcsound
double precision, private :: ihop_bcsoundi
double precision, private :: ihop_bcsoundshear
double precision, private :: ihop_bcsoundsheari
double precision, private :: ihop_brho
double precision, private :: ihop_depth
double precision, private :: ihop_dumpfreq
double precision, private :: ihop_freq
double precision, private :: ihop_idw_weights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_ranges(ihop_max_range)
double precision, private :: ihop_rd(nrd)
double precision, private :: ihop_rr(nrr)
double precision, private :: ihop_sd(nsd)
double precision, private :: ihop_step
double precision, private :: ihop_sumweights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_xc(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_yc(ihop_max_range,ihop_max_nc_size)
common /ihop_params_r/ ihop_dumpfreq, ihop_freq, ihop_depth, ihop_bcsound, ihop_bcsoundshear, ihop_brho, ihop_bcsoundi, ihop_bcsoundsheari, ihop_sd, &
&ihop_rd, ihop_rr, ihop_alpha, ihop_step, ihop_yc, ihop_xc, ihop_idw_weights, ihop_ranges, ihop_sumweights

double precision, private :: ihop_sld(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /ihop_state_2d/ ihop_sld

double precision, private :: ihop_ssp(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d/ ihop_ssp

double precision, private :: ihop_ssp_tl(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d_tl/ ihop_ssp_tl

double precision, private :: heatcapacity_cp
common /parm_a/ heatcapacity_cp

double precision, private :: atm_cp
double precision, private :: atm_kappa
double precision, private :: atm_po
double precision, private :: atm_rd
double precision, private :: atm_rq
double precision, private :: celsius2k
integer, private :: integr_geopot
integer, private :: selectfindrosurf
common /parm_atm/ celsius2k, atm_cp, atm_rd, atm_kappa, atm_rq, atm_po, integr_geopot, selectfindrosurf

character(len=max_len_fnam), private :: addmassfile
character(len=max_len_fnam), private :: addswallfile
character(len=max_len_fnam), private :: addwwallfile
character(len=max_len_fnam), private :: adtapedir
character(len=max_len_fnam), private :: bathyfile
character(len=max_len_fnam), private :: buoyancyrelation
character(len=max_len_fnam), private :: delrcfile
character(len=max_len_fnam), private :: delrfile
character(len=max_len_fnam), private :: delxfile
character(len=max_len_fnam), private :: delyfile
character(len=max_len_fnam), private :: diffkrfile
character(len=max_len_fnam), private :: eddypsixfile
character(len=max_len_fnam), private :: eddypsiyfile
character(len=max_len_fnam), private :: empmrfile
character(len=6), private :: eostype
character(len=max_len_fnam), private :: geopotanomfile
character(len=max_len_fnam), private :: geothermalfile
character(len=max_len_fnam), private :: gravityfile
character(len=max_len_fnam), private :: horizgridfile
character(len=max_len_fnam), private :: hybsigmfile
character(len=max_len_fnam), private :: hydrogsaltfile
character(len=max_len_fnam), private :: hydrogthetafile
character(len=max_len_fnam), private :: lambdasaltfile
character(len=max_len_fnam), private :: lambdathetafile
character(len=max_len_fnam), private :: mdsiolocaldir
character(len=max_len_fnam), private :: meridwindfile
character(len=10), private :: pickupsuff
character(len=max_len_fnam), private :: ploadfile
character(len=max_len_fnam), private :: psurfinitfile
character(len=max_len_fnam), private :: rhoreffile
character(len=max_len_fnam), private :: saltclimfile
character(len=max_len_fnam), private :: saltfluxfile
character(len=max_len_fnam), private :: sreffile
character(len=max_len_fnam), private :: surfqfile
character(len=max_len_fnam), private :: surfqnetfile
character(len=max_len_fnam), private :: surfqswfile
character(len=max_len_prec/2), private :: the_run_name
character(len=max_len_fnam), private :: thetaclimfile
character(len=max_len_fnam), private :: topofile
character(len=max_len_fnam), private :: treffile
character(len=max_len_fnam), private :: uvelinitfile
character(len=max_len_fnam), private :: visca4dfile
character(len=max_len_fnam), private :: visca4zfile
character(len=max_len_fnam), private :: viscahdfile
character(len=max_len_fnam), private :: viscahzfile
character(len=max_len_fnam), private :: vvelinitfile
character(len=max_len_fnam), private :: wghtbalancefile
character(len=max_len_fnam), private :: zonalwindfile
common /parm_c/ buoyancyrelation, eostype, pickupsuff, mdsiolocaldir, adtapedir, treffile, sreffile, rhoreffile, gravityfile, delrfile, delrcfile, &
&hybsigmfile, delxfile, delyfile, horizgridfile, bathyfile, topofile, addwwallfile, addswallfile, viscahdfile, viscahzfile, visca4dfile, visca4zfile,&
& hydrogthetafile, hydrogsaltfile, diffkrfile, zonalwindfile, meridwindfile, thetaclimfile, saltclimfile, empmrfile, saltfluxfile, surfqfile, &
&surfqnetfile, surfqswfile, uvelinitfile, vvelinitfile, psurfinitfile, ploadfile, geopotanomfile, addmassfile, eddypsixfile, eddypsiyfile, &
&geothermalfile, lambdathetafile, lambdasaltfile, wghtbalancefile, the_run_name

integer, private :: cg2dmaxiters
integer, private :: cg2dminitersnsa
integer, private :: cg2dprecondfreq
integer, private :: cg2duseminressol
integer, private :: cg3dmaxiters
integer, private :: debuglevel
integer, private :: momforcingoutab
integer, private :: monitorselect
integer, private :: nenditer
integer, private :: niter0
integer, private :: nonlinfreesurf
integer, private :: ntimesteps
integer, private :: ntimesteps_l2
integer, private :: pcellmix_select
integer, private :: plotlevel
integer, private :: printresidualfreq
integer, private :: readbinaryprec
integer, private :: rwsuffixtype
integer, private :: saltadvscheme
integer, private :: saltvertadvscheme
integer, private :: select3dcorischeme
integer, private :: select_rstar
integer, private :: selectaddfluid
integer, private :: selectbalanceempmr
integer, private :: selectbotdragquadr
integer, private :: selectcorimap
integer, private :: selectcorischeme
integer, private :: selectimplicitdrag
integer, private :: selectkescheme
integer, private :: selectmetricterms
integer, private :: selectnhfreesurf
integer, private :: selectp_ineos_zc
integer, private :: selectpenetratingsw
integer, private :: selectsigmacoord
integer, private :: selectvortscheme
integer, private :: tempadvscheme
integer, private :: tempvertadvscheme
integer, private :: tracforcingoutab
integer, private :: writebinaryprec
common /parm_i/ cg2dmaxiters, cg2dminitersnsa, cg2dprecondfreq, cg2duseminressol, cg3dmaxiters, printresidualfreq, niter0, ntimesteps, ntimesteps_l2,&
& nenditer, selectcorimap, selectsigmacoord, nonlinfreesurf, select_rstar, selectnhfreesurf, selectp_ineos_zc, selectaddfluid, selectbalanceempmr, &
&selectimplicitdrag, momforcingoutab, tracforcingoutab, tempadvscheme, tempvertadvscheme, saltadvscheme, saltvertadvscheme, selectkescheme, &
&selectvortscheme, selectmetricterms, selectcorischeme, select3dcorischeme, selectbotdragquadr, selectpenetratingsw, pcellmix_select, readbinaryprec,&
& writebinaryprec, rwsuffixtype, monitorselect, debuglevel, plotlevel

logical, private :: addfrictionheating
logical, private :: allowfreezing
logical, private :: applyexchuv_early
logical, private :: balanceprintmean
logical, private :: balanceqnet
logical, private :: balancesaltclimrelax
logical, private :: balancethetaclimrelax
logical, private :: bottomvisc_pcell
logical, private :: calc_wvelocity
logical, private :: checkinisalt
logical, private :: checkinitemp
logical, private :: deepatmosphere
logical, private :: doab_ongtgs
logical, private :: doresethfactors
logical, private :: dosaltclimrelax
logical, private :: dothetaclimrelax
logical, private :: dumpinitandlast
logical, private :: exactconserv
logical, private :: fluidisair
logical, private :: fluidiswater
logical, private :: globalfiles
logical, private :: haswetcscorners
logical, private :: highordervorticity
logical, private :: implicitdiffusion
logical, private :: implicitfreesurface
logical, private :: implicitintgravwave
logical, private :: implicitviscosity
logical, private :: interdiffkr_pcell
logical, private :: interviscar_pcell
logical, private :: linfsconservetr
logical, private :: maskinisalt
logical, private :: maskinitemp
logical, private :: momadvection
logical, private :: momdissip_in_ab
logical, private :: momforcing
logical, private :: momimplvertadv
logical, private :: mompressureforcing
logical, private :: momstepping
logical, private :: momtidalforcing
logical, private :: momviscosity
logical, private :: monitor_stdio
logical, private :: multidimadvection
logical, private :: no_slip_bottom
logical, private :: no_slip_sides
logical, private :: nonhydrostatic
logical, private :: outputtypesinclusive
logical, private :: periodicexternalforcing
logical, private :: pickup_read_mdsio
logical, private :: pickup_write_immed
logical, private :: pickup_write_mdsio
logical, private :: pickupstrictlymatch
logical, private :: quasihydrostatic
logical, private :: rigidlid
logical, private :: rotategrid
logical, private :: salt_staypositive
logical, private :: saltadvection
logical, private :: saltforcing
logical, private :: saltimplvertadv
logical, private :: saltisactivetr
logical, private :: saltstepping
logical, private :: saltvertdiff4
logical, private :: setcenterdr
logical, private :: setinterfdr
logical, private :: snapshot_mdsio
logical, private :: staggertimestep
logical, private :: startfrompickupab2
logical, private :: storephihyd4phys
logical, private :: temp_staypositive
logical, private :: tempadvection
logical, private :: tempforcing
logical, private :: tempimplvertadv
logical, private :: tempisactivetr
logical, private :: tempstepping
logical, private :: tempvertdiff4
logical, private :: timeave_mdsio
logical, private :: uniformfreesurflev
logical, private :: uniformlin_phisurf
logical, private :: upwindshear
logical, private :: upwindvorticity
logical, private :: use3dsolver
logical, private :: useabsvorticity
logical, private :: useareavisclength
logical, private :: usecdscheme
logical, private :: usecoriolis
logical, private :: usefullleith
logical, private :: usejamartmomadv
logical, private :: usemin4hfacedges
logical, private :: usemultidimadvec
logical, private :: usenhmterms
logical, private :: usensacgsolver
logical, private :: usepickupbeforec54
logical, private :: userealfreshwaterflux
logical, private :: usesmag3d
logical, private :: usesrcgsolver
logical, private :: usestraintensionvisc
logical, private :: usingcartesiangrid
logical, private :: usingcurvilineargrid
logical, private :: usingcylindricalgrid
logical, private :: usingpcoords
logical, private :: usingsphericalpolargrid
logical, private :: usingzcoords
logical, private :: vectorinvariantmomentum
logical, private :: writepickupatend
common /parm_l/ fluidisair, fluidiswater, usingpcoords, usingzcoords, usingcartesiangrid, usingsphericalpolargrid, rotategrid, usingcylindricalgrid, &
&usingcurvilineargrid, haswetcscorners, deepatmosphere, setinterfdr, setcenterdr, usemin4hfacedges, interviscar_pcell, interdiffkr_pcell, &
&no_slip_sides, no_slip_bottom, bottomvisc_pcell, usesmag3d, usefullleith, usestraintensionvisc, useareavisclength, momviscosity, momadvection, &
&momforcing, momtidalforcing, mompressureforcing, usenhmterms, usecoriolis, usecdscheme, vectorinvariantmomentum, usejamartmomadv, upwindvorticity, &
&highordervorticity, useabsvorticity, upwindshear, momstepping, calc_wvelocity, tempstepping, saltstepping, addfrictionheating, temp_staypositive, &
&salt_staypositive, tempadvection, tempvertdiff4, tempisactivetr, tempforcing, saltadvection, saltvertdiff4, saltisactivetr, saltforcing, &
&maskinitemp, maskinisalt, checkinitemp, checkinisalt, usensacgsolver, usesrcgsolver, rigidlid, implicitfreesurface, uniformlin_phisurf, &
&uniformfreesurflev, exactconserv, linfsconservetr, userealfreshwaterflux, storephihyd4phys, quasihydrostatic, nonhydrostatic, use3dsolver, &
&implicitintgravwave, staggertimestep, applyexchuv_early, doresethfactors, implicitdiffusion, implicitviscosity, tempimplvertadv, saltimplvertadv, &
&momimplvertadv, multidimadvection, usemultidimadvec, momdissip_in_ab, doab_ongtgs, balanceqnet, balanceprintmean, balancethetaclimrelax, &
&balancesaltclimrelax, dothetaclimrelax, dosaltclimrelax, allowfreezing, periodicexternalforcing, globalfiles, pickupstrictlymatch, &
&usepickupbeforec54, startfrompickupab2, pickup_read_mdsio, pickup_write_mdsio, pickup_write_immed, writepickupatend, timeave_mdsio, snapshot_mdsio, &
&monitor_stdio, outputtypesinclusive, dumpinitandlast

logical, private :: useaim
logical, private :: useatm2d
logical, private :: useatm_phys
logical, private :: useautodiff
logical, private :: usebbl
logical, private :: usebulkforce
logical, private :: usecal
logical, private :: usecheapaml
logical, private :: usectrl
logical, private :: usediagnostics
logical, private :: usedown_slope
logical, private :: useebm
logical, private :: useecco
logical, private :: useembed_files
logical, private :: useexf
logical, private :: usefizhi
logical, private :: useflt
logical, private :: usefrazil
logical, private :: usegad
logical, private :: usegchem
logical, private :: useggl90
logical, private :: usegmredi
logical, private :: usegrdchk
logical, private :: usegridalt
logical, private :: useicefront
logical, private :: useihop
logical, private :: usekl10
logical, private :: usekpp
logical, private :: useland
logical, private :: uselayers
logical, private :: usematrix
logical, private :: usemnc
logical, private :: usemy82
logical, private :: usemypackage
logical, private :: useobcs
logical, private :: useoffline
logical, private :: useopps
logical, private :: usepp81
logical, private :: useprofiles
logical, private :: useptracers
logical, private :: userbcs
logical, private :: useregrid
logical, private :: userunclock
logical, private :: usesalt_plume
logical, private :: usesbo
logical, private :: useseaice
logical, private :: useshap_filt
logical, private :: useshelfice
logical, private :: usesmooth
logical, private :: usestic
logical, private :: usestreamice
logical, private :: usethsice
logical, private :: usezonal_filt
common /parm_packages/ usegad, useobcs, useshap_filt, usezonal_filt, useopps, usepp81, usekl10, usemy82, useggl90, usekpp, usegmredi, usebbl, &
&usedown_slope, usecal, useexf, usebulkforce, useebm, usecheapaml, usegrdchk, usesmooth, useprofiles, useecco, usectrl, usesbo, useflt, useautodiff, &
&useptracers, usegchem, userbcs, useoffline, usematrix, usefrazil, useseaice, usesalt_plume, useshelfice, usestic, usestreamice, useicefront, &
&usethsice, useland, useatm2d, useaim, useatm_phys, usefizhi, usegridalt, usediagnostics, useregrid, uselayers, usemnc, userunclock, useembed_files, &
&usemypackage, useihop

double precision, private :: abeps
double precision, private :: adjdumpfreq
double precision, private :: adjmonitorfreq
double precision, private :: affacmom
double precision, private :: alph_ab
double precision, private :: basetime
double precision, private :: beta
double precision, private :: beta_ab
double precision, private :: bl79latvary
double precision, private :: bottomdraglinear
double precision, private :: bottomdragquadratic
double precision, private :: cadjfreq
double precision, private :: cffacmom
double precision, private :: cg2dpcoffdfac
double precision, private :: cg2dtargetresidual
double precision, private :: cg2dtargetreswunit
double precision, private :: cg3dtargetresidual
double precision, private :: cg3dtargetreswunit
double precision, private :: chkptfreq
double precision, private :: convertfw2salt
double precision, private :: cospower
double precision, private :: dbdrref(nr)
double precision, private :: delr(nr)
double precision, private :: delrc(nr+1)
double precision, private :: deltat
double precision, private :: deltatclock
double precision, private :: deltatfreesurf
double precision, private :: deltatmom
double precision, private :: diagfreq
double precision, private :: diffk4s
double precision, private :: diffk4t
double precision, private :: diffkhs
double precision, private :: diffkht
double precision, private :: diffkr4s(nr)
double precision, private :: diffkr4t(nr)
double precision, private :: diffkrbl79deep
double precision, private :: diffkrbl79ho
double precision, private :: diffkrbl79scl
double precision, private :: diffkrbl79surf
double precision, private :: diffkrbleqdeep
double precision, private :: diffkrbleqho
double precision, private :: diffkrbleqscl
double precision, private :: diffkrbleqsurf
double precision, private :: diffkrnrs(nr)
double precision, private :: diffkrnrt(nr)
double precision, private :: drhosmall
double precision, private :: dttracerlev(nr)
double precision, private :: dumpfreq
double precision, private :: endtime
double precision, private :: epsab_cd
double precision, private :: externforcingcycle
double precision, private :: externforcingperiod
double precision, private :: f0
double precision, private :: fofacmom
double precision, private :: fprime
double precision, private :: freesurffac
double precision, private :: gbaro
double precision, private :: gravfacc(nr)
double precision, private :: gravfacf(nr+1)
double precision, private :: gravity
double precision, private :: hfacinf
double precision, private :: hfacmin
double precision, private :: hfacmindp
double precision, private :: hfacmindr
double precision, private :: hfacmindz
double precision, private :: hfacsup
double precision, private :: hmixcriteria
double precision, private :: hmixsmooth
double precision, private :: implicdiv2dflow
double precision, private :: implicitnhpress
double precision, private :: implicsurfpress
double precision, private :: ivdc_kappa
double precision, private :: latbandclimrelax
double precision, private :: mass2runit
double precision, private :: monitorfreq
double precision, private :: mtfacmom
double precision, private :: nh_am2
double precision, private :: omega
double precision, private :: pcellmix_delr
double precision, private :: pcellmix_diffkr(nr)
double precision, private :: pcellmix_maxfac
double precision, private :: pcellmix_viscar(nr)
double precision, private :: pchkptfreq
double precision, private :: pffacmom
double precision, private :: phieuler
double precision, private :: phiref(2*nr+1)
double precision, private :: pref4eos(nr)
double precision, private :: psieuler
double precision, private :: radius_fromhorizgrid
double precision, private :: rcd
double precision, private :: recip_gravfacc(nr)
double precision, private :: recip_gravfacf(nr+1)
double precision, private :: recip_gravity
double precision, private :: recip_rhoconst
double precision, private :: recip_rhofacc(nr)
double precision, private :: recip_rhofacf(nr+1)
double precision, private :: recip_rsphere
double precision, private :: rho1ref(nr)
double precision, private :: rhoconst
double precision, private :: rhoconstfresh
double precision, private :: rhofacc(nr)
double precision, private :: rhofacf(nr+1)
double precision, private :: rhonil
double precision, private :: rhoref(nr)
double precision, private :: rotationperiod
double precision, private :: rsigmabnd
double precision, private :: rsphere
double precision, private :: runit2mass
double precision, private :: runit2z(nr)
double precision, private :: rvel2wunit(nr+1)
double precision, private :: salt_addmass
double precision, private :: salt_evprrn
double precision, private :: sealev_z
double precision, private :: siceloadfac
double precision, private :: sidedragfactor
double precision, private :: smag3d_coeff
double precision, private :: smag3d_diffcoeff
double precision, private :: smoothabsfuncrange
double precision, private :: sref(nr)
double precision, private :: starttime
double precision, private :: surf_pref
double precision, private :: taucd
double precision, private :: tausaltclimrelax
double precision, private :: tauthetaclimrelax
double precision, private :: tave_lastiter
double precision, private :: tavefreq
double precision, private :: tcylin
double precision, private :: tcylout
double precision, private :: temp_addmass
double precision, private :: temp_evprrn
double precision, private :: thetaconst
double precision, private :: thetaeuler
double precision, private :: top_pres
double precision, private :: tref(nr)
double precision, private :: vffacmom
double precision, private :: visca4
double precision, private :: visca4d
double precision, private :: visca4grid
double precision, private :: visca4gridmax
double precision, private :: visca4gridmin
double precision, private :: visca4max
double precision, private :: visca4remax
double precision, private :: visca4w
double precision, private :: visca4z
double precision, private :: viscah
double precision, private :: viscahd
double precision, private :: viscahgrid
double precision, private :: viscahgridmax
double precision, private :: viscahgridmin
double precision, private :: viscahmax
double precision, private :: viscahremax
double precision, private :: viscahw
double precision, private :: viscahz
double precision, private :: viscarnr(nr)
double precision, private :: viscc2leith
double precision, private :: viscc2leithd
double precision, private :: viscc2leithqg
double precision, private :: viscc2smag
double precision, private :: viscc4leith
double precision, private :: viscc4leithd
double precision, private :: viscc4smag
double precision, private :: viscfacadj
double precision, private :: wunit2rvel(nr+1)
double precision, private :: xgorigin
double precision, private :: ygorigin
double precision, private :: z2runit(nr)
double precision, private :: zroughbot
common /parm_r/ cg2dtargetresidual, cg2dtargetreswunit, cg2dpcoffdfac, cg3dtargetresidual, cg3dtargetreswunit, delr, delrc, xgorigin, ygorigin, &
&rsphere, recip_rsphere, radius_fromhorizgrid, sealev_z, top_pres, rsigmabnd, deltat, deltatmom, dttracerlev, deltatfreesurf, deltatclock, abeps, &
&alph_ab, beta_ab, f0, beta, fprime, omega, rotationperiod, viscfacadj, viscah, viscahw, smag3d_coeff, smag3d_diffcoeff, viscahmax, viscahgrid, &
&viscahgridmax, viscahgridmin, viscc2leith, viscc2leithd, viscc2leithqg, viscc2smag, viscc4smag, viscahd, viscahz, visca4d, visca4z, visca4, visca4w,&
& visca4max, visca4grid, visca4gridmax, visca4gridmin, viscahremax, visca4remax, viscc4leith, viscc4leithd, viscarnr, diffkht, diffk4t, diffkrnrt, &
&diffkr4t, diffkhs, diffk4s, diffkrnrs, diffkr4s, diffkrbl79surf, diffkrbl79deep, diffkrbl79scl, diffkrbl79ho, bl79latvary, diffkrbleqsurf, &
&diffkrbleqdeep, diffkrbleqscl, diffkrbleqho, pcellmix_maxfac, pcellmix_delr, pcellmix_viscar, pcellmix_diffkr, taucd, rcd, epsab_cd, freesurffac, &
&implicsurfpress, implicdiv2dflow, implicitnhpress, hfacmin, hfacmindz, hfacinf, hfacsup, gravity, recip_gravity, gbaro, gravfacc, recip_gravfacc, &
&gravfacf, recip_gravfacf, rhonil, rhoconst, recip_rhoconst, rho1ref, rhofacc, recip_rhofacc, rhofacf, recip_rhofacf, rhoconstfresh, thetaconst, &
&tref, sref, rhoref, dbdrref, surf_pref, pref4eos, phiref, rvel2wunit, wunit2rvel, runit2z, z2runit, mass2runit, runit2mass, basetime, starttime, &
&endtime, chkptfreq, pchkptfreq, dumpfreq, adjdumpfreq, diagfreq, tavefreq, tave_lastiter, monitorfreq, adjmonitorfreq, affacmom, vffacmom, pffacmom,&
& cffacmom, fofacmom, mtfacmom, cospower, cadjfreq, tauthetaclimrelax, tausaltclimrelax, latbandclimrelax, externforcingcycle, externforcingperiod, &
&convertfw2salt, temp_evprrn, salt_evprrn, temp_addmass, salt_addmass, hfacmindr, hfacmindp, ivdc_kappa, hmixcriteria, drhosmall, hmixsmooth, &
&sidedragfactor, bottomdraglinear, bottomdragquadratic, zroughbot, nh_am2, smoothabsfuncrange, siceloadfac, tcylin, tcylout, phieuler, thetaeuler, &
&psieuler

contains
  subroutine applycontribution( ih, ir, iz, tau, amp, phaseint, arrangle )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use writeray, only : writerayoutput
  use arr_mod, only : addarr,u
  use ihop_mod, only : afreq,delfile,nmax,rayfile

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: amp
  real(kind=8), intent(in) :: arrangle
  integer, intent(in) :: ih
  integer, intent(in) :: ir
  integer, intent(in) :: iz
  real(kind=8), intent(in) :: phaseint
  complex(kind=8), intent(in) :: tau

!==============================================
! declare local variables
!==============================================
  integer :: i
  real(kind=8) :: tmpdelay(nmax)
  real(kind=8) :: tmpx(nmax)
  real(kind=8) :: tmpy(nmax)
  complex :: upoint

  tmpx = 0.
  tmpy = 0.
  tmpdelay = 0.
  do i = 1, ih
    tmpx(i) = ray2d(i)%x(1)
    tmpy(i) = ray2d(i)%x(2)
    tmpdelay(i) = real(ray2d(i)%tau)
  end do
  select case ( beam%runtype(1:1) )
  case ('E')
    upoint = upoint
    call writerayoutput( rayfile,ih,tmpx(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('e')
    upoint = upoint
    call writerayoutput( rayfile,ih,tmpx(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
    if (writedelay) then
      call writerayoutput( delfile,ih,tmpdelay(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
    endif
    call addarr( afreq,iz,ir,amp,phaseint,tau,arrangle,ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('A','a')
    upoint = upoint
    call addarr( afreq,iz,ir,amp,phaseint,tau,arrangle,ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('C')
    upoint = upoint+cmplx(amp*exp(-(onecmplx*(afreq*tau-phaseint))))
  case ('S','I')
    if (beam%type(1:1) == 'B') then
      upoint = upoint+sngl(sqrt(2.*pi)*(amp*exp(aimag(afreq*tau)))**2)
    else
      upoint = upoint+sngl((amp*exp(aimag(afreq*tau)))**2)
    endif
  case default
    if (beam%type(1:1) == 'B') then
      upoint = upoint+sngl(sqrt(2.*pi)*(amp*exp(aimag(afreq*tau)))**2)
    else
      upoint = upoint+sngl((amp*exp(aimag(afreq*tau)))**2)
    endif
  end select
  u(iz,ir) = upoint
  end subroutine applycontribution
  subroutine applycontribution_tl( ih, ir, iz, tau, tau_tl, amp, amp_tl, phaseint, phaseint_tl, arrangle )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use writeray, only : writerayoutput
  use arr_mod, only : addarr,addarr_tl,u
  use ihop_mod, only : afreq,delfile,nmax,rayfile

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: amp
  real(kind=8), intent(in) :: amp_tl
  real(kind=8), intent(in) :: arrangle
  integer, intent(in) :: ih
  integer, intent(in) :: ir
  integer, intent(in) :: iz
  real(kind=8), intent(in) :: phaseint
  real(kind=8), intent(in) :: phaseint_tl
  complex(kind=8), intent(in) :: tau
  complex(kind=8), intent(in) :: tau_tl

!==============================================
! declare local variables
!==============================================
  integer :: i
  real(kind=8) :: tmpdelay(nmax)
  real(kind=8) :: tmpx(nmax)
  real(kind=8) :: tmpy(nmax)
  complex :: upoint

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  tmpx = 0.
  tmpy = 0.
  tmpdelay = 0.
  do i = 1, ih
    tmpx(i) = ray2d(i)%x(1)
    tmpy(i) = ray2d(i)%x(2)
    tmpdelay(i) = real(ray2d(i)%tau)
  end do
  select case ( beam%runtype(1:1) )
  case ('E')
    upoint = upoint
    call writerayoutput( rayfile,ih,tmpx(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('e')
    upoint = upoint
    call writerayoutput( rayfile,ih,tmpx(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
    if (writedelay) then
      call writerayoutput( delfile,ih,tmpdelay(1:ih),tmpy(1:ih),ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
    endif
    call addarr_tl( afreq,iz,ir,amp,amp_tl,phaseint,phaseint_tl,tau,tau_tl,arrangle,ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('A','a')
    upoint = upoint
    call addarr_tl( afreq,iz,ir,amp,amp_tl,phaseint,phaseint_tl,tau,tau_tl,arrangle,ray2d(ih)%ntopbnc,ray2d(ih)%nbotbnc )
  case ('C')
    upoint = upoint+cmplx(amp*exp(-(onecmplx*(afreq*tau-phaseint))))
  case ('S','I')
    if (beam%type(1:1) == 'B') then
      upoint = upoint+sngl(sqrt(2.*pi)*(amp*exp(aimag(afreq*tau)))**2)
    else
      upoint = upoint+sngl((amp*exp(aimag(afreq*tau)))**2)
    endif
  case default
    if (beam%type(1:1) == 'B') then
      upoint = upoint+sngl(sqrt(2.*pi)*(amp*exp(aimag(afreq*tau)))**2)
    else
      upoint = upoint+sngl((amp*exp(aimag(afreq*tau)))**2)
    endif
  end select
  u(iz,ir) = upoint

  end subroutine applycontribution_tl
  subroutine calculateinfluence( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

  select case ( beam%type(1:1) )
  case ('g')
    call influencegeohatraycen( mythid )
  case ('B')
    call influencegeogaussiancart( mythid )
  case ('G','^')
    call influencegeohatcart( mythid )
  case default
    call influencegeohatcart( mythid )
  end select
  end subroutine calculateinfluence
  subroutine calculateinfluence_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  select case ( beam%type(1:1) )
  case ('g')
    call influencegeohatraycen_tl( mythid )
  case ('B')
    call influencegeogaussiancart_tl( mythid )
  case ('G','^')
    call influencegeohatcart_tl( mythid )
  case default
    call influencegeohatcart_tl( mythid )
  end select

  end subroutine calculateinfluence_tl
  function   hermite( x, x1, x2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8) :: hermite
  real(kind=8), intent(in) :: x
  real(kind=8), intent(in) :: x1
  real(kind=8), intent(in) :: x2

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: ax
  real(kind=8) :: u

  ax = abs(x)
  if (ax <= x1) then
    hermite = 1.0d0
  else if (ax >= x2) then
    hermite = 0.0d0
  else
    u = (ax-x1)/(x2-x1)
    hermite = (1.0d0+2.0d0*u)*(1.0d0-u)**2
  endif
  end function   hermite
  subroutine influencegeogaussiancart( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: beamwindow = 4

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  complex(kind=8) :: delay
  real(kind=8) :: dqds
  complex(kind=8) :: dtauds
  integer :: ih
  logical :: inrcvrranges
  integer :: ir
  integer :: irtt
  integer :: iz
  real(kind=8) :: lambda
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: n
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: qatmp
  real(kind=8) :: qbtmp
  real(kind=8) :: qold
  real(kind=8) :: qtmp
  real(kind=8) :: ra
  real(kind=8) :: radiusmax
  real(kind=8) :: ratio1
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayntmp
  real(kind=8) :: rayt(2)
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rlen
  real(kind=8) :: s
  real(kind=8) :: sigma
  real(kind=8) :: sigmatmp
  real(kind=8) :: w
  real(kind=8) :: x_rcvr(2)
  real(kind=8) :: xa(2)
  real(kind=8) :: xb(2)
  real(kind=8) :: zmax
  real(kind=8) :: zmin

  q0 = ray2d(1)%c/angles%dalpha
  phase = 0
  qold = ray2d(1)%q(1)
  ra = ray2d(1)%x(1)
  w = 0
  s = 0
  n = 0
  xb = [ ra,zerorl ]
  q = 0
  amp = 0
  phaseint = 0
  rcvrdeclangle = 180
  delay = 0
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))/sqrt(2.*pi)
  else
    ratio1 = 1/sqrt(2.*pi)
  endif
  stepping: do ih = 2, beam%nsteps
    xa = ray2d(ih-1)%x
    xb = ray2d(ih)%x
    rayt = xb-xa
    if (all(rayt == 0.)) then
      rlen = 0.0
    else
      rlen = norm2(rayt)
    endif
    if (rlen >= 1.0d3*spacing(xb(1))) then
      rayt = rayt/rlen
      rayn = [ -rayt(2),rayt(1) ]
      if (all(rayt == 0.0)) then
        rcvrdeclangle = 0.0
      else
        rcvrdeclangle = rad2deg*atan2(rayt(2),rayt(1))
      endif
      q = ray2d(ih-1)%q(1)
      dqds = ray2d(ih)%q(1)-q
      dtauds = ray2d(ih)%tau-ray2d(ih-1)%tau
      if (q <= 0. .and. qold > 0. .or. q >= 0. .and. qold < 0.) then
        phase = phase+pi/2.
      endif
      qold = q
      call locabs( q,qatmp )
      call locabs( ray2d(ih)%q(1),qbtmp )
      call locabs( rayn(2),rayntmp )
      if (qatmp >= qbtmp) then
        radiusmax = qatmp
      else
        radiusmax = qbtmp
      endif
      radiusmax = radiusmax/q0/rayntmp
      lambda = ray2d(ih-1)%c/ihop_freq
      sigmatmp = min(0.2*ihop_freq*real(ray2d(ih)%tau),pi*lambda)
      radiusmax = max(radiusmax,sigmatmp)
      radiusmax = beamwindow*radiusmax
      if (rayt(1) > 0.5 .or. rayt(1) < (-0.5)) then
        zmin = min(xa(2),xb(2))-radiusmax
        zmax = max(xa(2),xb(2))+radiusmax
      else
        zmin = -huge(zmin)
        zmax = huge(zmax)
      endif
      inrcvrranges =  .true. 
      rcvrranges: do ir = 1, ihop_nrr
        if (pos%rr(ir) >= min(ra,xb(1)) .and. pos%rr(ir) < max(ra,xb(1)) .and. inrcvrranges) then
          rcvrdepths: do iz = 1, nrz_per_range
            if (beam%runtype(5:5) == 'I') then
              x_rcvr = [ pos%rr(ir),pos%rz(ir) ]
            else
              x_rcvr = [ pos%rr(ir),pos%rz(iz) ]
            endif
            if (x_rcvr(2) >= zmin .and. x_rcvr(2) <= zmax) then
              s = dot_product(x_rcvr-xa,rayt)
              s = s/rlen
              n = dot_product(x_rcvr-xa,rayn)
              n = abs(n)
              q = q+s*dqds
              sigma = abs(q/q0)
              radiusmax = max(sigma,sigmatmp)
              radiusmax = beamwindow*radiusmax
              if (n < radiusmax) then
write(unit=msgbuf,fmt='(A,F10.2)') 'Influence: Eigenray w RadiusMax = ',radiusmax
if (ihop_dumpfreq >= 0) then
  call print_message( msgbuf,prtfile,squeeze_right,mythid )
endif
delay = ray2d(ih-1)%tau+s*dtauds
call locabs( q,qtmp )
if (ray2d(ih)%c > zerorl) then
  amp = sqrt(ray2d(ih)%c/qtmp)
else
  amp = 0.0
endif
amp = ratio1*amp*ray2d(ih)%amp
if (sigma /= 0) then
  w = exp(-(0.5*(n/sigma)**2))/sigma**2
else
  w = 0
endif
amp = amp*w
if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
  phaseint = phase+pi/2.
else
  phaseint = ray2d(ih-1)%phase+phase
endif
call applycontribution( ih,ir,iz,delay,amp,phaseint,rcvrdeclangle )
              endif
            endif
          end do rcvrdepths
        endif
        if (pos%rr(ir) < xb(1)) then
          if (ir >= pos%nrr) then
            inrcvrranges =  .false. 
          endif
          irtt = ir+1
          if (pos%rr(irtt) >= xb(1)) then
            inrcvrranges =  .false. 
          endif
        endif
      end do rcvrranges
      ra = xb(1)
    endif
  end do stepping
  end subroutine influencegeogaussiancart
  subroutine influencegeogaussiancart_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: beamwindow = 4
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikinea = 8
  integer, parameter :: ikineb = 8
  integer, parameter :: ikinec = 8
  integer, parameter :: ikined = 8
  integer, parameter :: ikinee = 8
  integer, parameter :: ikineg = 8
  integer, parameter :: ikineh = 8
  integer, parameter :: ikinei = 8
  integer, parameter :: ikinej = 8

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  real(kind=8) :: amp_tl
  complex(kind=8) :: delay
  complex(kind=8) :: delay_tl
  real(kind=8) :: dqds
  real(kind=8) :: dqds_tl
  complex(kind=8) :: dtauds
  complex(kind=8) :: dtauds_tl
  integer :: ih
  logical :: inrcvrranges
  integer :: ir
  integer :: irtt
  integer :: iz
  real(kind=8) :: lambda
  real(kind=8) :: lambda_tl
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: n
  real(kind=8) :: n_tl
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: phaseint_tl
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: q0_tl
  real(kind=8) :: q_tl
  real(kind=8) :: qatmp
  real(kind=8) :: qatmp_tl
  real(kind=8) :: qbtmp
  real(kind=8) :: qbtmp_tl
  real(kind=8) :: qold
  real(kind=8) :: qold_tl
  real(kind=8) :: qtmp
  real(kind=8) :: qtmp_tl
  real(kind=8) :: ra
  real(kind=8) :: ra_tl
  real(kind=8) :: radiusmax
  real(kind=8) :: radiusmax_tl
  real(kind=8) :: ratio1
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayn_tl(2)
  real(kind=8) :: rayntmp
  real(kind=8) :: rayntmp_tl
  real(kind=8) :: rayt(2)
  real(kind=8) :: rayt_tl(2)
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rlen
  real(kind=8) :: rlen_tl
  real(kind=8) :: s
  real(kind=8) :: s_tl
  real(kind=8) :: sigma
  real(kind=8) :: sigma_tl
  real(kind=8) :: sigmah
  real(kind=8) :: sigmatmp
  real(kind=8) :: sigmatmp_tl
  real :: sigmatmph
  real(kind=8) :: w
  real(kind=8) :: w_tl
  real(kind=8) :: wh
  real(kind=8) :: x_rcvr(2)
  real(kind=8) :: xa(2)
  real(kind=8) :: xa_tl(2)
  real(kind=8) :: xb(2)
  real(kind=8) :: xb_tl(2)
  real(kind=8) :: zmax
  real(kind=8) :: zmax_tl
  real(kind=8) :: zmin
  real(kind=8) :: zmin_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  q0_tl = ray2d_tl(1)%c_tl/angles%dalpha
  q0 = ray2d(1)%c/angles%dalpha
  phase = 0
  qold_tl = ray2d_tl(1)%q_tl(1)
  qold = ray2d(1)%q(1)
  ra_tl = ray2d_tl(1)%x_tl(1)
  ra = ray2d(1)%x(1)
  w_tl = 0._ikinej
  w = 0
  s_tl = 0._ikinei
  s = 0
  n_tl = 0._ikineh
  n = 0
  xb_tl = [ ra_tl,0._ikineg ]
  xb = [ ra,zerorl ]
  q_tl = 0._ikinee
  q = 0
  amp_tl = 0._ikined
  amp = 0
  phaseint_tl = 0._ikinec
  phaseint = 0
  rcvrdeclangle = 180
  delay_tl = (0._ikineb,0._ikineb)
  delay = 0
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))/sqrt(2.*pi)
  else
    ratio1 = 1/sqrt(2.*pi)
  endif
  stepping1: do ih = 2, beam%nsteps
    xa_tl = ray2d_tl(ih-1)%x_tl
    xa = ray2d(ih-1)%x
    xb_tl = ray2d_tl(ih)%x_tl
    xb = ray2d(ih)%x
    rayt_tl = (-xa_tl)+xb_tl
    rayt = xb-xa
    if (all(rayt == 0.)) then
      rlen_tl = 0._ikinea
      rlen = 0.0
    else
      rlen_tl = sum(rayt_tl*rayt)/norm2(rayt)
      rlen = norm2(rayt)
    endif
    if (rlen >= 1.0d3*spacing(xb(1))) then
      rayt_tl = rayt_tl/rlen-rlen_tl*(rayt/rlen/rlen)
      rayt = rayt/rlen
      rayn_tl = [ -rayt_tl(2),rayt_tl(1) ]
      rayn = [ -rayt(2),rayt(1) ]
      if (all(rayt == 0.0)) then
        rcvrdeclangle = 0.0
      else
        rcvrdeclangle = rad2deg*atan2(rayt(2),rayt(1))
      endif
      q_tl = ray2d_tl(ih-1)%q_tl(1)
      q = ray2d(ih-1)%q(1)
      dqds_tl = (-q_tl)+ray2d_tl(ih)%q_tl(1)
      dqds = ray2d(ih)%q(1)-q
      dtauds_tl = (-ray2d_tl(ih-1)%tau_tl)+ray2d_tl(ih)%tau_tl
      dtauds = ray2d(ih)%tau-ray2d(ih-1)%tau
      if (q <= 0. .and. qold > 0. .or. q >= 0. .and. qold < 0.) then
        phase = phase+pi/2.
      endif
      qold_tl = q_tl
      qold = q
      call locabs( q_tl,qatmp_tl )
      call locabs( q,qatmp )
      call locabs( ray2d_tl(ih)%q_tl(1),qbtmp_tl )
      call locabs( ray2d(ih)%q(1),qbtmp )
      call locabs( rayn_tl(2),rayntmp_tl )
      call locabs( rayn(2),rayntmp )
      if (qatmp >= qbtmp) then
        radiusmax_tl = qatmp_tl
        radiusmax = qatmp
      else
        radiusmax_tl = qbtmp_tl
        radiusmax = qbtmp
      endif
      radiusmax_tl = (-(q0_tl*(radiusmax/q0/q0/rayntmp)))+radiusmax_tl*(1/q0/rayntmp)-rayntmp_tl*(radiusmax/q0/rayntmp/rayntmp)
      radiusmax = radiusmax/q0/rayntmp
      lambda_tl = ray2d_tl(ih-1)%c_tl/ihop_freq
      lambda = ray2d(ih-1)%c/ihop_freq
      sigmatmph = real(ray2d(ih)%tau)
      sigmatmp_tl = lambda_tl*(0.5-sign(0.5d0,pi*lambda-0.2*ihop_freq*sigmatmph))*pi+0.2*(0.5+sign(0.5d0,pi*lambda-0.2*ihop_freq*sigmatmph))*&
&ihop_freq*real(ray2d_tl(ih)%tau_tl)
      sigmatmp = min(0.2*ihop_freq*sigmatmph,pi*lambda)
      radiusmax_tl = radiusmax_tl*(0.5+sign(0.5_8,radiusmax-sigmatmp))+sigmatmp_tl*(0.5-sign(0.5_8,radiusmax-sigmatmp))
      radiusmax = max(radiusmax,sigmatmp)
      radiusmax_tl = radiusmax_tl*beamwindow
      radiusmax = beamwindow*radiusmax
      if (rayt(1) > 0.5 .or. rayt(1) < (-0.5)) then
        zmin_tl = (-radiusmax_tl)+xa_tl(2)*(0.5+sign(0.5_8,xb(2)-xa(2)))+xb_tl(2)*(0.5-sign(0.5_8,xb(2)-xa(2)))
        zmin = min(xa(2),xb(2))-radiusmax
        zmax_tl = radiusmax_tl+xa_tl(2)*(0.5+sign(0.5_8,xa(2)-xb(2)))+xb_tl(2)*(0.5-sign(0.5_8,xa(2)-xb(2)))
        zmax = radiusmax+max(xa(2),xb(2))
      else
        zmin_tl = 0._ikind5
        zmin = -huge(zmin)
        zmax_tl = 0._ikind4
        zmax = huge(zmax)
      endif
      inrcvrranges =  .true. 
      rcvrranges1: do ir = 1, ihop_nrr
        if (pos%rr(ir) >= min(ra,xb(1)) .and. pos%rr(ir) < max(ra,xb(1)) .and. inrcvrranges) then
          rcvrdepths1: do iz = 1, nrz_per_range
            if (beam%runtype(5:5) == 'I') then
              x_rcvr = [ pos%rr(ir),pos%rz(ir) ]
            else
              x_rcvr = [ pos%rr(ir),pos%rz(iz) ]
            endif
            if (x_rcvr(2) >= zmin .and. x_rcvr(2) <= zmax) then
              s_tl = dot_product(x_rcvr-xa,rayt_tl)+dot_product(-xa_tl,rayt)
              s = dot_product(x_rcvr-xa,rayt)
              s_tl = (-(rlen_tl*(s/rlen/rlen)))+s_tl/rlen
              s = s/rlen
              n_tl = dot_product(x_rcvr-xa,rayn_tl)+dot_product(-xa_tl,rayn)
              n = dot_product(x_rcvr-xa,rayn)
              n_tl = n_tl*sign(1._8,n)
              n = abs(n)
              q_tl = dqds_tl*s+q_tl+s_tl*dqds
              q = q+s*dqds
              sigmah = q/q0
              sigma_tl = (q_tl/q0-q0_tl*(q/q0/q0))*sign(1._8,sigmah)
              sigma = abs(sigmah)
              radiusmax_tl = sigma_tl*(0.5+sign(0.5_8,sigma-sigmatmp))+sigmatmp_tl*(0.5-sign(0.5_8,sigma-sigmatmp))
              radiusmax = max(sigma,sigmatmp)
              radiusmax_tl = radiusmax_tl*beamwindow
              radiusmax = beamwindow*radiusmax
              if (n < radiusmax) then
write(unit=msgbuf,fmt='(A,F10.2)') 'Influence: Eigenray w RadiusMax = ',radiusmax
if (ihop_dumpfreq >= 0) then
  call print_message( msgbuf,prtfile,squeeze_right,mythid )
endif
delay_tl = dtauds_tl*s+ray2d_tl(ih-1)%tau_tl+s_tl*dtauds
delay = ray2d(ih-1)%tau+s*dtauds
call locabs( q_tl,qtmp_tl )
call locabs( q,qtmp )
if (ray2d(ih)%c > zerorl) then
  amp_tl = (-(qtmp_tl/(2._8*sqrt(ray2d(ih)%c/qtmp))*(ray2d(ih)%c/qtmp/qtmp)))+ray2d_tl(ih)%c_tl*(1._8/(2._8*sqrt(ray2d(ih)%c/qtmp))/qtmp)
  amp = sqrt(ray2d(ih)%c/qtmp)
else
  amp_tl = 0._ikind3
  amp = 0.0
endif
amp_tl = amp_tl*ratio1*ray2d(ih)%amp+ray2d_tl(ih)%amp_tl*ratio1*amp
amp = ratio1*amp*ray2d(ih)%amp
if (sigma /= 0) then
  wh = -(0.5*(n/sigma)**2)
  w_tl = (-(sigma_tl*(2*sigma*exp(wh)/sigma**2/sigma**2)))+((-(0.5*n_tl*(2*(1/sigma)*(n/sigma))))+0.5*sigma_tl*(2*(n/sigma/sigma)*(n/sigma)))*&
&(exp(wh)/sigma**2)
  w = exp(wh)/sigma**2
else
  w_tl = 0._ikind2
  w = 0
endif
amp_tl = amp_tl*w+w_tl*amp
amp = amp*w
if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
  phaseint_tl = 0._ikind1
  phaseint = phase+pi/2.
else
  phaseint_tl = ray2d_tl(ih-1)%phase_tl
  phaseint = ray2d(ih-1)%phase+phase
endif
call applycontribution_tl( ih,ir,iz,delay,delay_tl,amp,amp_tl,phaseint,phaseint_tl,rcvrdeclangle )
              endif
            endif
          end do rcvrdepths1
        endif
        if (pos%rr(ir) < xb(1)) then
          if (ir >= pos%nrr) then
            inrcvrranges =  .false. 
          endif
          irtt = ir+1
          if (pos%rr(irtt) >= xb(1)) then
            inrcvrranges =  .false. 
          endif
        endif
      end do rcvrranges1
      ra_tl = xb_tl(1)
      ra = xb(1)
    endif
  end do stepping1

  end subroutine influencegeogaussiancart_tl
  subroutine influencegeohatcart( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  complex(kind=8) :: delay
  real(kind=8) :: dqds
  complex(kind=8) :: dtauds
  integer :: ih
  logical :: inrcvrranges
  integer :: ir
  integer :: irtt
  integer :: iz
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: n
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: qatmp
  real(kind=8) :: qbtmp
  real(kind=8) :: qold
  real(kind=8) :: qtmp
  real(kind=8) :: ra
  real(kind=8) :: radiusmax
  real(kind=8) :: ratio1
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayntmp
  real(kind=8) :: rayt(2)
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rlen
  real(kind=8) :: s
  real(kind=8) :: w
  real(kind=8) :: x_rcvr(2,nrz_per_range)
  real(kind=8) :: xa(2)
  real(kind=8) :: xb(2)
  real(kind=8) :: zmax
  real(kind=8) :: zmin

  q0 = ray2d(1)%c/angles%dalpha
  phase = 0.0
  qold = ray2d(1)%q(1)
  ra = ray2d(1)%x(1)
  w = 0
  s = 0
  n = 0
  xb = [ ra,zerorl ]
  q = 0
  amp = 0
  phaseint = 0
  rcvrdeclangle = 180
  delay = 0
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))
  endif
  stepping: do ih = 2, beam%nsteps
    xa = ray2d(ih-1)%x
    xb = ray2d(ih)%x
    rayt = xb-xa
    if (all(rayt == 0.0)) then
      rlen = 0.0
    else
      rlen = norm2(rayt)
    endif
    if (rlen >= 1.0d3*spacing(xb(1))) then
      rayt = rayt/rlen
      rayn = [ -rayt(2),rayt(1) ]
      if (all(rayt == 0.0)) then
        rcvrdeclangle = 0.0
      else
        rcvrdeclangle = rad2deg*atan2(rayt(2),rayt(1))
      endif
      q = ray2d(ih-1)%q(1)
      dqds = ray2d(ih)%q(1)-q
      dtauds = ray2d(ih)%tau-ray2d(ih-1)%tau
      if (q <= 0. .and. qold > 0. .or. q >= 0. .and. qold < 0.) then
        phase = phase+pi/2.
      endif
      qold = q
      call locabs( q,qatmp )
      call locabs( ray2d(ih)%q(1),qbtmp )
      call locabs( rayn(2),rayntmp )
      if (qatmp >= qbtmp) then
        radiusmax = qatmp
      else
        radiusmax = qbtmp
      endif
      radiusmax = radiusmax/q0/rayntmp
      if (rayt(1) > 0.5 .or. rayt(1) < (-0.5)) then
        zmin = min(xa(2),xb(2))-radiusmax
        zmax = max(xa(2),xb(2))+radiusmax
      else
        zmin = -huge(zmin)
        zmax = huge(zmax)
      endif
      inrcvrranges =  .true. 
      rcvrranges: do ir = 1, ihop_nrr
        if (pos%rr(ir) >= min(ra,xb(1)) .and. pos%rr(ir) < max(ra,xb(1)) .and. inrcvrranges) then
          x_rcvr(1,1:nrz_per_range) = pos%rr(ir)
          if (beam%runtype(5:5) == 'I') then
            x_rcvr(2,1) = pos%rz(ir)
          else
            x_rcvr(2,1:nrz_per_range) = pos%rz(1:nrz_per_range)
          endif
          rcvrdepths: do iz = 1, nrz_per_range
            if (x_rcvr(2,iz) >= zmin .and. x_rcvr(2,iz) <= zmax) then
              s = dot_product(x_rcvr(:,iz)-xa,rayt)
              s = s/rlen
              n = dot_product(x_rcvr(:,iz)-xa,rayn)
              n = abs(n)
              q = q+s*dqds
              radiusmax = abs(q/q0)
              if (n < radiusmax) then
write(unit=msgbuf,fmt='(A,F10.2)') 'Influence: Eigenray w RadiusMax = ',radiusmax
if (ihop_dumpfreq >= 0) then
  call print_message( msgbuf,prtfile,squeeze_right,mythid )
endif
delay = ray2d(ih-1)%tau+s*dtauds
call locabs( q,qtmp )
if (ray2d(ih)%c > zerorl) then
  amp = sqrt(ray2d(ih)%c/qtmp)
else
  amp = 0.0
endif
amp = ratio1*amp*ray2d(ih)%amp
if (radiusmax /= 0) then
  w = (radiusmax-n)/radiusmax
else
  w = 0
endif
amp = amp*w
if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
  phaseint = phase+pi/2.
else
  phaseint = ray2d(ih-1)%phase+phase
endif
call applycontribution( ih,ir,iz,delay,amp,phaseint,rcvrdeclangle )
              endif
            endif
          end do rcvrdepths
        endif
        if (pos%rr(ir) < xb(1)) then
          if (ir >= pos%nrr) then
            inrcvrranges =  .false. 
          endif
          irtt = ir+1
          if (pos%rr(irtt) >= xb(1)) then
            inrcvrranges =  .false. 
          endif
        endif
      end do rcvrranges
      ra = xb(1)
    endif
  end do stepping
  end subroutine influencegeohatcart
  subroutine influencegeohatcart_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikinea = 8
  integer, parameter :: ikineb = 8
  integer, parameter :: ikinec = 8
  integer, parameter :: ikined = 8
  integer, parameter :: ikinee = 8
  integer, parameter :: ikineg = 8
  integer, parameter :: ikineh = 8
  integer, parameter :: ikinei = 8
  integer, parameter :: ikinej = 8

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  real(kind=8) :: amp_tl
  complex(kind=8) :: delay
  complex(kind=8) :: delay_tl
  real(kind=8) :: dqds
  real(kind=8) :: dqds_tl
  complex(kind=8) :: dtauds
  complex(kind=8) :: dtauds_tl
  integer :: ih
  logical :: inrcvrranges
  integer :: ir
  integer :: irtt
  integer :: iz
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: n
  real(kind=8) :: n_tl
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: phaseint_tl
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: q0_tl
  real(kind=8) :: q_tl
  real(kind=8) :: qatmp
  real(kind=8) :: qatmp_tl
  real(kind=8) :: qbtmp
  real(kind=8) :: qbtmp_tl
  real(kind=8) :: qold
  real(kind=8) :: qold_tl
  real(kind=8) :: qtmp
  real(kind=8) :: qtmp_tl
  real(kind=8) :: ra
  real(kind=8) :: ra_tl
  real(kind=8) :: radiusmax
  real(kind=8) :: radiusmax_tl
  real(kind=8) :: radiusmaxh
  real(kind=8) :: ratio1
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayn_tl(2)
  real(kind=8) :: rayntmp
  real(kind=8) :: rayntmp_tl
  real(kind=8) :: rayt(2)
  real(kind=8) :: rayt_tl(2)
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rlen
  real(kind=8) :: rlen_tl
  real(kind=8) :: s
  real(kind=8) :: s_tl
  real(kind=8) :: w
  real(kind=8) :: w_tl
  real(kind=8) :: x_rcvr(2,nrz_per_range)
  real(kind=8) :: xa(2)
  real(kind=8) :: xa_tl(2)
  real(kind=8) :: xb(2)
  real(kind=8) :: xb_tl(2)
  real(kind=8) :: zmax
  real(kind=8) :: zmax_tl
  real(kind=8) :: zmin
  real(kind=8) :: zmin_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  q0_tl = ray2d_tl(1)%c_tl/angles%dalpha
  q0 = ray2d(1)%c/angles%dalpha
  phase = 0.0
  qold_tl = ray2d_tl(1)%q_tl(1)
  qold = ray2d(1)%q(1)
  ra_tl = ray2d_tl(1)%x_tl(1)
  ra = ray2d(1)%x(1)
  w_tl = 0._ikinej
  w = 0
  s_tl = 0._ikinei
  s = 0
  n_tl = 0._ikineh
  n = 0
  xb_tl = [ ra_tl,0._ikineg ]
  xb = [ ra,zerorl ]
  q_tl = 0._ikinee
  q = 0
  amp_tl = 0._ikined
  amp = 0
  phaseint_tl = 0._ikinec
  phaseint = 0
  rcvrdeclangle = 180
  delay_tl = (0._ikineb,0._ikineb)
  delay = 0
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))
  endif
  stepping1: do ih = 2, beam%nsteps
    xa_tl = ray2d_tl(ih-1)%x_tl
    xa = ray2d(ih-1)%x
    xb_tl = ray2d_tl(ih)%x_tl
    xb = ray2d(ih)%x
    rayt_tl = (-xa_tl)+xb_tl
    rayt = xb-xa
    if (all(rayt == 0.0)) then
      rlen_tl = 0._ikinea
      rlen = 0.0
    else
      rlen_tl = sum(rayt_tl*rayt)/norm2(rayt)
      rlen = norm2(rayt)
    endif
    if (rlen >= 1.0d3*spacing(xb(1))) then
      rayt_tl = rayt_tl/rlen-rlen_tl*(rayt/rlen/rlen)
      rayt = rayt/rlen
      rayn_tl = [ -rayt_tl(2),rayt_tl(1) ]
      rayn = [ -rayt(2),rayt(1) ]
      if (all(rayt == 0.0)) then
        rcvrdeclangle = 0.0
      else
        rcvrdeclangle = rad2deg*atan2(rayt(2),rayt(1))
      endif
      q_tl = ray2d_tl(ih-1)%q_tl(1)
      q = ray2d(ih-1)%q(1)
      dqds_tl = (-q_tl)+ray2d_tl(ih)%q_tl(1)
      dqds = ray2d(ih)%q(1)-q
      dtauds_tl = (-ray2d_tl(ih-1)%tau_tl)+ray2d_tl(ih)%tau_tl
      dtauds = ray2d(ih)%tau-ray2d(ih-1)%tau
      if (q <= 0. .and. qold > 0. .or. q >= 0. .and. qold < 0.) then
        phase = phase+pi/2.
      endif
      qold_tl = q_tl
      qold = q
      call locabs( q_tl,qatmp_tl )
      call locabs( q,qatmp )
      call locabs( ray2d_tl(ih)%q_tl(1),qbtmp_tl )
      call locabs( ray2d(ih)%q(1),qbtmp )
      call locabs( rayn_tl(2),rayntmp_tl )
      call locabs( rayn(2),rayntmp )
      if (qatmp >= qbtmp) then
        radiusmax_tl = qatmp_tl
        radiusmax = qatmp
      else
        radiusmax_tl = qbtmp_tl
        radiusmax = qbtmp
      endif
      radiusmax_tl = (-(q0_tl*(radiusmax/q0/q0/rayntmp)))+radiusmax_tl*(1/q0/rayntmp)-rayntmp_tl*(radiusmax/q0/rayntmp/rayntmp)
      radiusmax = radiusmax/q0/rayntmp
      if (rayt(1) > 0.5 .or. rayt(1) < (-0.5)) then
        zmin_tl = (-radiusmax_tl)+xa_tl(2)*(0.5+sign(0.5_8,xb(2)-xa(2)))+xb_tl(2)*(0.5-sign(0.5_8,xb(2)-xa(2)))
        zmin = min(xa(2),xb(2))-radiusmax
        zmax_tl = radiusmax_tl+xa_tl(2)*(0.5+sign(0.5_8,xa(2)-xb(2)))+xb_tl(2)*(0.5-sign(0.5_8,xa(2)-xb(2)))
        zmax = radiusmax+max(xa(2),xb(2))
      else
        zmin_tl = 0._ikind5
        zmin = -huge(zmin)
        zmax_tl = 0._ikind4
        zmax = huge(zmax)
      endif
      inrcvrranges =  .true. 
      rcvrranges1: do ir = 1, ihop_nrr
        if (pos%rr(ir) >= min(ra,xb(1)) .and. pos%rr(ir) < max(ra,xb(1)) .and. inrcvrranges) then
          x_rcvr(1,1:nrz_per_range) = pos%rr(ir)
          if (beam%runtype(5:5) == 'I') then
            x_rcvr(2,1) = pos%rz(ir)
          else
            x_rcvr(2,1:nrz_per_range) = pos%rz(1:nrz_per_range)
          endif
          rcvrdepths1: do iz = 1, nrz_per_range
            if (x_rcvr(2,iz) >= zmin .and. x_rcvr(2,iz) <= zmax) then
              s_tl = dot_product(x_rcvr(:,iz)-xa,rayt_tl)+dot_product(-xa_tl,rayt)
              s = dot_product(x_rcvr(:,iz)-xa,rayt)
              s_tl = (-(rlen_tl*(s/rlen/rlen)))+s_tl/rlen
              s = s/rlen
              n_tl = dot_product(x_rcvr(:,iz)-xa,rayn_tl)+dot_product(-xa_tl,rayn)
              n = dot_product(x_rcvr(:,iz)-xa,rayn)
              n_tl = n_tl*sign(1._8,n)
              n = abs(n)
              q_tl = dqds_tl*s+q_tl+s_tl*dqds
              q = q+s*dqds
              radiusmaxh = q/q0
              radiusmax_tl = (q_tl/q0-q0_tl*(q/q0/q0))*sign(1._8,radiusmaxh)
              radiusmax = abs(radiusmaxh)
              if (n < radiusmax) then
write(unit=msgbuf,fmt='(A,F10.2)') 'Influence: Eigenray w RadiusMax = ',radiusmax
if (ihop_dumpfreq >= 0) then
  call print_message( msgbuf,prtfile,squeeze_right,mythid )
endif
delay_tl = dtauds_tl*s+ray2d_tl(ih-1)%tau_tl+s_tl*dtauds
delay = ray2d(ih-1)%tau+s*dtauds
call locabs( q_tl,qtmp_tl )
call locabs( q,qtmp )
if (ray2d(ih)%c > zerorl) then
  amp_tl = (-(qtmp_tl/(2._8*sqrt(ray2d(ih)%c/qtmp))*(ray2d(ih)%c/qtmp/qtmp)))+ray2d_tl(ih)%c_tl*(1._8/(2._8*sqrt(ray2d(ih)%c/qtmp))/qtmp)
  amp = sqrt(ray2d(ih)%c/qtmp)
else
  amp_tl = 0._ikind3
  amp = 0.0
endif
amp_tl = amp_tl*ratio1*ray2d(ih)%amp+ray2d_tl(ih)%amp_tl*ratio1*amp
amp = ratio1*amp*ray2d(ih)%amp
if (radiusmax /= 0) then
  w_tl = (-(n_tl/radiusmax))+radiusmax_tl*((1-(radiusmax-n)/radiusmax)/radiusmax)
  w = (radiusmax-n)/radiusmax
else
  w_tl = 0._ikind2
  w = 0
endif
amp_tl = amp_tl*w+w_tl*amp
amp = amp*w
if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
  phaseint_tl = 0._ikind1
  phaseint = phase+pi/2.
else
  phaseint_tl = ray2d_tl(ih-1)%phase_tl
  phaseint = ray2d(ih-1)%phase+phase
endif
call applycontribution_tl( ih,ir,iz,delay,delay_tl,amp,amp_tl,phaseint,phaseint_tl,rcvrdeclangle )
              endif
            endif
          end do rcvrdepths1
        endif
        if (pos%rr(ir) < xb(1)) then
          if (ir >= pos%nrr) then
            inrcvrranges =  .false. 
          endif
          irtt = ir+1
          if (pos%rr(irtt) >= xb(1)) then
            inrcvrranges =  .false. 
          endif
        endif
      end do rcvrranges1
      ra_tl = xb_tl(1)
      ra = xb(1)
    endif
  end do stepping1

  end subroutine influencegeohatcart_tl
  subroutine influencegeohatraycen( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  complex(kind=8) :: delay
  real(kind=8) :: dq(beam%nsteps-1)
  complex(kind=8) :: dtau(beam%nsteps-1)
  integer :: ih
  integer :: ii
  integer :: ir
  integer :: ira
  integer :: irb
  integer :: iz
  real(kind=8) :: l
  real(kind=8) :: n
  real(kind=8) :: na
  real(kind=8) :: nb
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: qold
  real(kind=8) :: ra
  real(kind=8) :: ratio1
  real(kind=8) :: rb
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rcvrdeclanglev(beam%nsteps)
  real(kind=8) :: rnv(beam%nsteps)
  real(kind=8) :: s
  logical :: skip_step
  real(kind=8) :: w
  real(kind=8) :: znv(beam%nsteps)
  real(kind=8) :: zr

  w = 0
  s = 0
  n = 0
  rb = ra
  q = 0
  amp = 0
  phaseint = 0
  rcvrdeclangle = 180
  delay = 0
  q0 = ray2d(1)%c/angles%dalpha
  dq = ray2d(2:beam%nsteps)%q(1)-ray2d(1:beam%nsteps-1)%q(1)
  dtau = ray2d(2:beam%nsteps)%tau-ray2d(1:beam%nsteps-1)%tau
  znv = -(ray2d(1:beam%nsteps)%t(1)*ray2d(1:beam%nsteps)%c)
  rnv = ray2d(1:beam%nsteps)%t(2)*ray2d(1:beam%nsteps)%c
  do ii = 1, beam%nsteps
    if (all(ray2d(ii)%t == 0.0)) then
      rcvrdeclanglev(ii) = 0.0
    else
      rcvrdeclanglev(ii) = rad2deg*atan2(ray2d(ii)%t(2),ray2d(ii)%t(1))
    endif
  end do
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))
  endif
  ray2d(1:beam%nsteps)%amp = ratio1*sqrt(ray2d(1:beam%nsteps)%c)*ray2d(1:beam%nsteps)%amp
  rcvrdepths: do iz = 1, nrz_per_range
    zr = pos%rz(iz)
    phase = 0.0
    qold = ray2d(1)%q(1)
    if (abs(znv(1)) < 1d-6) then
      na = 1d10
      ra = 1d10
      ira = 1
    else
      na = (zr-ray2d(1)%x(2))/znv(1)
      ra = ray2d(1)%x(1)+na*rnv(1)
      ira = max(min(int((ra-pos%rr(1))/pos%delta_r)+1,pos%nrr),1)
    endif
    stepping: do ih = 2, beam%nsteps
      skip_step =  .false. 
      if (abs(znv(ih)) < 1d-10) then
        skip_step =  .true. 
        rb = 1d10
      else
        nb = (zr-ray2d(ih)%x(2))/znv(ih)
        rb = ray2d(ih)%x(1)+nb*rnv(ih)
        irb = max(min(int((rb-pos%rr(1))/pos%delta_r)+1,pos%nrr),1)
        if (abs(ray2d(ih)%x(1)-ray2d(ih-1)%x(1)) < 1.0d3*spacing(ray2d(ih)%x(1)) .or. ira == irb) then
          ra = rb
          na = nb
          ira = irb
          skip_step =  .true. 
        endif
      endif
      if ( .not. skip_step) then
        q = ray2d(ih-1)%q(1)
        if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
          phase = phase+pi/2.0d0
        endif
        qold = q
        rcvrdeclangle = rcvrdeclanglev(ih)
        ii = 0
        if (irb <= ira) then
          ii = 1
        endif
        do ir = ira+1-ii, irb+ii, sign(1,irb-ira)
          w = (pos%rr(ir)-ra)/(rb-ra)
          n = abs(na+w*(nb-na))
          q = ray2d(ih-1)%q(1)+w*dq(ih-1)
          l = abs(q)/q0
          if (n < l) then
            delay = ray2d(ih-1)%tau+w*dtau(ih-1)
            amp = ray2d(ih)%amp/sqrt(abs(q))
            w = (l-n)/l
            amp = amp*w
            phaseint = ray2d(ih-1)%phase+phase
            if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
              phaseint = phase+pi/2.0d0
            endif
            call applycontribution( ih,ir,iz,delay,amp,phaseint,rcvrdeclangle )
          endif
        end do
      endif
      ra = rb
      na = nb
      ira = irb
    end do stepping
  end do rcvrdepths
  end subroutine influencegeohatraycen
  subroutine influencegeohatraycen_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use angle_mod, only : angles

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8
  integer, parameter :: ikind7 = 8
  integer, parameter :: ikind8 = 8
  integer, parameter :: ikind9 = 8
  integer, parameter :: ikinea = 8

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp
  real(kind=8) :: amp_tl
  real(kind=8) :: amph
  complex(kind=8) :: delay
  complex(kind=8) :: delay_tl
  real(kind=8) :: dq(beam%nsteps-1)
  real(kind=8) :: dq_tl(beam%nsteps-1)
  complex(kind=8) :: dtau(beam%nsteps-1)
  complex(kind=8) :: dtau_tl(beam%nsteps-1)
  integer :: ih
  integer :: ii
  integer :: ir
  integer :: ira
  real(kind=8) :: irah_tl
  integer :: irb
  real(kind=8) :: irbh_tl
  integer :: iz
  real(kind=8) :: l
  real(kind=8) :: l_tl
  real(kind=8) :: lh
  real(kind=8) :: n
  real(kind=8) :: n_tl
  real(kind=8) :: na
  real(kind=8) :: na_tl
  real(kind=8) :: nb
  real(kind=8) :: nb_tl
  real(kind=8) :: nh
  real(kind=8) :: phase
  real(kind=8) :: phaseint
  real(kind=8) :: phaseint_tl
  real(kind=8) :: q
  real(kind=8) :: q0
  real(kind=8) :: q0_tl
  real(kind=8) :: q_tl
  real(kind=8) :: qold
  real(kind=8) :: qold_tl
  real(kind=8) :: ra
  real(kind=8) :: ra_tl
  real(kind=8) :: ratio1
  real(kind=8) :: rb
  real(kind=8) :: rb_tl
  real(kind=8) :: rcvrdeclangle
  real(kind=8) :: rcvrdeclanglev(beam%nsteps)
  real(kind=8) :: rnv(beam%nsteps)
  real(kind=8) :: rnv_tl(beam%nsteps)
  real(kind=8) :: s
  logical :: skip_step
  real(kind=8) :: w
  real(kind=8) :: w_tl
  real(kind=8) :: znv(beam%nsteps)
  real(kind=8) :: znv_tl(beam%nsteps)
  real(kind=8) :: zr

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  w_tl = 0._ikinea
  w = 0
  s = 0
  n_tl = 0._ikind9
  n = 0
  rb_tl = ra_tl
  rb = ra
  q_tl = 0._ikind8
  q = 0
  amp_tl = 0._ikind7
  amp = 0
  phaseint_tl = 0._ikind6
  phaseint = 0
  rcvrdeclangle = 180
  delay_tl = (0._ikind5,0._ikind5)
  delay = 0
  q0_tl = ray2d_tl(1)%c_tl/angles%dalpha
  q0 = ray2d(1)%c/angles%dalpha
  dq_tl = ray2d_tl(2:beam%nsteps)%q_tl(1)-ray2d_tl(1:beam%nsteps-1)%q_tl(1)
  dq = ray2d(2:beam%nsteps)%q(1)-ray2d(1:beam%nsteps-1)%q(1)
  dtau_tl = ray2d_tl(2:beam%nsteps)%tau_tl-ray2d_tl(1:beam%nsteps-1)%tau_tl
  dtau = ray2d(2:beam%nsteps)%tau-ray2d(1:beam%nsteps-1)%tau
  znv_tl = (-(ray2d_tl(1:beam%nsteps)%c_tl*ray2d(1:beam%nsteps)%t(1)))-ray2d_tl(1:beam%nsteps)%t_tl(1)*ray2d(1:beam%nsteps)%c
  znv = -(ray2d(1:beam%nsteps)%t(1)*ray2d(1:beam%nsteps)%c)
  rnv_tl = ray2d_tl(1:beam%nsteps)%c_tl*ray2d(1:beam%nsteps)%t(2)+ray2d_tl(1:beam%nsteps)%t_tl(2)*ray2d(1:beam%nsteps)%c
  rnv = ray2d(1:beam%nsteps)%t(2)*ray2d(1:beam%nsteps)%c
  do ii = 1, beam%nsteps
    if (all(ray2d(ii)%t == 0.0)) then
      rcvrdeclanglev(ii) = 0.0
    else
      rcvrdeclanglev(ii) = rad2deg*atan2(ray2d(ii)%t(2),ray2d(ii)%t(1))
    endif
  end do
  ratio1 = 1.0d0
  if (beam%runtype(4:4) == 'R') then
    ratio1 = sqrt(abs(cos(srcdeclangle/rad2deg)))
  endif
  ray2d_tl(1:beam%nsteps)%amp_tl = ray2d_tl(1:beam%nsteps)%amp_tl*ratio1*sqrt(ray2d(1:beam%nsteps)%c)+ray2d_tl(1:beam%nsteps)%c_tl*(ratio1/(2._8*&
&sqrt(ray2d(1:beam%nsteps)%c)))*ray2d(1:beam%nsteps)%amp
  ray2d(1:beam%nsteps)%amp = ratio1*sqrt(ray2d(1:beam%nsteps)%c)*ray2d(1:beam%nsteps)%amp
  rcvrdepths1: do iz = 1, nrz_per_range
    zr = pos%rz(iz)
    phase = 0.0
    qold_tl = ray2d_tl(1)%q_tl(1)
    qold = ray2d(1)%q(1)
    if (abs(znv(1)) < 1d-6) then
      na_tl = 0._ikind4
      na = 1d10
      ra_tl = 0._ikind3
      ra = 1d10
      ira = 1
    else
      na_tl = (-(ray2d_tl(1)%x_tl(2)/znv(1)))-znv_tl(1)*((zr-ray2d(1)%x(2))/znv(1)/znv(1))
      na = (zr-ray2d(1)%x(2))/znv(1)
      ra_tl = na_tl*rnv(1)+ray2d_tl(1)%x_tl(1)+rnv_tl(1)*na
      ra = ray2d(1)%x(1)+na*rnv(1)
      irah_tl = ra_tl/pos%delta_r
      ira = max(min(1+int((ra-pos%rr(1))/pos%delta_r),pos%nrr),1)
    endif
    stepping1: do ih = 2, beam%nsteps
      skip_step =  .false. 
      if (abs(znv(ih)) < 1d-10) then
        skip_step =  .true. 
        rb_tl = 0._ikind2
        rb = 1d10
      else
        nb_tl = (-(ray2d_tl(ih)%x_tl(2)/znv(ih)))-znv_tl(ih)*((zr-ray2d(ih)%x(2))/znv(ih)/znv(ih))
        nb = (zr-ray2d(ih)%x(2))/znv(ih)
        rb_tl = nb_tl*rnv(ih)+ray2d_tl(ih)%x_tl(1)+rnv_tl(ih)*nb
        rb = ray2d(ih)%x(1)+nb*rnv(ih)
        irbh_tl = rb_tl/pos%delta_r
        irb = max(min(1+int((rb-pos%rr(1))/pos%delta_r),pos%nrr),1)
        if (abs(ray2d(ih)%x(1)-ray2d(ih-1)%x(1)) < 1.0d3*spacing(ray2d(ih)%x(1)) .or. ira == irb) then
          ra_tl = rb_tl
          ra = rb
          na_tl = nb_tl
          na = nb
          ira = irb
          skip_step =  .true. 
        endif
      endif
      if ( .not. skip_step) then
        q_tl = ray2d_tl(ih-1)%q_tl(1)
        q = ray2d(ih-1)%q(1)
        if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
          phase = phase+pi/2.0d0
        endif
        qold_tl = q_tl
        qold = q
        rcvrdeclangle = rcvrdeclanglev(ih)
        ii = 0
        if (irb <= ira) then
          ii = 1
        endif
        do ir = ira+1-ii, irb+ii, sign(1,irb-ira)
          w_tl = ra_tl*(((-1)+(pos%rr(ir)-ra)/(rb-ra))/(rb-ra))-rb_tl*((pos%rr(ir)-ra)/(rb-ra)/(rb-ra))
          w = (pos%rr(ir)-ra)/(rb-ra)
          nh = na+w*(nb-na)
          n_tl = (na_tl*(1-w)+nb_tl*w+w_tl*(nb-na))*sign(1._8,nh)
          n = abs(nh)
          q_tl = dq_tl(ih-1)*w+ray2d_tl(ih-1)%q_tl(1)+w_tl*dq(ih-1)
          q = ray2d(ih-1)%q(1)+w*dq(ih-1)
          lh = abs(q)
          l_tl = q_tl*sign(1._8,q)/q0-q0_tl*(lh/q0/q0)
          l = lh/q0
          if (n < l) then
            delay_tl = dtau_tl(ih-1)*w+ray2d_tl(ih-1)%tau_tl+w_tl*dtau(ih-1)
            delay = ray2d(ih-1)%tau+w*dtau(ih-1)
            amph = abs(q)
            amp_tl = (-(q_tl*(ray2d(ih)%amp/(2._8*sqrt(amph))/sqrt(amph)/sqrt(amph))*sign(1._8,q)))+ray2d_tl(ih)%amp_tl/sqrt(amph)
            amp = ray2d(ih)%amp/sqrt(amph)
            w_tl = l_tl*((1-(l-n)/l)/l)-n_tl/l
            w = (l-n)/l
            amp_tl = amp_tl*w+w_tl*amp
            amp = amp*w
            phaseint_tl = ray2d_tl(ih-1)%phase_tl
            phaseint = ray2d(ih-1)%phase+phase
            if (q <= 0.0d0 .and. qold > 0.0d0 .or. q >= 0.0d0 .and. qold < 0.0d0) then
              phaseint_tl = 0._ikind1
              phaseint = phase+pi/2.0d0
            endif
            call applycontribution_tl( ih,ir,iz,delay,delay_tl,amp,amp_tl,phaseint,phaseint_tl,rcvrdeclangle )
          endif
        end do
      endif
      ra_tl = rb_tl
      ra = rb
      na_tl = nb_tl
      na = nb
      ira = irb
    end do stepping1
  end do rcvrdepths1

  end subroutine influencegeohatraycen_tl
  subroutine locabs( varin, varabs )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(inout) :: varabs
  real(kind=8), intent(in) :: varin

  if (varin < 0) then
    varabs = -(1*varin)
  else
    varabs = varin
  endif
  return
  end subroutine locabs
  subroutine scalepressure( c, r, u, nrz, nrcvr )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_mod, only : beam
  use angle_mod, only : angles

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: c
  integer, intent(in) :: nrcvr
  integer, intent(in) :: nrz
  real(kind=8), intent(in) :: r(nrcvr)
  complex, intent(inout) :: u(nrz,nrcvr)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: const
  real(kind=8) :: factor
  integer :: ir

  select case ( beam%runtype(2:2) )
  case ('C')
    const = -(angles%dalpha*sqrt(ihop_freq)/c)
  case ('R')
    const = -(angles%dalpha*sqrt(ihop_freq)/c)
  case default
    const = -1.
  end select
  if (beam%runtype(1:1) /= 'C') then
    u = sqrt(real(u))
  endif
  ranges: do ir = 1, nrcvr
    if (beam%runtype(4:4) == 'X') then
      factor = -(4.0*sqrt(pi)*const)
    else
      if (r(ir) == 0) then
        factor = 0.0d0
      else
        if (r(ir) > 0) then
          factor = const/sqrt(r(ir))
        else
          factor = zerorl
        endif
      endif
    endif
    u(:,ir) = sngl(factor)*u(:,ir)
  end do ranges
  end subroutine scalepressure
  subroutine scalepressure_tl( c, r, u, nrz, nrcvr )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_mod, only : beam
  use angle_mod, only : angles

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: c
  integer, intent(in) :: nrcvr
  integer, intent(in) :: nrz
  real(kind=8), intent(in) :: r(nrcvr)
  complex, intent(inout) :: u(nrz,nrcvr)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: const
  real(kind=8) :: factor
  integer :: ir

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  select case ( beam%runtype(2:2) )
  case ('C')
    const = -(angles%dalpha*sqrt(ihop_freq)/c)
  case ('R')
    const = -(angles%dalpha*sqrt(ihop_freq)/c)
  case default
    const = -1.
  end select
  if (beam%runtype(1:1) /= 'C') then
    u = sqrt(real(u))
  endif
  ranges1: do ir = 1, nrcvr
    if (beam%runtype(4:4) == 'X') then
      factor = -(4.0*sqrt(pi)*const)
    else
      if (r(ir) == 0) then
        factor = 0.0d0
      else
        if (r(ir) > 0) then
          factor = const/sqrt(r(ir))
        else
          factor = zerorl
        endif
      endif
    endif
    u(:,ir) = sngl(factor)*u(:,ir)
  end do ranges1

  end subroutine scalepressure_tl
end module     influence
