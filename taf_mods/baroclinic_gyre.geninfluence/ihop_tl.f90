!                           DISCLAIMER
! 
!   This file was generated by TAF version 6.8.11
! 
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
! 
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
! 
module     ihop
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use ihop_mod, only : arrfile,delfile,onecmplx,prtfile,rayfile,shdfile

implicit none

!==============================================
! write visibility
!==============================================
private
public :: ihop_main
public :: ihop_main_tl

!==============================================
! declare parameters
!==============================================
integer, private, parameter :: cachelinesize = 256
integer, private, parameter :: comm_get = 4
integer, private, parameter :: comm_msg = 2
integer, private, parameter :: comm_none = 1
integer, private, parameter :: comm_put = 3
character(len=*), private, parameter :: commentcharacter = '#'
integer, private, parameter :: debleva = 1
integer, private, parameter :: deblevb = 2
integer, private, parameter :: deblevc = 3
integer, private, parameter :: deblevd = 4
integer, private, parameter :: debleve = 5
integer, private, parameter :: deblevzero = 0
double precision, private, parameter :: pi = 3.14159265358979323844d0
double precision, private, parameter :: deg2rad = 2.d0*pi/360.d0
character(len=*), private, parameter :: error_header = ' *** ERROR ***'
integer, private, parameter :: exch_ignore_corners = 0
integer, private, parameter :: exch_update_corners = 1
integer, private, parameter :: forward_simulation = 0
integer, private, parameter :: gsvec_size = 1024
double precision, private, parameter :: halfrl = 0.5d0
double precision, private, parameter :: halfrs = 0.5d0
integer, private, parameter :: ihop_max_idw = 4
integer, private, parameter :: ihop_max_nc_size = 15
integer, private, parameter :: ihop_max_range = 6
integer, private, parameter :: index_i = 1
integer, private, parameter :: index_j = 2
integer, private, parameter :: index_k = 3
integer, private, parameter :: index_none = 4
integer, private, parameter :: lshare1 = cachelinesize
integer, private, parameter :: lshare4 = cachelinesize/4
integer, private, parameter :: lshare8 = cachelinesize/8
integer, private, parameter :: max_len_fnam = 512
integer, private, parameter :: max_len_mbuf = 512
integer, private, parameter :: max_len_prec = 200
integer, private, parameter :: max_no_threads = 4
integer, private, parameter :: max_num_comm_modes = 4
integer, private, parameter :: olx = 3
integer, private, parameter :: max_olx = olx
integer, private, parameter :: oly = 3
integer, private, parameter :: max_oly = oly
integer, private, parameter :: mpi_2double_precision = 1275072547
integer, private, parameter :: mpi_2int = 1275070486
integer, private, parameter :: mpi_2integer = 1275070496
integer, private, parameter :: mpi_2real = 1275070497
integer, private, parameter :: mpi_address_kind = 8
integer, private, parameter :: mpi_aint = 1275070531
integer, private, parameter :: mpi_any_source = -2
integer, private, parameter :: mpi_any_tag = -1
integer, private, parameter :: mpi_appnum = 1681915918
logical, private, parameter :: mpi_async_protects_nonblocking =  .false. 
integer, private, parameter :: mpi_band = 1476395014
integer, private, parameter :: mpi_bor = 1476395016
integer, private, parameter :: mpi_bsend_overhead = 88
integer, private, parameter :: mpi_bxor = 1476395018
integer, private, parameter :: mpi_byte = 1275068685
integer, private, parameter :: mpi_c_bool = 1275068735
integer, private, parameter :: mpi_c_complex = 1275070528
integer, private, parameter :: mpi_c_double_complex = 1275072577
integer, private, parameter :: mpi_c_float_complex = 1275070528
integer, private, parameter :: mpi_c_long_double_complex = 1275076674
integer, private, parameter :: mpi_cart = 2
integer, private, parameter :: mpi_char = 1275068673
integer, private, parameter :: mpi_character = 1275068698
integer, private, parameter :: mpi_combiner_contiguous = 3
integer, private, parameter :: mpi_combiner_darray = 14
integer, private, parameter :: mpi_combiner_dup = 2
integer, private, parameter :: mpi_combiner_f90_complex = 16
integer, private, parameter :: mpi_combiner_f90_integer = 17
integer, private, parameter :: mpi_combiner_f90_real = 15
integer, private, parameter :: mpi_combiner_hindexed = 9
integer, private, parameter :: mpi_combiner_hindexed_block = 19
integer, private, parameter :: mpi_combiner_hindexed_integer = 8
integer, private, parameter :: mpi_combiner_hvector = 6
integer, private, parameter :: mpi_combiner_hvector_integer = 5
integer, private, parameter :: mpi_combiner_indexed = 7
integer, private, parameter :: mpi_combiner_indexed_block = 10
integer, private, parameter :: mpi_combiner_named = 1
integer, private, parameter :: mpi_combiner_resized = 18
integer, private, parameter :: mpi_combiner_struct = 12
integer, private, parameter :: mpi_combiner_struct_integer = 11
integer, private, parameter :: mpi_combiner_subarray = 13
integer, private, parameter :: mpi_combiner_vector = 4
integer, private, parameter :: mpi_comm_null = 67108864
integer, private, parameter :: mpi_comm_self = 1140850689
integer, private, parameter :: mpi_comm_type_shared = 1
integer, private, parameter :: mpi_comm_world = 1140850688
integer, private, parameter :: mpi_complex = 1275070494
integer, private, parameter :: mpi_complex16 = 1275072554
integer, private, parameter :: mpi_complex32 = 1275076652
integer, private, parameter :: mpi_complex8 = 1275070504
integer, private, parameter :: mpi_congruent = 1
integer, private, parameter :: mpi_count = 1275070533
integer, private, parameter :: mpi_count_kind = 8
integer, private, parameter :: mpi_cxx_bool = 1275068723
integer, private, parameter :: mpi_cxx_double_complex = 1275072565
integer, private, parameter :: mpi_cxx_float_complex = 1275070516
integer, private, parameter :: mpi_cxx_long_double_complex = 1275076662
integer, private, parameter :: mpi_datatype_null = 201326592
integer(kind=8), private, parameter :: mpi_displacement_current = -54278278
integer, private, parameter :: mpi_dist_graph = 3
integer, private, parameter :: mpi_distribute_block = 121
integer, private, parameter :: mpi_distribute_cyclic = 122
integer, private, parameter :: mpi_distribute_dflt_darg = -49767
integer, private, parameter :: mpi_distribute_none = 123
integer, private, parameter :: mpi_double = 1275070475
integer, private, parameter :: mpi_double_complex = 1275072546
integer, private, parameter :: mpi_double_int = -1946157055
integer, private, parameter :: mpi_double_precision = 1275070495
integer, private, parameter :: mpi_err_access = 20
integer, private, parameter :: mpi_err_amode = 21
integer, private, parameter :: mpi_err_arg = 12
integer, private, parameter :: mpi_err_assert = 53
integer, private, parameter :: mpi_err_bad_file = 22
integer, private, parameter :: mpi_err_base = 46
integer, private, parameter :: mpi_err_buffer = 1
integer, private, parameter :: mpi_err_comm = 5
integer, private, parameter :: mpi_err_conversion = 23
integer, private, parameter :: mpi_err_count = 2
integer, private, parameter :: mpi_err_dims = 11
integer, private, parameter :: mpi_err_disp = 52
integer, private, parameter :: mpi_err_dup_datarep = 24
integer, private, parameter :: mpi_err_file = 27
integer, private, parameter :: mpi_err_file_exists = 25
integer, private, parameter :: mpi_err_file_in_use = 26
integer, private, parameter :: mpi_err_group = 8
integer, private, parameter :: mpi_err_in_status = 17
integer, private, parameter :: mpi_err_info = 28
integer, private, parameter :: mpi_err_info_key = 29
integer, private, parameter :: mpi_err_info_nokey = 31
integer, private, parameter :: mpi_err_info_value = 30
integer, private, parameter :: mpi_err_intern = 16
integer, private, parameter :: mpi_err_io = 32
integer, private, parameter :: mpi_err_keyval = 48
integer, private, parameter :: mpi_err_lastcode = 1073741823
integer, private, parameter :: mpi_err_locktype = 47
integer, private, parameter :: mpi_err_name = 33
integer, private, parameter :: mpi_err_no_mem = 34
integer, private, parameter :: mpi_err_no_space = 36
integer, private, parameter :: mpi_err_no_such_file = 37
integer, private, parameter :: mpi_err_not_same = 35
integer, private, parameter :: mpi_err_op = 9
integer, private, parameter :: mpi_err_other = 15
integer, private, parameter :: mpi_err_pending = 18
integer, private, parameter :: mpi_err_port = 38
integer, private, parameter :: mpi_err_quota = 39
integer, private, parameter :: mpi_err_rank = 6
integer, private, parameter :: mpi_err_read_only = 40
integer, private, parameter :: mpi_err_request = 19
integer, private, parameter :: mpi_err_rma_attach = 56
integer, private, parameter :: mpi_err_rma_conflict = 49
integer, private, parameter :: mpi_err_rma_flavor = 58
integer, private, parameter :: mpi_err_rma_range = 55
integer, private, parameter :: mpi_err_rma_shared = 57
integer, private, parameter :: mpi_err_rma_sync = 50
integer, private, parameter :: mpi_err_root = 7
integer, private, parameter :: mpi_err_service = 41
integer, private, parameter :: mpi_err_size = 51
integer, private, parameter :: mpi_err_spawn = 42
integer, private, parameter :: mpi_err_tag = 4
integer, private, parameter :: mpi_err_topology = 10
integer, private, parameter :: mpi_err_truncate = 14
integer, private, parameter :: mpi_err_type = 3
integer, private, parameter :: mpi_err_unknown = 13
integer, private, parameter :: mpi_err_unsupported_datarep = 43
integer, private, parameter :: mpi_err_unsupported_operation = 44
integer, private, parameter :: mpi_err_win = 45
integer, private, parameter :: mpi_errhandler_null = 335544320
integer, private, parameter :: mpi_error = 5
integer, private, parameter :: mpi_errors_are_fatal = 1409286144
integer, private, parameter :: mpi_errors_return = 1409286145
integer, private, parameter :: mpi_file_null = 0
integer, private, parameter :: mpi_float = 1275069450
integer, private, parameter :: mpi_float_int = -1946157056
integer, private, parameter :: mpi_graph = 1
integer, private, parameter :: mpi_group_empty = 1207959552
integer, private, parameter :: mpi_group_null = 134217728
integer, private, parameter :: mpi_host = 1681915908
integer, private, parameter :: mpi_ident = 0
integer, private, parameter :: mpi_info_env = 1543503873
integer, private, parameter :: mpi_info_null = 469762048
integer, private, parameter :: mpi_int = 1275069445
integer, private, parameter :: mpi_int16_t = 1275068984
integer, private, parameter :: mpi_int32_t = 1275069497
integer, private, parameter :: mpi_int64_t = 1275070522
integer, private, parameter :: mpi_int8_t = 1275068727
integer, private, parameter :: mpi_integer = 1275069467
integer, private, parameter :: mpi_integer1 = 1275068717
integer, private, parameter :: mpi_integer16 = mpi_datatype_null
integer, private, parameter :: mpi_integer2 = 1275068975
integer, private, parameter :: mpi_integer4 = 1275069488
integer, private, parameter :: mpi_integer8 = 1275070513
integer, private, parameter :: mpi_integer_kind = 4
integer, private, parameter :: mpi_io = 1681915910
integer, private, parameter :: mpi_keyval_invalid = 603979776
integer, private, parameter :: mpi_land = 1476395013
integer, private, parameter :: mpi_lastusedcode = 1681915916
integer, private, parameter :: mpi_lb = 1275068432
integer, private, parameter :: mpi_lock_exclusive = 234
integer, private, parameter :: mpi_lock_shared = 235
integer, private, parameter :: mpi_logical = 1275069469
integer, private, parameter :: mpi_long = 1275070471
integer, private, parameter :: mpi_long_double = 1275072524
integer, private, parameter :: mpi_long_double_int = -1946157052
integer, private, parameter :: mpi_long_int = -1946157054
integer, private, parameter :: mpi_long_long = 1275070473
integer, private, parameter :: mpi_long_long_int = 1275070473
integer, private, parameter :: mpi_lor = 1476395015
integer, private, parameter :: mpi_lxor = 1476395017
integer, private, parameter :: mpi_max = 1476395009
integer, private, parameter :: mpi_max_datarep_string = 127
integer, private, parameter :: mpi_max_error_string = 512-1
integer, private, parameter :: mpi_max_info_key = 254
integer, private, parameter :: mpi_max_info_val = 1023
integer, private, parameter :: mpi_max_library_version_string = 8192-1
integer, private, parameter :: mpi_max_object_name = 127
integer, private, parameter :: mpi_max_port_name = 255
integer, private, parameter :: mpi_max_processor_name = 128-1
integer, private, parameter :: mpi_maxloc = 1476395020
integer, private, parameter :: mpi_message_no_proc = 1811939328
integer, private, parameter :: mpi_message_null = 738197504
integer, private, parameter :: mpi_min = 1476395010
integer, private, parameter :: mpi_minloc = 1476395019
integer, private, parameter :: mpi_mode_append = 128
integer, private, parameter :: mpi_mode_create = 1
integer, private, parameter :: mpi_mode_delete_on_close = 16
integer, private, parameter :: mpi_mode_excl = 64
integer, private, parameter :: mpi_mode_nocheck = 1024
integer, private, parameter :: mpi_mode_noprecede = 8192
integer, private, parameter :: mpi_mode_noput = 4096
integer, private, parameter :: mpi_mode_nostore = 2048
integer, private, parameter :: mpi_mode_nosucceed = 16384
integer, private, parameter :: mpi_mode_rdonly = 2
integer, private, parameter :: mpi_mode_rdwr = 8
integer, private, parameter :: mpi_mode_sequential = 256
integer, private, parameter :: mpi_mode_unique_open = 32
integer, private, parameter :: mpi_mode_wronly = 4
integer, private, parameter :: mpi_no_op = 1476395022
integer, private, parameter :: mpi_offset = 1275070532
integer, private, parameter :: mpi_offset_kind = 8
integer, private, parameter :: mpi_op_null = 402653184
integer, private, parameter :: mpi_order_c = 56
integer, private, parameter :: mpi_order_fortran = 57
integer, private, parameter :: mpi_packed = 1275068687
integer, private, parameter :: mpi_proc_null = -1
integer, private, parameter :: mpi_prod = 1476395012
integer, private, parameter :: mpi_real = 1275069468
integer, private, parameter :: mpi_real16 = 1275072555
integer, private, parameter :: mpi_real4 = 1275069479
integer, private, parameter :: mpi_real8 = 1275070505
integer, private, parameter :: mpi_replace = 1476395021
integer, private, parameter :: mpi_request_null = 738197504
integer, private, parameter :: mpi_root = -3
integer, private, parameter :: mpi_seek_cur = 602
integer, private, parameter :: mpi_seek_end = 604
integer, private, parameter :: mpi_seek_set = 600
integer, private, parameter :: mpi_short = 1275068931
integer, private, parameter :: mpi_short_int = -1946157053
integer, private, parameter :: mpi_signed_char = 1275068696
integer, private, parameter :: mpi_similar = 2
integer, private, parameter :: mpi_source = 3
integer, private, parameter :: mpi_status_size = 5
logical, private, parameter :: mpi_subarrays_supported =  .false. 
integer, private, parameter :: mpi_subversion = 1
integer, private, parameter :: mpi_success = 0
integer, private, parameter :: mpi_sum = 1476395011
integer, private, parameter :: mpi_tag = 4
integer, private, parameter :: mpi_tag_ub = 1681915906
integer, private, parameter :: mpi_thread_funneled = 1
integer, private, parameter :: mpi_thread_multiple = 3
integer, private, parameter :: mpi_thread_serialized = 2
integer, private, parameter :: mpi_thread_single = 0
integer, private, parameter :: mpi_typeclass_complex = 3
integer, private, parameter :: mpi_typeclass_integer = 2
integer, private, parameter :: mpi_typeclass_real = 1
integer, private, parameter :: mpi_ub = 1275068433
integer, private, parameter :: mpi_uint16_t = 1275068988
integer, private, parameter :: mpi_uint32_t = 1275069501
integer, private, parameter :: mpi_uint64_t = 1275070526
integer, private, parameter :: mpi_uint8_t = 1275068731
integer, private, parameter :: mpi_undefined = -32766
integer, private, parameter :: mpi_unequal = 3
integer, private, parameter :: mpi_universe_size = 1681915914
integer, private, parameter :: mpi_unsigned = 1275069446
integer, private, parameter :: mpi_unsigned_char = 1275068674
integer, private, parameter :: mpi_unsigned_long = 1275070472
integer, private, parameter :: mpi_unsigned_long_long = 1275070489
integer, private, parameter :: mpi_unsigned_short = 1275068932
integer, private, parameter :: mpi_version = 3
integer, private, parameter :: mpi_wchar = 1275069454
integer, private, parameter :: mpi_win_base = 1711276034
integer, private, parameter :: mpi_win_create_flavor = 1711276040
integer, private, parameter :: mpi_win_disp_unit = 1711276038
integer, private, parameter :: mpi_win_flavor_allocate = 2
integer, private, parameter :: mpi_win_flavor_create = 1
integer, private, parameter :: mpi_win_flavor_dynamic = 3
integer, private, parameter :: mpi_win_flavor_shared = 4
integer, private, parameter :: mpi_win_model = 1711276042
integer, private, parameter :: mpi_win_null = 536870912
integer, private, parameter :: mpi_win_separate = 1
integer, private, parameter :: mpi_win_size = 1711276036
integer, private, parameter :: mpi_win_unified = 2
integer, private, parameter :: mpi_wtime_is_global = 1681915912
integer, private, parameter :: nfilesmax_ihop = 1
integer, private, parameter :: nobsmax_ihop = 10
integer, private, parameter :: npx = 2
integer, private, parameter :: npy = 2
integer, private, parameter :: nr = 15
integer, private, parameter :: nrd = 1
integer, private, parameter :: nrr = 1
integer, private, parameter :: nsd = 1
integer, private, parameter :: nsx = 1
integer, private, parameter :: nsy = 1
integer, private, parameter :: nts = 1080
integer, private, parameter :: null_tile = -1
integer, private, parameter :: snx = 31
integer, private, parameter :: nx = snx*nsx*npx
integer, private, parameter :: sny = 31
integer, private, parameter :: ny = sny*nsy*npy
double precision, private, parameter :: onerl = 1.0d0
double precision, private, parameter :: oners = 1.0d0
integer, private, parameter :: precfloat32 = 32
integer, private, parameter :: precfloat64 = 64
character(len=*), private, parameter :: print_map_xy = 'XY'
character(len=*), private, parameter :: print_map_xz = 'XZ'
character(len=*), private, parameter :: print_map_yz = 'YZ'
character(len=*), private, parameter :: process_header = 'PID.TID'
integer, private, parameter :: reverse_simulation = 1
character(len=*), private, parameter :: squeeze_both = 'B'
character(len=*), private, parameter :: squeeze_left = 'L'
character(len=*), private, parameter :: squeeze_right = 'R'
integer, private, parameter :: tangent_simulation = 2
double precision, private, parameter :: tworl = 2.0d0
double precision, private, parameter :: twors = 2.0d0
real, private, parameter :: unset_float4 = 1.234567e5
double precision, private, parameter :: unset_float8 = 1.234567d5
integer, private, parameter :: unset_i = 123456789
double precision, private, parameter :: unset_rl = 1.234567d5
double precision, private, parameter :: unset_rs = 1.234567d5
double precision, private, parameter :: zerorl = 0.0d0
double precision, private, parameter :: zerors = 0.0d0

!==============================================
! declare common blocks
!==============================================
integer, private :: eedataunit
integer, private :: errormessageunit
integer, private :: ioerrorcount(max_no_threads)
integer, private :: maxlengthprt1d
integer, private :: modeldataunit
integer, private :: mybxhi(max_no_threads)
integer, private :: mybxlo(max_no_threads)
integer, private :: mybyhi(max_no_threads)
integer, private :: mybylo(max_no_threads)
integer, private :: myprocid
integer, private :: mypx
integer, private :: mypy
integer, private :: myxgloballo
integer, private :: myygloballo
integer, private :: nthreads
integer, private :: ntx
integer, private :: nty
integer, private :: numberofprocs
integer, private :: pidio
integer, private :: scrunit1
integer, private :: scrunit2
integer, private :: standardmessageunit
common /eeparams_i/ errormessageunit, standardmessageunit, maxlengthprt1d, scrunit1, scrunit2, eedataunit, modeldataunit, numberofprocs, pidio, &
&myprocid, mypx, mypy, myxgloballo, myygloballo, nthreads, mybxlo, mybxhi, mybylo, mybyhi, ntx, nty, ioerrorcount

logical, private :: debugmode
logical, private :: eebooterror
logical, private :: eeenderror
logical, private :: fatalerror
logical, private :: printmapincludeszeros
logical, private :: usecoupler
logical, private :: usecubedsphereexchange
logical, private :: usenest2w_child
logical, private :: usenest2w_parent
logical, private :: usenest_child
logical, private :: usenest_parent
logical, private :: useoasis
logical, private :: usesetrlstk
logical, private :: usesigreg
logical, private :: usesinglecpuinput
logical, private :: usesinglecpuio
common /eeparams_l/ eebooterror, eeenderror, fatalerror, debugmode, usesinglecpuio, usesinglecpuinput, printmapincludeszeros, usecubedsphereexchange,&
& usecoupler, usenest_parent, usenest_child, usenest2w_parent, usenest2w_child, useoasis, usesetrlstk, usesigreg

character(len=128), private :: myprocessstr
common /eesupp_c/ myprocessstr

character(len=10), private :: commname(max_num_comm_modes)
common /eesupp_commname/ commname

integer, private :: mypid
integer, private :: nprocs
integer, private :: pide
integer, private :: pidn
integer, private :: pids
integer, private :: pidw
integer, private :: tilebie(nsx,nsy)
integer, private :: tilebin(nsx,nsy)
integer, private :: tilebis(nsx,nsy)
integer, private :: tilebiw(nsx,nsy)
integer, private :: tilebje(nsx,nsy)
integer, private :: tilebjn(nsx,nsy)
integer, private :: tilebjs(nsx,nsy)
integer, private :: tilebjw(nsx,nsy)
integer, private :: tilecommmodee(nsx,nsy)
integer, private :: tilecommmoden(nsx,nsy)
integer, private :: tilecommmodes(nsx,nsy)
integer, private :: tilecommmodew(nsx,nsy)
integer, private :: tileno(nsx,nsy)
integer, private :: tilenoe(nsx,nsy)
integer, private :: tilenon(nsx,nsy)
integer, private :: tilenos(nsx,nsy)
integer, private :: tilenow(nsx,nsy)
integer, private :: tilepide(nsx,nsy)
integer, private :: tilepidn(nsx,nsy)
integer, private :: tilepids(nsx,nsy)
integer, private :: tilepidw(nsx,nsy)
integer, private :: tiletagrecve(nsx,nsy)
integer, private :: tiletagrecvn(nsx,nsy)
integer, private :: tiletagrecvs(nsx,nsy)
integer, private :: tiletagrecvw(nsx,nsy)
integer, private :: tiletagsende(nsx,nsy)
integer, private :: tiletagsendn(nsx,nsy)
integer, private :: tiletagsends(nsx,nsy)
integer, private :: tiletagsendw(nsx,nsy)
common /eesupp_i/ mypid, nprocs, pidw, pide, pidn, pids, tilecommmodew, tilecommmodee, tilecommmoden, tilecommmodes, tileno, tilenow, tilenoe, &
&tilenos, tilenon, tilepidw, tilepide, tilepids, tilepidn, tilebiw, tilebie, tilebis, tilebin, tilebjw, tilebje, tilebjs, tilebjn, tiletagsendw, &
&tiletagsende, tiletagsends, tiletagsendn, tiletagrecvw, tiletagrecve, tiletagrecvs, tiletagrecvn

logical, private :: allmyedgesaresharedmemory(max_no_threads)
logical, private :: notusingxperiodicity
logical, private :: notusingyperiodicity
logical, private :: therror(max_no_threads)
logical, private :: threadiscomplete(max_no_threads)
logical, private :: threadisrunning(max_no_threads)
logical, private :: usingmpi
logical, private :: usingsyncmessages
common /eesupp_l/ therror, threadisrunning, threadiscomplete, allmyedgesaresharedmemory, usingmpi, usingsyncmessages, notusingxperiodicity, &
&notusingyperiodicity

integer, private :: mpicomm
integer, private :: mpimyid
integer, private :: mpinprocs
integer, private :: mpipide
integer, private :: mpipidio
integer, private :: mpipidn
integer, private :: mpipidne
integer, private :: mpipidnw
integer, private :: mpipids
integer, private :: mpipidse
integer, private :: mpipidsw
integer, private :: mpipidw
integer, private :: mpipx
integer, private :: mpipy
integer, private :: mpitage
integer, private :: mpitagn
integer, private :: mpitagne
integer, private :: mpitagnw
integer, private :: mpitags
integer, private :: mpitagse
integer, private :: mpitagsw
integer, private :: mpitagw
integer, private :: mpitypexfaceblock_xy_r4
integer, private :: mpitypexfaceblock_xy_r8
integer, private :: mpitypexfaceblock_xyz_r4
integer, private :: mpitypexfaceblock_xyz_r8
integer, private :: mpitypexfacethread_xy_r4(max_no_threads)
integer, private :: mpitypexfacethread_xy_r8(max_no_threads)
integer, private :: mpitypexfacethread_xyz_r4(max_no_threads)
integer, private :: mpitypexfacethread_xyz_r8(max_no_threads)
integer, private :: mpitypeyfaceblock_xy_r4
integer, private :: mpitypeyfaceblock_xy_r8
integer, private :: mpitypeyfaceblock_xyz_r4
integer, private :: mpitypeyfaceblock_xyz_r8
integer, private :: mpitypeyfacethread_xy_r4(max_no_threads)
integer, private :: mpitypeyfacethread_xy_r8(max_no_threads)
integer, private :: mpitypeyfacethread_xyz_r4(max_no_threads)
integer, private :: mpitypeyfacethread_xyz_r8(max_no_threads)
integer, private :: mpixgloballo
integer, private :: mpiygloballo
common /eesupp_mpi_i/ mpipidw, mpipide, mpipids, mpipidn, mpipidse, mpipidsw, mpipidne, mpipidnw, mpipidio, mpimyid, mpinprocs, mpicomm, mpipx, &
&mpipy, mpixgloballo, mpiygloballo, mpitypexfaceblock_xy_r4, mpitypexfaceblock_xy_r8, mpitypeyfaceblock_xy_r4, mpitypeyfaceblock_xy_r8, &
&mpitypexfaceblock_xyz_r4, mpitypexfaceblock_xyz_r8, mpitypeyfaceblock_xyz_r4, mpitypeyfaceblock_xyz_r8, mpitypexfacethread_xy_r4, &
&mpitypexfacethread_xy_r8, mpitypeyfacethread_xy_r4, mpitypeyfacethread_xy_r8, mpitypexfacethread_xyz_r4, mpitypexfacethread_xyz_r8, &
&mpitypeyfacethread_xyz_r4, mpitypeyfacethread_xyz_r8, mpitage, mpitagw, mpitagn, mpitags, mpitagse, mpitagsw, mpitagnw, mpitagne

integer, private :: klowc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfs(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
integer, private :: ksurfw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_i/ ksurfc, ksurfw, ksurfs, klowc

double precision, private :: cosfacu(1-oly:sny+oly,nsx,nsy)
double precision, private :: cosfacv(1-oly:sny+oly,nsx,nsy)
double precision, private :: deepfac2c(nr)
double precision, private :: deepfac2f(nr+1)
double precision, private :: deepfacc(nr)
double precision, private :: deepfacf(nr+1)
double precision, private :: globalarea
double precision, private :: gravitysign
double precision, private :: recip_deepfac2c(nr)
double precision, private :: recip_deepfac2f(nr+1)
double precision, private :: recip_deepfacc(nr)
double precision, private :: recip_deepfacf(nr+1)
double precision, private :: rksign
double precision, private :: sqcosfacu(1-oly:sny+oly,nsx,nsy)
double precision, private :: sqcosfacv(1-oly:sny+oly,nsx,nsy)
common /grid_rl/ cosfacu, cosfacv, sqcosfacu, sqcosfacv, deepfacc, deepfac2c, recip_deepfacc, recip_deepfac2c, deepfacf, deepfac2f, recip_deepfacf, &
&recip_deepfac2f, gravitysign, rksign, globalarea

double precision, private :: ahybsigmc(nr)
double precision, private :: ahybsigmf(nr+1)
double precision, private :: anglecosc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: anglesinc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: bhybsigmc(nr)
double precision, private :: bhybsigmf(nr+1)
double precision, private :: dahybsigc(nr+1)
double precision, private :: dahybsigf(nr)
double precision, private :: dbhybsigc(nr+1)
double precision, private :: dbhybsigf(nr)
double precision, private :: drc(nr+1)
double precision, private :: drf(nr)
double precision, private :: dxc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dxv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: dyu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcori(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcoricos(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: fcorig(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: maskinc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskins(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: maskinw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: masks(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: maskw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: ra(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: ras(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: raw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: raz(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rc(nr)
double precision, private :: recip_drc(nr+1)
double precision, private :: recip_drf(nr)
double precision, private :: recip_dxc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dxv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_dyu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_ra(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_ras(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_raw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_raz(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rf(nr+1)
double precision, private :: rlows(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rloww(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: ro_surf(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rsurfs(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: rsurfw(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: tanphiatu(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: tanphiatv(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: u2zondir(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: v2zondir(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: xc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: xg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: yc(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: yg(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_rs/ dxc, dxf, dxg, dxv, dyc, dyf, dyg, dyu, rloww, rlows, ro_surf, rsurfw, rsurfs, recip_dxc, recip_dxf, recip_dxg, recip_dxv, &
&recip_dyc, recip_dyf, recip_dyg, recip_dyu, xc, yc, ra, raw, ras, raz, xg, yg, maskinc, maskinw, maskins, maskc, maskw, masks, recip_ra, recip_raw, &
&recip_ras, recip_raz, drc, drf, recip_drc, recip_drf, rc, rf, ahybsigmf, bhybsigmf, ahybsigmc, bhybsigmc, dahybsigf, dbhybsigf, dbhybsigc, &
&dahybsigc, tanphiatu, tanphiatv, anglecosc, anglesinc, u2zondir, v2zondir, fcori, fcorig, fcoricos

double precision, private :: hfacc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: hfacs(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: hfacw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: r_low(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
double precision, private :: recip_hfacc(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_hfacs(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_hfacw(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
double precision, private :: recip_rcol(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /grid_var_rs/ hfacc, hfacw, hfacs, recip_hfacc, recip_hfacw, recip_hfacs, r_low, recip_rcol

logical, private :: ihop_mdsio
logical, private :: ihop_mnc
common /ihop_package/ ihop_mnc, ihop_mdsio

character(len=2), private :: ihop_botopt
character(len=max_len_fnam), private :: ihop_fileroot
character(len=max_len_fnam), private :: ihop_interpfile
character(len=7), private :: ihop_runopt
character(len=max_len_fnam), private :: ihop_title
character(len=6), private :: ihop_topopt
common /ihop_params_c/ ihop_fileroot, ihop_title, ihop_topopt, ihop_botopt, ihop_runopt, ihop_interpfile

integer, private :: ihop_iter(nts)
integer, private :: ihop_nalpha
integer, private :: ihop_npts_idw
integer, private :: ihop_npts_range
integer, private :: ihop_nrd
integer, private :: ihop_nrr
integer, private :: ihop_nsd
integer, private :: ihop_nts
common /ihop_params_i/ ihop_nts, ihop_nsd, ihop_nrd, ihop_nrr, ihop_npts_range, ihop_npts_idw, ihop_nalpha, ihop_iter

logical, private :: usesspfile
logical, private :: writedelay
common /ihop_params_l/ writedelay, usesspfile

double precision, private :: ihop_alpha(2)
double precision, private :: ihop_bcsound
double precision, private :: ihop_bcsoundi
double precision, private :: ihop_bcsoundshear
double precision, private :: ihop_bcsoundsheari
double precision, private :: ihop_brho
double precision, private :: ihop_depth
double precision, private :: ihop_dumpfreq
double precision, private :: ihop_freq
double precision, private :: ihop_idw_weights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_ranges(ihop_max_range)
double precision, private :: ihop_rd(nrd)
double precision, private :: ihop_rr(nrr)
double precision, private :: ihop_sd(nsd)
double precision, private :: ihop_step
double precision, private :: ihop_sumweights(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_xc(ihop_max_range,ihop_max_nc_size)
double precision, private :: ihop_yc(ihop_max_range,ihop_max_nc_size)
common /ihop_params_r/ ihop_dumpfreq, ihop_freq, ihop_depth, ihop_bcsound, ihop_bcsoundshear, ihop_brho, ihop_bcsoundi, ihop_bcsoundsheari, ihop_sd, &
&ihop_rd, ihop_rr, ihop_alpha, ihop_step, ihop_yc, ihop_xc, ihop_idw_weights, ihop_ranges, ihop_sumweights

double precision, private :: ihop_sld(1-olx:snx+olx,1-oly:sny+oly,nsx,nsy)
common /ihop_state_2d/ ihop_sld

double precision, private :: ihop_ssp(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d/ ihop_ssp

double precision, private :: ihop_ssp_tl(1-olx:snx+olx,1-oly:sny+oly,nr,nsx,nsy)
common /ihop_state_3d_tl/ ihop_ssp_tl

integer, private :: mpi_comm_model
common /mpi_comms/ mpi_comm_model

integer, private :: mpi_myxgloballo(npx*npy)
integer, private :: mpi_myygloballo(npx*npy)
common /mpi_fullmap_i/ mpi_myxgloballo, mpi_myygloballo

integer, private :: mpi_unweighted
common /mpifcmb5/ mpi_unweighted

integer, private :: mpi_weights_empty
common /mpifcmb9/ mpi_weights_empty

integer, private :: mpi_bottom
integer, private :: mpi_in_place
integer, private :: mpi_status_ignore(mpi_status_size)
common /mpipriv1/ mpi_bottom, mpi_in_place, mpi_status_ignore

integer, private :: mpi_errcodes_ignore(1)
integer, private :: mpi_statuses_ignore(mpi_status_size,1)
common /mpipriv2/ mpi_statuses_ignore, mpi_errcodes_ignore

character(len=1), private :: mpi_argv_null(1)
character(len=1), private :: mpi_argvs_null(1,1)
common /mpiprivc/ mpi_argvs_null, mpi_argv_null

double precision, private :: heatcapacity_cp
common /parm_a/ heatcapacity_cp

double precision, private :: atm_cp
double precision, private :: atm_kappa
double precision, private :: atm_po
double precision, private :: atm_rd
double precision, private :: atm_rq
double precision, private :: celsius2k
integer, private :: integr_geopot
integer, private :: selectfindrosurf
common /parm_atm/ celsius2k, atm_cp, atm_rd, atm_kappa, atm_rq, atm_po, integr_geopot, selectfindrosurf

character(len=max_len_fnam), private :: addmassfile
character(len=max_len_fnam), private :: addswallfile
character(len=max_len_fnam), private :: addwwallfile
character(len=max_len_fnam), private :: adtapedir
character(len=max_len_fnam), private :: bathyfile
character(len=max_len_fnam), private :: buoyancyrelation
character(len=max_len_fnam), private :: delrcfile
character(len=max_len_fnam), private :: delrfile
character(len=max_len_fnam), private :: delxfile
character(len=max_len_fnam), private :: delyfile
character(len=max_len_fnam), private :: diffkrfile
character(len=max_len_fnam), private :: eddypsixfile
character(len=max_len_fnam), private :: eddypsiyfile
character(len=max_len_fnam), private :: empmrfile
character(len=6), private :: eostype
character(len=max_len_fnam), private :: geopotanomfile
character(len=max_len_fnam), private :: geothermalfile
character(len=max_len_fnam), private :: gravityfile
character(len=max_len_fnam), private :: horizgridfile
character(len=max_len_fnam), private :: hybsigmfile
character(len=max_len_fnam), private :: hydrogsaltfile
character(len=max_len_fnam), private :: hydrogthetafile
character(len=max_len_fnam), private :: lambdasaltfile
character(len=max_len_fnam), private :: lambdathetafile
character(len=max_len_fnam), private :: mdsiolocaldir
character(len=max_len_fnam), private :: meridwindfile
character(len=10), private :: pickupsuff
character(len=max_len_fnam), private :: ploadfile
character(len=max_len_fnam), private :: psurfinitfile
character(len=max_len_fnam), private :: rhoreffile
character(len=max_len_fnam), private :: saltclimfile
character(len=max_len_fnam), private :: saltfluxfile
character(len=max_len_fnam), private :: sreffile
character(len=max_len_fnam), private :: surfqfile
character(len=max_len_fnam), private :: surfqnetfile
character(len=max_len_fnam), private :: surfqswfile
character(len=max_len_prec/2), private :: the_run_name
character(len=max_len_fnam), private :: thetaclimfile
character(len=max_len_fnam), private :: topofile
character(len=max_len_fnam), private :: treffile
character(len=max_len_fnam), private :: uvelinitfile
character(len=max_len_fnam), private :: visca4dfile
character(len=max_len_fnam), private :: visca4zfile
character(len=max_len_fnam), private :: viscahdfile
character(len=max_len_fnam), private :: viscahzfile
character(len=max_len_fnam), private :: vvelinitfile
character(len=max_len_fnam), private :: wghtbalancefile
character(len=max_len_fnam), private :: zonalwindfile
common /parm_c/ buoyancyrelation, eostype, pickupsuff, mdsiolocaldir, adtapedir, treffile, sreffile, rhoreffile, gravityfile, delrfile, delrcfile, &
&hybsigmfile, delxfile, delyfile, horizgridfile, bathyfile, topofile, addwwallfile, addswallfile, viscahdfile, viscahzfile, visca4dfile, visca4zfile,&
& hydrogthetafile, hydrogsaltfile, diffkrfile, zonalwindfile, meridwindfile, thetaclimfile, saltclimfile, empmrfile, saltfluxfile, surfqfile, &
&surfqnetfile, surfqswfile, uvelinitfile, vvelinitfile, psurfinitfile, ploadfile, geopotanomfile, addmassfile, eddypsixfile, eddypsiyfile, &
&geothermalfile, lambdathetafile, lambdasaltfile, wghtbalancefile, the_run_name

integer, private :: cg2dmaxiters
integer, private :: cg2dminitersnsa
integer, private :: cg2dprecondfreq
integer, private :: cg2duseminressol
integer, private :: cg3dmaxiters
integer, private :: debuglevel
integer, private :: momforcingoutab
integer, private :: monitorselect
integer, private :: nenditer
integer, private :: niter0
integer, private :: nonlinfreesurf
integer, private :: ntimesteps
integer, private :: ntimesteps_l2
integer, private :: pcellmix_select
integer, private :: plotlevel
integer, private :: printresidualfreq
integer, private :: readbinaryprec
integer, private :: rwsuffixtype
integer, private :: saltadvscheme
integer, private :: saltvertadvscheme
integer, private :: select3dcorischeme
integer, private :: select_rstar
integer, private :: selectaddfluid
integer, private :: selectbalanceempmr
integer, private :: selectbotdragquadr
integer, private :: selectcorimap
integer, private :: selectcorischeme
integer, private :: selectimplicitdrag
integer, private :: selectkescheme
integer, private :: selectmetricterms
integer, private :: selectnhfreesurf
integer, private :: selectp_ineos_zc
integer, private :: selectpenetratingsw
integer, private :: selectsigmacoord
integer, private :: selectvortscheme
integer, private :: tempadvscheme
integer, private :: tempvertadvscheme
integer, private :: tracforcingoutab
integer, private :: writebinaryprec
common /parm_i/ cg2dmaxiters, cg2dminitersnsa, cg2dprecondfreq, cg2duseminressol, cg3dmaxiters, printresidualfreq, niter0, ntimesteps, ntimesteps_l2,&
& nenditer, selectcorimap, selectsigmacoord, nonlinfreesurf, select_rstar, selectnhfreesurf, selectp_ineos_zc, selectaddfluid, selectbalanceempmr, &
&selectimplicitdrag, momforcingoutab, tracforcingoutab, tempadvscheme, tempvertadvscheme, saltadvscheme, saltvertadvscheme, selectkescheme, &
&selectvortscheme, selectmetricterms, selectcorischeme, select3dcorischeme, selectbotdragquadr, selectpenetratingsw, pcellmix_select, readbinaryprec,&
& writebinaryprec, rwsuffixtype, monitorselect, debuglevel, plotlevel

logical, private :: addfrictionheating
logical, private :: allowfreezing
logical, private :: applyexchuv_early
logical, private :: balanceprintmean
logical, private :: balanceqnet
logical, private :: balancesaltclimrelax
logical, private :: balancethetaclimrelax
logical, private :: bottomvisc_pcell
logical, private :: calc_wvelocity
logical, private :: checkinisalt
logical, private :: checkinitemp
logical, private :: deepatmosphere
logical, private :: doab_ongtgs
logical, private :: doresethfactors
logical, private :: dosaltclimrelax
logical, private :: dothetaclimrelax
logical, private :: dumpinitandlast
logical, private :: exactconserv
logical, private :: fluidisair
logical, private :: fluidiswater
logical, private :: globalfiles
logical, private :: haswetcscorners
logical, private :: highordervorticity
logical, private :: implicitdiffusion
logical, private :: implicitfreesurface
logical, private :: implicitintgravwave
logical, private :: implicitviscosity
logical, private :: interdiffkr_pcell
logical, private :: interviscar_pcell
logical, private :: linfsconservetr
logical, private :: maskinisalt
logical, private :: maskinitemp
logical, private :: momadvection
logical, private :: momdissip_in_ab
logical, private :: momforcing
logical, private :: momimplvertadv
logical, private :: mompressureforcing
logical, private :: momstepping
logical, private :: momtidalforcing
logical, private :: momviscosity
logical, private :: monitor_stdio
logical, private :: multidimadvection
logical, private :: no_slip_bottom
logical, private :: no_slip_sides
logical, private :: nonhydrostatic
logical, private :: outputtypesinclusive
logical, private :: periodicexternalforcing
logical, private :: pickup_read_mdsio
logical, private :: pickup_write_immed
logical, private :: pickup_write_mdsio
logical, private :: pickupstrictlymatch
logical, private :: quasihydrostatic
logical, private :: rigidlid
logical, private :: rotategrid
logical, private :: salt_staypositive
logical, private :: saltadvection
logical, private :: saltforcing
logical, private :: saltimplvertadv
logical, private :: saltisactivetr
logical, private :: saltstepping
logical, private :: saltvertdiff4
logical, private :: setcenterdr
logical, private :: setinterfdr
logical, private :: snapshot_mdsio
logical, private :: staggertimestep
logical, private :: startfrompickupab2
logical, private :: storephihyd4phys
logical, private :: temp_staypositive
logical, private :: tempadvection
logical, private :: tempforcing
logical, private :: tempimplvertadv
logical, private :: tempisactivetr
logical, private :: tempstepping
logical, private :: tempvertdiff4
logical, private :: timeave_mdsio
logical, private :: uniformfreesurflev
logical, private :: uniformlin_phisurf
logical, private :: upwindshear
logical, private :: upwindvorticity
logical, private :: use3dsolver
logical, private :: useabsvorticity
logical, private :: useareavisclength
logical, private :: usecdscheme
logical, private :: usecoriolis
logical, private :: usefullleith
logical, private :: usejamartmomadv
logical, private :: usemin4hfacedges
logical, private :: usemultidimadvec
logical, private :: usenhmterms
logical, private :: usensacgsolver
logical, private :: usepickupbeforec54
logical, private :: userealfreshwaterflux
logical, private :: usesmag3d
logical, private :: usesrcgsolver
logical, private :: usestraintensionvisc
logical, private :: usingcartesiangrid
logical, private :: usingcurvilineargrid
logical, private :: usingcylindricalgrid
logical, private :: usingpcoords
logical, private :: usingsphericalpolargrid
logical, private :: usingzcoords
logical, private :: vectorinvariantmomentum
logical, private :: writepickupatend
common /parm_l/ fluidisair, fluidiswater, usingpcoords, usingzcoords, usingcartesiangrid, usingsphericalpolargrid, rotategrid, usingcylindricalgrid, &
&usingcurvilineargrid, haswetcscorners, deepatmosphere, setinterfdr, setcenterdr, usemin4hfacedges, interviscar_pcell, interdiffkr_pcell, &
&no_slip_sides, no_slip_bottom, bottomvisc_pcell, usesmag3d, usefullleith, usestraintensionvisc, useareavisclength, momviscosity, momadvection, &
&momforcing, momtidalforcing, mompressureforcing, usenhmterms, usecoriolis, usecdscheme, vectorinvariantmomentum, usejamartmomadv, upwindvorticity, &
&highordervorticity, useabsvorticity, upwindshear, momstepping, calc_wvelocity, tempstepping, saltstepping, addfrictionheating, temp_staypositive, &
&salt_staypositive, tempadvection, tempvertdiff4, tempisactivetr, tempforcing, saltadvection, saltvertdiff4, saltisactivetr, saltforcing, &
&maskinitemp, maskinisalt, checkinitemp, checkinisalt, usensacgsolver, usesrcgsolver, rigidlid, implicitfreesurface, uniformlin_phisurf, &
&uniformfreesurflev, exactconserv, linfsconservetr, userealfreshwaterflux, storephihyd4phys, quasihydrostatic, nonhydrostatic, use3dsolver, &
&implicitintgravwave, staggertimestep, applyexchuv_early, doresethfactors, implicitdiffusion, implicitviscosity, tempimplvertadv, saltimplvertadv, &
&momimplvertadv, multidimadvection, usemultidimadvec, momdissip_in_ab, doab_ongtgs, balanceqnet, balanceprintmean, balancethetaclimrelax, &
&balancesaltclimrelax, dothetaclimrelax, dosaltclimrelax, allowfreezing, periodicexternalforcing, globalfiles, pickupstrictlymatch, &
&usepickupbeforec54, startfrompickupab2, pickup_read_mdsio, pickup_write_mdsio, pickup_write_immed, writepickupatend, timeave_mdsio, snapshot_mdsio, &
&monitor_stdio, outputtypesinclusive, dumpinitandlast

logical, private :: useaim
logical, private :: useatm2d
logical, private :: useatm_phys
logical, private :: useautodiff
logical, private :: usebbl
logical, private :: usebulkforce
logical, private :: usecal
logical, private :: usecheapaml
logical, private :: usectrl
logical, private :: usediagnostics
logical, private :: usedown_slope
logical, private :: useebm
logical, private :: useecco
logical, private :: useembed_files
logical, private :: useexf
logical, private :: usefizhi
logical, private :: useflt
logical, private :: usefrazil
logical, private :: usegad
logical, private :: usegchem
logical, private :: useggl90
logical, private :: usegmredi
logical, private :: usegrdchk
logical, private :: usegridalt
logical, private :: useicefront
logical, private :: useihop
logical, private :: usekl10
logical, private :: usekpp
logical, private :: useland
logical, private :: uselayers
logical, private :: usematrix
logical, private :: usemnc
logical, private :: usemy82
logical, private :: usemypackage
logical, private :: useobcs
logical, private :: useoffline
logical, private :: useopps
logical, private :: usepp81
logical, private :: useprofiles
logical, private :: useptracers
logical, private :: userbcs
logical, private :: useregrid
logical, private :: userunclock
logical, private :: usesalt_plume
logical, private :: usesbo
logical, private :: useseaice
logical, private :: useshap_filt
logical, private :: useshelfice
logical, private :: usesmooth
logical, private :: usestic
logical, private :: usestreamice
logical, private :: usethsice
logical, private :: usezonal_filt
common /parm_packages/ usegad, useobcs, useshap_filt, usezonal_filt, useopps, usepp81, usekl10, usemy82, useggl90, usekpp, usegmredi, usebbl, &
&usedown_slope, usecal, useexf, usebulkforce, useebm, usecheapaml, usegrdchk, usesmooth, useprofiles, useecco, usectrl, usesbo, useflt, useautodiff, &
&useptracers, usegchem, userbcs, useoffline, usematrix, usefrazil, useseaice, usesalt_plume, useshelfice, usestic, usestreamice, useicefront, &
&usethsice, useland, useatm2d, useaim, useatm_phys, usefizhi, usegridalt, usediagnostics, useregrid, uselayers, usemnc, userunclock, useembed_files, &
&usemypackage, useihop

double precision, private :: abeps
double precision, private :: adjdumpfreq
double precision, private :: adjmonitorfreq
double precision, private :: affacmom
double precision, private :: alph_ab
double precision, private :: basetime
double precision, private :: beta
double precision, private :: beta_ab
double precision, private :: bl79latvary
double precision, private :: bottomdraglinear
double precision, private :: bottomdragquadratic
double precision, private :: cadjfreq
double precision, private :: cffacmom
double precision, private :: cg2dpcoffdfac
double precision, private :: cg2dtargetresidual
double precision, private :: cg2dtargetreswunit
double precision, private :: cg3dtargetresidual
double precision, private :: cg3dtargetreswunit
double precision, private :: chkptfreq
double precision, private :: convertfw2salt
double precision, private :: cospower
double precision, private :: dbdrref(nr)
double precision, private :: delr(nr)
double precision, private :: delrc(nr+1)
double precision, private :: deltat
double precision, private :: deltatclock
double precision, private :: deltatfreesurf
double precision, private :: deltatmom
double precision, private :: diagfreq
double precision, private :: diffk4s
double precision, private :: diffk4t
double precision, private :: diffkhs
double precision, private :: diffkht
double precision, private :: diffkr4s(nr)
double precision, private :: diffkr4t(nr)
double precision, private :: diffkrbl79deep
double precision, private :: diffkrbl79ho
double precision, private :: diffkrbl79scl
double precision, private :: diffkrbl79surf
double precision, private :: diffkrbleqdeep
double precision, private :: diffkrbleqho
double precision, private :: diffkrbleqscl
double precision, private :: diffkrbleqsurf
double precision, private :: diffkrnrs(nr)
double precision, private :: diffkrnrt(nr)
double precision, private :: drhosmall
double precision, private :: dttracerlev(nr)
double precision, private :: dumpfreq
double precision, private :: endtime
double precision, private :: epsab_cd
double precision, private :: externforcingcycle
double precision, private :: externforcingperiod
double precision, private :: f0
double precision, private :: fofacmom
double precision, private :: fprime
double precision, private :: freesurffac
double precision, private :: gbaro
double precision, private :: gravfacc(nr)
double precision, private :: gravfacf(nr+1)
double precision, private :: gravity
double precision, private :: hfacinf
double precision, private :: hfacmin
double precision, private :: hfacmindp
double precision, private :: hfacmindr
double precision, private :: hfacmindz
double precision, private :: hfacsup
double precision, private :: hmixcriteria
double precision, private :: hmixsmooth
double precision, private :: implicdiv2dflow
double precision, private :: implicitnhpress
double precision, private :: implicsurfpress
double precision, private :: ivdc_kappa
double precision, private :: latbandclimrelax
double precision, private :: mass2runit
double precision, private :: monitorfreq
double precision, private :: mtfacmom
double precision, private :: nh_am2
double precision, private :: omega
double precision, private :: pcellmix_delr
double precision, private :: pcellmix_diffkr(nr)
double precision, private :: pcellmix_maxfac
double precision, private :: pcellmix_viscar(nr)
double precision, private :: pchkptfreq
double precision, private :: pffacmom
double precision, private :: phieuler
double precision, private :: phiref(2*nr+1)
double precision, private :: pref4eos(nr)
double precision, private :: psieuler
double precision, private :: radius_fromhorizgrid
double precision, private :: rcd
double precision, private :: recip_gravfacc(nr)
double precision, private :: recip_gravfacf(nr+1)
double precision, private :: recip_gravity
double precision, private :: recip_rhoconst
double precision, private :: recip_rhofacc(nr)
double precision, private :: recip_rhofacf(nr+1)
double precision, private :: recip_rsphere
double precision, private :: rho1ref(nr)
double precision, private :: rhoconst
double precision, private :: rhoconstfresh
double precision, private :: rhofacc(nr)
double precision, private :: rhofacf(nr+1)
double precision, private :: rhonil
double precision, private :: rhoref(nr)
double precision, private :: rotationperiod
double precision, private :: rsigmabnd
double precision, private :: rsphere
double precision, private :: runit2mass
double precision, private :: runit2z(nr)
double precision, private :: rvel2wunit(nr+1)
double precision, private :: salt_addmass
double precision, private :: salt_evprrn
double precision, private :: sealev_z
double precision, private :: siceloadfac
double precision, private :: sidedragfactor
double precision, private :: smag3d_coeff
double precision, private :: smag3d_diffcoeff
double precision, private :: smoothabsfuncrange
double precision, private :: sref(nr)
double precision, private :: starttime
double precision, private :: surf_pref
double precision, private :: taucd
double precision, private :: tausaltclimrelax
double precision, private :: tauthetaclimrelax
double precision, private :: tave_lastiter
double precision, private :: tavefreq
double precision, private :: tcylin
double precision, private :: tcylout
double precision, private :: temp_addmass
double precision, private :: temp_evprrn
double precision, private :: thetaconst
double precision, private :: thetaeuler
double precision, private :: top_pres
double precision, private :: tref(nr)
double precision, private :: vffacmom
double precision, private :: visca4
double precision, private :: visca4d
double precision, private :: visca4grid
double precision, private :: visca4gridmax
double precision, private :: visca4gridmin
double precision, private :: visca4max
double precision, private :: visca4remax
double precision, private :: visca4w
double precision, private :: visca4z
double precision, private :: viscah
double precision, private :: viscahd
double precision, private :: viscahgrid
double precision, private :: viscahgridmax
double precision, private :: viscahgridmin
double precision, private :: viscahmax
double precision, private :: viscahremax
double precision, private :: viscahw
double precision, private :: viscahz
double precision, private :: viscarnr(nr)
double precision, private :: viscc2leith
double precision, private :: viscc2leithd
double precision, private :: viscc2leithqg
double precision, private :: viscc2smag
double precision, private :: viscc4leith
double precision, private :: viscc4leithd
double precision, private :: viscc4smag
double precision, private :: viscfacadj
double precision, private :: wunit2rvel(nr+1)
double precision, private :: xgorigin
double precision, private :: ygorigin
double precision, private :: z2runit(nr)
double precision, private :: zroughbot
common /parm_r/ cg2dtargetresidual, cg2dtargetreswunit, cg2dpcoffdfac, cg3dtargetresidual, cg3dtargetreswunit, delr, delrc, xgorigin, ygorigin, &
&rsphere, recip_rsphere, radius_fromhorizgrid, sealev_z, top_pres, rsigmabnd, deltat, deltatmom, dttracerlev, deltatfreesurf, deltatclock, abeps, &
&alph_ab, beta_ab, f0, beta, fprime, omega, rotationperiod, viscfacadj, viscah, viscahw, smag3d_coeff, smag3d_diffcoeff, viscahmax, viscahgrid, &
&viscahgridmax, viscahgridmin, viscc2leith, viscc2leithd, viscc2leithqg, viscc2smag, viscc4smag, viscahd, viscahz, visca4d, visca4z, visca4, visca4w,&
& visca4max, visca4grid, visca4gridmax, visca4gridmin, viscahremax, visca4remax, viscc4leith, viscc4leithd, viscarnr, diffkht, diffk4t, diffkrnrt, &
&diffkr4t, diffkhs, diffk4s, diffkrnrs, diffkr4s, diffkrbl79surf, diffkrbl79deep, diffkrbl79scl, diffkrbl79ho, bl79latvary, diffkrbleqsurf, &
&diffkrbleqdeep, diffkrbleqscl, diffkrbleqho, pcellmix_maxfac, pcellmix_delr, pcellmix_viscar, pcellmix_diffkr, taucd, rcd, epsab_cd, freesurffac, &
&implicsurfpress, implicdiv2dflow, implicitnhpress, hfacmin, hfacmindz, hfacinf, hfacsup, gravity, recip_gravity, gbaro, gravfacc, recip_gravfacc, &
&gravfacf, recip_gravfacf, rhonil, rhoconst, recip_rhoconst, rho1ref, rhofacc, recip_rhofacc, rhofacf, recip_rhofacf, rhoconstfresh, thetaconst, &
&tref, sref, rhoref, dbdrref, surf_pref, pref4eos, phiref, rvel2wunit, wunit2rvel, runit2z, z2runit, mass2runit, runit2mass, basetime, starttime, &
&endtime, chkptfreq, pchkptfreq, dumpfreq, adjdumpfreq, diagfreq, tavefreq, tave_lastiter, monitorfreq, adjmonitorfreq, affacmom, vffacmom, pffacmom,&
& cffacmom, fofacmom, mtfacmom, cospower, cadjfreq, tauthetaclimrelax, tausaltclimrelax, latbandclimrelax, externforcingcycle, externforcingperiod, &
&convertfw2salt, temp_evprrn, salt_evprrn, temp_addmass, salt_addmass, hfacmindr, hfacmindp, ivdc_kappa, hmixcriteria, drhosmall, hmixsmooth, &
&sidedragfactor, bottomdraglinear, bottomdragquadratic, zroughbot, nh_am2, smoothabsfuncrange, siceloadfac, tcylin, tcylout, phieuler, thetaeuler, &
&psieuler

!==============================================
! declare external procedures and functions
!==============================================
integer, external :: ilnblnk
private :: ilnblnk
external :: mpi_comm_dup_fn
private :: mpi_comm_dup_fn
external :: mpi_comm_null_copy_fn
private :: mpi_comm_null_copy_fn
external :: mpi_comm_null_delete_fn
private :: mpi_comm_null_delete_fn
external :: mpi_conversion_fn_null
private :: mpi_conversion_fn_null
external :: mpi_dup_fn
private :: mpi_dup_fn
external :: mpi_null_copy_fn
private :: mpi_null_copy_fn
external :: mpi_null_delete_fn
private :: mpi_null_delete_fn
external :: mpi_type_dup_fn
private :: mpi_type_dup_fn
external :: mpi_type_null_copy_fn
private :: mpi_type_null_copy_fn
external :: mpi_type_null_delete_fn
private :: mpi_type_null_delete_fn
external :: mpi_win_dup_fn
private :: mpi_win_dup_fn
external :: mpi_win_null_copy_fn
private :: mpi_win_null_copy_fn
external :: mpi_win_null_delete_fn
private :: mpi_win_null_delete_fn
double precision, external :: mpi_wtick
private :: mpi_wtick
double precision, external :: mpi_wtime
private :: mpi_wtime
double precision, external :: pmpi_wtick
private :: pmpi_wtick
double precision, external :: pmpi_wtime
private :: pmpi_wtime

contains
  subroutine distances2d( rayx, topx, botx, dtop, dbot, topn, botn, disttop, distbot )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: botn(2)
  real(kind=8), intent(in) :: botx(2)
  real(kind=8), intent(out) :: dbot(2)
  real(kind=8), intent(out) :: distbot
  real(kind=8), intent(out) :: disttop
  real(kind=8), intent(out) :: dtop(2)
  real(kind=8), intent(in) :: rayx(2)
  real(kind=8), intent(in) :: topn(2)
  real(kind=8), intent(in) :: topx(2)

  dtop = rayx-topx
  dbot = rayx-botx
  disttop = -dot_product(topn,dtop)
  distbot = -dot_product(botn,dbot)
  end subroutine distances2d
  subroutine distances2d_tl( rayx, rayx_tl, topx, botx, dtop, dtop_tl, dbot, dbot_tl, topn, botn, disttop, disttop_tl, distbot, distbot_tl )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: botn(2)
  real(kind=8), intent(in) :: botx(2)
  real(kind=8), intent(inout) :: dbot(2)
  real(kind=8), intent(inout) :: dbot_tl(2)
  real(kind=8), intent(out) :: distbot
  real(kind=8), intent(out) :: distbot_tl
  real(kind=8), intent(out) :: disttop
  real(kind=8), intent(out) :: disttop_tl
  real(kind=8), intent(inout) :: dtop(2)
  real(kind=8), intent(inout) :: dtop_tl(2)
  real(kind=8), intent(in) :: rayx(2)
  real(kind=8), intent(in) :: rayx_tl(2)
  real(kind=8), intent(in) :: topn(2)
  real(kind=8), intent(in) :: topx(2)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  dtop_tl = rayx_tl
  dtop = rayx-topx
  dbot_tl = rayx_tl
  dbot = rayx-botx
  disttop_tl = -dot_product(topn,dtop_tl)
  disttop = -dot_product(topn,dtop)
  distbot_tl = -dot_product(botn,dbot_tl)
  distbot = -dot_product(botn,dbot)

  end subroutine distances2d_tl
  subroutine ihop_main( mytime, myiter, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_init_diag, only : initprtfile,openoutputfiles,resetmemory
  use bdry_mod, only : bdry,writebdry
  use ssp_mod, only : setssp
  use refcoef, only : writerefcoef
  use beampat, only : writepat
  use ihop_mod, only : beam,ray2d
  use ihop_mod, only : bcastray
  use arr_mod, only : bcastarr

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: myiter
  integer, intent(in) :: mythid
  double precision, intent(in) :: mytime

!==============================================
! declare local variables
!==============================================
  integer :: mpirc
  character(len=max_len_mbuf) :: msgbuf
  real :: tstart
  real :: tstop

  mpirc = 0
  tstart = 0.
  tstop = 0.
  call resetmemory
  if (myprocid == 0 .and. ihop_dumpfreq >= 0) then
    call initprtfile( mytime,myiter,mythid )
    call writebdry( mythid )
    call writerefcoef( mythid )
    call writepat( mythid )
    call openoutputfiles( ihop_fileroot,mytime,myiter,mythid )
  endif
  call setssp( mythid )
  if (myprocid == 0) then
    call cpu_time( tstart )
    call ihopcore( mythid )
    call cpu_time( tstop )
  endif
  if (usingmpi) then
    call mpi_barrier( mpi_comm_world,mpirc )
    call bcastray( 0,mpi_comm_world )
    call bcastarr( 0,mpi_comm_world )
  endif
  if (myprocid == 0 .and. ihop_dumpfreq >= 0) then
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A,G15.3,A)') 'CPU Time = ',tstop-tstart,'s'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    close(unit=prtfile)
    select case ( beam%runtype(1:1) )
    case ('C','S','I')
      close(unit=shdfile)
    case ('A','a')
      close(unit=arrfile)
    case ('R','E')
      close(unit=rayfile)
      if (writedelay) then
        close(unit=delfile)
      endif
    case ('e')
      close(unit=rayfile)
      close(unit=arrfile)
      if (writedelay) then
        close(unit=delfile)
      endif
    case default
      stop 'ABNORMAL END: S/R IHOP_MAIN'
    end select
  endif
  end subroutine ihop_main
  subroutine ihop_main_tl( mytime, myiter, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_init_diag, only : initprtfile,openoutputfiles,resetmemory,resetmemory_tl
  use bdry_mod, only : bdry,writebdry
  use ssp_mod, only : setssp,setssp_tl
  use refcoef, only : writerefcoef
  use beampat, only : writepat
  use ihop_mod, only : bcastray_tl,beam,ray2d
  use ihop_mod, only : ray2d_tl
  use ihop_mod, only : bcastray
  use arr_mod, only : bcastarr,bcastarr_tl

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: myiter
  integer, intent(in) :: mythid
  double precision, intent(in) :: mytime

!==============================================
! declare local variables
!==============================================
  integer :: mpirc
  character(len=max_len_mbuf) :: msgbuf
  real :: tstart
  real :: tstop

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  mpirc = 0
  tstart = 0.
  tstop = 0.
  call resetmemory_tl
  if (myprocid == 0 .and. ihop_dumpfreq >= 0) then
    call initprtfile( mytime,myiter,mythid )
    call writebdry( mythid )
    call writerefcoef( mythid )
    call writepat( mythid )
    call openoutputfiles( ihop_fileroot,mytime,myiter,mythid )
  endif
  call setssp_tl( mythid )
  if (myprocid == 0) then
    call cpu_time( tstart )
    call ihopcore_tl( mythid )
    call cpu_time( tstop )
  endif
  if (usingmpi) then
    call mpi_barrier( mpi_comm_world,mpirc )
    call bcastray_tl( 0,mpi_comm_world )
    call bcastarr_tl( 0,mpi_comm_world )
  endif
  if (myprocid == 0 .and. ihop_dumpfreq >= 0) then
    write(unit=msgbuf,fmt='(A)')
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    write(unit=msgbuf,fmt='(A,G15.3,A)') 'CPU Time = ',tstop-tstart,'s'
    call print_message( msgbuf,prtfile,squeeze_right,mythid )
    close(unit=prtfile)
    select case ( beam%runtype(1:1) )
    case ('C','S','I')
      close(unit=shdfile)
    case ('A','a')
      close(unit=arrfile)
    case ('R','E')
      close(unit=rayfile)
      if (writedelay) then
        close(unit=delfile)
      endif
    case ('e')
      close(unit=rayfile)
      close(unit=arrfile)
      if (writedelay) then
        close(unit=delfile)
      endif
    case default
      stop 'ABNORMAL END: S/R IHOP_MAIN'
    end select
  endif

  end subroutine ihop_main_tl
  subroutine ihopcore( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ssp_mod, only : evalssp,isegr
  use angle_mod, only : angles,ialpha
  use srpos_mod, only : pos
  use arr_mod, only : u,writearrivalsascii,writearrivalsbinary
  use writeray, only : writerayoutput
  use influence, only : calculateinfluence,scalepressure
  use beampat, only : nsbppts,srcbmpat
  use ihop_mod, only : afreq,beam,delfile,nmax,nrz_per_range,rad2deg,ray2d,rayfile,srcdeclangle

  implicit none

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp0
  real(kind=8) :: c
  real(kind=8) :: cimag
  real(kind=8) :: crr
  real(kind=8) :: crz
  real(kind=8) :: czz
  real(kind=8) :: dalphaopt
  real(kind=8) :: gradc(2)
  integer :: ibp
  integer :: ibpvec(1)
  integer :: ih
  integer :: irec
  integer :: irz1
  character(len=max_len_mbuf) :: msgbuf
  integer :: nalphaopt
  integer :: nsteps
  real(kind=8) :: radmax
  real(kind=8) :: rho
  real(kind=8) :: s
  real(kind=8) :: tmpdelay(nmax)
  real(kind=8) :: tmpraytaur(angles%nalpha)
  real(kind=8) :: xs(2)

  afreq = 2.0*pi*ihop_freq
  sourcedepth: do ih = 1, pos%nsz
    xs = [ zerorl,pos%sz(ih) ]
    u = 0.0
    call evalssp( xs,c,cimag,gradc,crr,crz,czz,rho,mythid )
    radmax = 5*c/ihop_freq
    if (beam%runtype(1:1) == 'C') then
      dalphaopt = sqrt(c/(6.0*ihop_freq*pos%rr(pos%nrr)))
      nalphaopt = 2+int((angles%arad(angles%nalpha)-angles%arad(1))/dalphaopt)
      if (angles%nalpha < nalphaopt) then
        write(unit=msgbuf,fmt='(A,/,A,I10.4)') 'WARNING: Too few beams','nAlpha should be at least = ',nalphaopt
        if (ihop_dumpfreq >= 0) then
          call print_message( msgbuf,prtfile,squeeze_right,mythid )
        endif
      endif
    endif
    declinationangle: do ialpha = 1, angles%nalpha
      srcdeclangle = angles%adeg(ialpha)
      if (angles%isingle_alpha == 0 .or. ialpha == angles%isingle_alpha) then
        ibpvec = maxloc(srcbmpat(:,1),mask=srcbmpat(:,1) < srcdeclangle)
        ibp = ibpvec(1)
        ibp = max(ibp,1)
        ibp = min(ibp,nsbppts-1)
        s = (srcdeclangle-srcbmpat(ibp,1))/(srcbmpat(ibp+1,1)-srcbmpat(ibp,1))
        amp0 = (1-s)*srcbmpat(ibp,2)+s*srcbmpat(ibp+1,2)
        if (beam%runtype(1:1) == 'S') then
          amp0 = amp0*sqrt(2.0)*abs(sin(afreq/c*xs(2)*sin(angles%arad(ialpha))))
        endif
        if (mod(ialpha-1,max(angles%nalpha/50,1)) == 0) then
          write(unit=msgbuf,fmt='(A,I7,F10.2)') 'Tracing ray ',ialpha,srcdeclangle
          if (ihop_dumpfreq >= 0) then
            call print_message( msgbuf,prtfile,squeeze_right,mythid )
            flush(unit=prtfile)
          endif
        endif
        call traceray2d( xs,angles%arad(ialpha),amp0,mythid )
        if (beam%runtype(1:1) == 'R') then
          nsteps = beam%nsteps
          call writerayoutput( rayfile,nsteps,ray2d(1:nsteps)%x(1),ray2d(1:nsteps)%x(2),ray2d(nsteps)%ntopbnc,ray2d(nsteps)%nbotbnc )
          if (writedelay) then
            tmpdelay = real(ray2d(1:nsteps)%tau)
            call writerayoutput( delfile,nsteps,tmpdelay,ray2d(1:nsteps)%x(2),ray2d(nsteps)%ntopbnc,ray2d(nsteps)%nbotbnc )
          endif
        else
          call calculateinfluence( mythid )
        endif
      endif
      tmpraytaur(ialpha) = ray2d(beam%nsteps)%q(1)
    end do declinationangle
    select case ( beam%runtype(1:1) )
    case ('C','S','I')
      call scalepressure( ray2d(1)%c,pos%rr,u,nrz_per_range,pos%nrr )
      irec = 10+nrz_per_range*(ih-1)
      rcvrdepth: do irz1 = 1, nrz_per_range
        irec = irec+1
        write(unit=shdfile,rec=irec) u(irz1,1:pos%nrr)
      end do rcvrdepth
    case ('A','e')
      call writearrivalsascii( pos%rr,nrz_per_range,pos%nrr,beam%runtype(4:4) )
    case ('a')
      call writearrivalsbinary( pos%rr,nrz_per_range,pos%nrr,beam%runtype(4:4) )
    end select
  end do sourcedepth
  end subroutine ihopcore
  subroutine ihopcore_tl( mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ssp_mod, only : evalssp,evalssp_tl,isegr
  use angle_mod, only : angles,ialpha
  use srpos_mod, only : pos
  use arr_mod, only : u,writearrivalsascii,writearrivalsbinary
  use writeray, only : writerayoutput
  use influence, only : calculateinfluence,calculateinfluence_tl,scalepressure,scalepressure_tl
  use beampat, only : nsbppts,srcbmpat
  use ihop_mod, only : afreq,beam,delfile,nmax,nrz_per_range,rad2deg,ray2d,rayfile,srcdeclangle
  use ihop_mod, only : ray2d_tl

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8
  integer, parameter :: ikind7 = 8
  integer, parameter :: ikind8 = 8

!==============================================
! declare arguments
!==============================================
  integer, intent(in) :: mythid

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: amp0
  real(kind=8) :: amp0_tl
  real(kind=8) :: amp0h
  real(kind=8) :: amp0i
  real(kind=8) :: amp0j
  real(kind=8) :: c
  real(kind=8) :: c_tl
  real(kind=8) :: cimag
  real(kind=8) :: cimagh_tl
  real(kind=8) :: crr
  real(kind=8) :: crrh_tl
  real(kind=8) :: crz
  real(kind=8) :: crzh_tl
  real(kind=8) :: czz
  real(kind=8) :: czzh_tl
  real(kind=8) :: dalphaopt
  real(kind=8) :: gradc(2)
  real(kind=8) :: gradch_tl(2)
  integer :: ibp
  integer :: ibpvec(1)
  integer :: ih
  integer :: irec
  integer :: irz1
  character(len=max_len_mbuf) :: msgbuf
  integer :: nalphaopt
  integer :: nsteps
  real(kind=8) :: radmax
  real(kind=8) :: rho
  real(kind=8) :: rhoh_tl
  real(kind=8) :: s
  real(kind=8) :: tmpdelay(nmax)
  real(kind=8) :: tmpraytaur(angles%nalpha)
  real(kind=8) :: xs(2)
  real(kind=8) :: xsh_tl(2)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  afreq = 2.0*pi*ihop_freq
  sourcedepth1: do ih = 1, pos%nsz
    xs = [ zerorl,pos%sz(ih) ]
    u = 0.0
    xsh_tl = 0._ikind2
    cimagh_tl = 0._ikind3
    gradch_tl = 0._ikind4
    crrh_tl = 0._ikind5
    crzh_tl = 0._ikind6
    czzh_tl = 0._ikind7
    rhoh_tl = 0._ikind8
    call evalssp_tl( xs,xsh_tl,c,c_tl,cimag,cimagh_tl,gradc,gradch_tl,crr,crrh_tl,crz,crzh_tl,czz,czzh_tl,rho,rhoh_tl,mythid )
    radmax = 5*c/ihop_freq
    if (beam%runtype(1:1) == 'C') then
      dalphaopt = sqrt(c/(6.0*ihop_freq*pos%rr(pos%nrr)))
      nalphaopt = 2+int((angles%arad(angles%nalpha)-angles%arad(1))/dalphaopt)
      if (angles%nalpha < nalphaopt) then
        write(unit=msgbuf,fmt='(A,/,A,I10.4)') 'WARNING: Too few beams','nAlpha should be at least = ',nalphaopt
        if (ihop_dumpfreq >= 0) then
          call print_message( msgbuf,prtfile,squeeze_right,mythid )
        endif
      endif
    endif
    declinationangle1: do ialpha = 1, angles%nalpha
      srcdeclangle = angles%adeg(ialpha)
      if (angles%isingle_alpha == 0 .or. ialpha == angles%isingle_alpha) then
        ibpvec = maxloc(srcbmpat(:,1),mask=srcbmpat(:,1) < srcdeclangle)
        ibp = ibpvec(1)
        ibp = max(ibp,1)
        ibp = min(ibp,nsbppts-1)
        s = (srcdeclangle-srcbmpat(ibp,1))/(srcbmpat(ibp+1,1)-srcbmpat(ibp,1))
        amp0_tl = 0._ikind1
        amp0 = (1-s)*srcbmpat(ibp,2)+s*srcbmpat(ibp+1,2)
        if (beam%runtype(1:1) == 'S') then
          amp0h = afreq/c*xs(2)*sin(angles%arad(ialpha))
          amp0i = sin(amp0h)
          amp0j = abs(amp0i)
          amp0_tl = (amp0_tl*amp0j-c_tl*(afreq/c/c)*xs(2)*amp0*sin(angles%arad(ialpha))*cos(amp0h)*sign(1._8,amp0i))*sqrt(2.0)
          amp0 = amp0*sqrt(2.0)*amp0j
        endif
        if (mod(ialpha-1,max(angles%nalpha/50,1)) == 0) then
          write(unit=msgbuf,fmt='(A,I7,F10.2)') 'Tracing ray ',ialpha,srcdeclangle
          if (ihop_dumpfreq >= 0) then
            call print_message( msgbuf,prtfile,squeeze_right,mythid )
          endif
        endif
        call traceray2d_tl( xs,angles%arad(ialpha),amp0,amp0_tl,mythid )
        if (beam%runtype(1:1) == 'R') then
          nsteps = beam%nsteps
          call writerayoutput( rayfile,nsteps,ray2d(1:nsteps)%x(1),ray2d(1:nsteps)%x(2),ray2d(nsteps)%ntopbnc,ray2d(nsteps)%nbotbnc )
          if (writedelay) then
            tmpdelay = real(ray2d(1:nsteps)%tau)
            call writerayoutput( delfile,nsteps,tmpdelay,ray2d(1:nsteps)%x(2),ray2d(nsteps)%ntopbnc,ray2d(nsteps)%nbotbnc )
          endif
        else
          call calculateinfluence_tl( mythid )
        endif
      endif
      tmpraytaur(ialpha) = ray2d(beam%nsteps)%q(1)
    end do declinationangle1
    select case ( beam%runtype(1:1) )
    case ('C','S','I')
      call scalepressure_tl( ray2d(1)%c,pos%rr,u,nrz_per_range,pos%nrr )
      irec = 10+nrz_per_range*(ih-1)
      rcvrdepth1: do irz1 = 1, nrz_per_range
        irec = irec+1
        write(unit=shdfile,rec=irec) u(irz1,1:pos%nrr)
      end do rcvrdepth1
    case ('A','e')
      call writearrivalsascii( pos%rr,nrz_per_range,pos%nrr,beam%runtype(4:4) )
    case ('a')
      call writearrivalsbinary( pos%rr,nrz_per_range,pos%nrr,beam%runtype(4:4) )
    end select
  end do sourcedepth1

  end subroutine ihopcore_tl
  subroutine reflect2d( ih, hs, bottop, tbdry, nbdry, kappa, refc, npts, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ssp_mod, only : evalssp
  use bdry_mod, only : hsinfo
  use refcoef, only : interpolatereflectioncoefficient,reflectioncoef
  use ihop_mod, only : afreq,beam,rad2deg,ray2d

  implicit none

!==============================================
! declare arguments
!==============================================
  character(len=3), intent(in) :: bottop
  type(hsinfo), intent(in) :: hs
  integer, intent(inout) :: ih
  real(kind=8), intent(in) :: kappa
  integer, intent(in) :: mythid
  real(kind=8), intent(in) :: nbdry(2)
  integer, intent(in) :: npts
  type(reflectioncoef), intent(in) :: refc(npts)
  real(kind=8), intent(in) :: tbdry(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: a
  complex(kind=8) :: b
  real(kind=8) :: c
  real(kind=8) :: cco
  complex(kind=8) :: ch
  real(kind=8) :: cimag
  real(kind=8) :: ck
  real(kind=8) :: cnjump
  real(kind=8) :: co
  real(kind=8) :: crr
  real(kind=8) :: crz
  real(kind=8) :: csjump
  real(kind=8) :: czz
  complex(kind=8) :: d
  complex(kind=8) :: ddelta
  complex(kind=8) :: delta
  complex(kind=8) :: f
  complex(kind=8) :: g
  real(kind=8) :: gradc(2)
  integer :: ih1
  complex(kind=8) :: kx
  complex(kind=8) :: kz
  complex(kind=8) :: kzp
  complex(kind=8) :: kzp2
  complex(kind=8) :: kzs
  complex(kind=8) :: kzs2
  character(len=max_len_mbuf) :: msgbuf
  complex(kind=8) :: mu
  real(kind=8) :: pdelta
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayn_tilde(2)
  real(kind=8) :: rayt(2)
  real(kind=8) :: rayt_tilde(2)
  real(kind=8) :: rddelta
  complex(kind=8) :: refl
  real(kind=8) :: rho
  real(kind=8) :: rm
  real(kind=8) :: rn
  complex(kind=8) :: sb
  real(kind=8) :: sddelta
  real(kind=8) :: si
  real(kind=8) :: ssi
  real(kind=8) :: tg
  real(kind=8) :: th
  real(kind=8) :: theta_bot
  complex(kind=8) :: y2
  complex(kind=8) :: y4

!==============================================
! declare derived type variables
!==============================================
  type(reflectioncoef) :: rint

  rint%r = 0.0
  rint%phi = 0.0
  rint%theta = -999.
  ih = ih+1
  ih1 = ih+1
  tg = dot_product(ray2d(ih)%t,tbdry)
  th = dot_product(ray2d(ih)%t,nbdry)
  ray2d(ih1)%ntopbnc = ray2d(ih)%ntopbnc
  ray2d(ih1)%nbotbnc = ray2d(ih)%nbotbnc
  ray2d(ih1)%x = ray2d(ih)%x
  ray2d(ih1)%t = ray2d(ih)%t-2.0*th*nbdry
  call evalssp( ray2d(ih)%x,c,cimag,gradc,crr,crz,czz,rho,mythid )
  rayt = c*ray2d(ih)%t
  rayn = [ -rayt(2),rayt(1) ]
  rayt_tilde = c*ray2d(ih1)%t
  rayn_tilde = -[ -rayt_tilde(2),rayt_tilde(1) ]
  cnjump = -dot_product(gradc,rayn_tilde-rayn)
  csjump = -dot_product(gradc,rayt_tilde-rayt)
  rn = 2*kappa/c**2/th
  if (bottop == 'TOP') then
    cnjump = -cnjump
    rn = -rn
  endif
  rm = tg/th
  rn = rn+rm*(2*cnjump-rm*csjump)/c**2
  select case ( beam%type(3:3) )
  case ('D')
    rn = 2.0*rn
  case ('Z')
    rn = 0.0
  case default
    rn = rn
  end select
  ray2d(ih1)%c = c
  ray2d(ih1)%tau = ray2d(ih)%tau
  ray2d(ih1)%p = ray2d(ih)%p+ray2d(ih)%q*rn
  ray2d(ih1)%q = ray2d(ih)%q
  select case ( hs%bc )
  case ('R')
    ray2d(ih1)%amp = ray2d(ih)%amp
    ray2d(ih1)%phase = ray2d(ih)%phase
  case ('V')
    ray2d(ih1)%amp = ray2d(ih)%amp
    ray2d(ih1)%phase = ray2d(ih)%phase+pi
  case ('F')
    if (th == 0.0 .and. tg == 0.0) then
      rint%theta = 0.0
    else
      rint%theta = rad2deg*abs(atan2(th,tg))
    endif
    if (rint%theta > 90.) then
      rint%theta = 180.-rint%theta
    endif
    call interpolatereflectioncoefficient( rint,refc,npts )
    ray2d(ih1)%amp = ray2d(ih)%amp*rint%r
    ray2d(ih1)%phase = ray2d(ih)%phase+rint%phi
  case ('A','G')
    kx = afreq*tg
    kz = afreq*th
    if (real(hs%cs) > 0.) then
      kzs2 = kx**2-(afreq/hs%cs)**2
      kzp2 = kx**2-(afreq/hs%cp)**2
      kzs = sqrt(kzs2)
      kzp = sqrt(kzp2)
      mu = hs%rho*hs%cs**2
      y2 = ((kzs2+kx**2)**2-4.0d0*kzs*kzp*kx**2)*mu
      y4 = kzp*(kx**2-kzs2)
      f = afreq**2*y4
      g = y2
    else
      kzp = sqrt(kx**2-(afreq/hs%cp)**2)
      if (real(kzp) == 0. .and. aimag(kzp) < 0.) then
        kzp = -kzp
      endif
      f = kzp
      g = hs%rho
    endif
    refl = -((rho*f-onecmplx*kz*g)/(rho*f+onecmplx*kz*g))
    if (abs(refl) < 1.0e-5) then
      ray2d(ih1)%amp = 0.0
      ray2d(ih1)%phase = ray2d(ih)%phase
    else
      ray2d(ih1)%amp = abs(refl)*ray2d(ih)%amp
      ray2d(ih1)%phase = ray2d(ih)%phase+atan2(aimag(refl),real(refl))
      if (beam%type(4:4) == 'S') then
        ch = ray2d(ih)%c/conjg(hs%cp)
        co = ray2d(ih)%t(1)*ray2d(ih)%c
        si = ray2d(ih)%t(2)*ray2d(ih)%c
        ck = afreq/ray2d(ih)%c
        a = 2*hs%rho*(1-ch*ch)
        b = co*co-ch*ch
        d = hs%rho*hs%rho*si*si+b
        sb = sqrt(b)
        cco = co*co
        ssi = si*si
        if (si /= 0.) then
          delta = a*co/si/(ck*sb*d)
        else
          delta = 0.0
        endif
        pdelta = real(delta)/(ray2d(ih)%c/co)
        ddelta = (-(a/(ck*sb*d)))-a*cco/ssi/(ck*sb*d)+a*cco/(ck*b*sb*d)-a*co/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si)
        rddelta = -real(ddelta)
        sddelta = rddelta/abs(rddelta)
        theta_bot = datan(tbdry(2)/tbdry(1))
        ray2d(ih1)%x(1) = ray2d(ih1)%x(1)+real(delta)*dcos(theta_bot)
        ray2d(ih1)%x(2) = ray2d(ih1)%x(2)+real(delta)*dsin(theta_bot)
        ray2d(ih1)%tau = ray2d(ih1)%tau+pdelta
        ray2d(ih1)%q = ray2d(ih1)%q+sddelta*rddelta*si*c*ray2d(ih)%p
      endif
    endif
  case default
    write(unit=msgbuf,fmt='(2A)') 'HS%BC = ',hs%bc
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    write(unit=msgbuf,fmt='(A)') 'IHOP Reflect2D: Unknown boundary condition type'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Reflect2D'
  end select
  if (bottop == 'TOP') then
    ray2d(ih+1)%ntopbnc = ray2d(ih)%ntopbnc+1
  else if (bottop == 'BOT') then
    ray2d(ih+1)%nbotbnc = ray2d(ih)%nbotbnc+1
  else
    write(unit=msgbuf,fmt='(2A)') 'IHOP Reflect2D: ','no reflection bounce, but in reflect2d somehow'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Reflect2D'
  endif
  end subroutine reflect2d
  subroutine reflect2d_tl( ih, hs, bottop, tbdry, tbdry_tl, nbdry, nbdry_tl, kappa, refc, refc_tl, npts, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ssp_mod, only : evalssp,evalssp_tl
  use bdry_mod, only : hsinfo
  use refcoef, only : interpolatereflectioncoefficient,interpolatereflectioncoefficient_tl,reflectioncoef
  use refcoef, only : reflectioncoef_tl
  use ihop_mod, only : afreq,beam,rad2deg,ray2d
  use ihop_mod, only : ray2d_tl

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8
  integer, parameter :: ikinef = 8
  integer, parameter :: ikineg = 8
  integer, parameter :: ikineh = 8
  integer, parameter :: ikinei = 8
  integer, parameter :: ikinej = 8
  integer, parameter :: ikinek = 8
  integer, parameter :: ikinel = 8

!==============================================
! declare arguments
!==============================================
  character(len=3), intent(in) :: bottop
  type(hsinfo), intent(in) :: hs
  integer, intent(inout) :: ih
  real(kind=8), intent(in) :: kappa
  integer, intent(in) :: mythid
  real(kind=8), intent(in) :: nbdry(2)
  real(kind=8), intent(in) :: nbdry_tl(2)
  integer, intent(in) :: npts
  type(reflectioncoef), intent(in) :: refc(npts)
  type(reflectioncoef_tl), intent(in) :: refc_tl(npts)
  real(kind=8), intent(in) :: tbdry(2)
  real(kind=8), intent(in) :: tbdry_tl(2)

!==============================================
! declare local variables
!==============================================
  complex(kind=8) :: a
  complex(kind=8) :: a_tl
  complex(kind=8) :: b
  complex(kind=8) :: b_tl
  real(kind=8) :: c
  real(kind=8) :: c_tl
  real(kind=8) :: cco
  real(kind=8) :: cco_tl
  complex(kind=8) :: ch
  complex(kind=8) :: ch_tl
  real(kind=8) :: cimag
  real(kind=8) :: cimagh_tl
  real(kind=8) :: ck
  real(kind=8) :: ck_tl
  real(kind=8) :: cnjump
  real(kind=8) :: cnjump_tl
  real(kind=8) :: co
  real(kind=8) :: co_tl
  real(kind=8) :: crr
  real(kind=8) :: crrh_tl
  real(kind=8) :: crz
  real(kind=8) :: crzh_tl
  real(kind=8) :: csjump
  real(kind=8) :: csjump_tl
  real(kind=8) :: czz
  real(kind=8) :: czzh_tl
  complex(kind=8) :: d
  complex(kind=8) :: d_tl
  complex(kind=8) :: ddelta
  complex(kind=8) :: ddelta_tl
  complex(kind=8) :: delta
  complex(kind=8) :: delta_tl
  complex(kind=8) :: f
  complex(kind=8) :: f_tl
  complex(kind=8) :: g
  complex(kind=8) :: g_tl
  real(kind=8) :: gradc(2)
  real(kind=8) :: gradc_tl(2)
  integer :: ih1
  complex(kind=8) :: kx
  complex(kind=8) :: kx_tl
  complex(kind=8) :: kz
  complex(kind=8) :: kz_tl
  complex(kind=8) :: kzp
  complex(kind=8) :: kzp2
  complex(kind=8) :: kzp2_tl
  complex(kind=8) :: kzp_tl
  complex(kind=8) :: kzs
  complex(kind=8) :: kzs2
  complex(kind=8) :: kzs2_tl
  complex(kind=8) :: kzs_tl
  character(len=max_len_mbuf) :: msgbuf
  complex(kind=8) :: mu
  real(kind=8) :: pdelta
  real(kind=8) :: pdelta_tl
  real :: pdeltah
  real :: ray2dh
  real :: ray2di
  real :: ray2dj
  real :: ray2dk
  real(kind=8) :: ray2dl
  real(kind=8) :: rayn(2)
  real(kind=8) :: rayn_tilde(2)
  real(kind=8) :: rayn_tilde_tl(2)
  real(kind=8) :: rayn_tl(2)
  real(kind=8) :: rayt(2)
  real(kind=8) :: rayt_tilde(2)
  real(kind=8) :: rayt_tilde_tl(2)
  real(kind=8) :: rayt_tl(2)
  real(kind=8) :: rddelta
  real(kind=8) :: rddelta_tl
  complex(kind=8) :: refl
  complex(kind=8) :: refl_tl
  real(kind=8) :: rho
  real(kind=8) :: rho_tl
  real(kind=8) :: rm
  real(kind=8) :: rm_tl
  real(kind=8) :: rn
  real(kind=8) :: rn_tl
  complex(kind=8) :: sb
  complex(kind=8) :: sb_tl
  real(kind=8) :: sddelta
  real(kind=8) :: sddelta_tl
  real(kind=8) :: sddeltah
  real(kind=8) :: si
  real(kind=8) :: si_tl
  real(kind=8) :: ssi
  real(kind=8) :: ssi_tl
  real(kind=8) :: tg
  real(kind=8) :: tg_tl
  real(kind=8) :: th
  real(kind=8) :: th_tl
  real(kind=8) :: theta_bot
  real(kind=8) :: theta_bot_tl
  complex(kind=8) :: y2
  complex(kind=8) :: y2_tl
  complex(kind=8) :: y4
  complex(kind=8) :: y4_tl

!==============================================
! declare derived type variables
!==============================================
  type(reflectioncoef) :: rint
  type(reflectioncoef_tl) :: rint_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  rint_tl%r_tl = 0._ikinel
  rint%r = 0.0
  rint_tl%phi_tl = 0._ikinek
  rint%phi = 0.0
  rint_tl%theta_tl = 0._ikinej
  rint%theta = -999.
  ih = ih+1
  ih1 = ih+1
  tg_tl = dot_product(ray2d_tl(ih)%t_tl,tbdry)+dot_product(ray2d(ih)%t,tbdry_tl)
  tg = dot_product(ray2d(ih)%t,tbdry)
  th_tl = dot_product(ray2d(ih)%t,nbdry_tl)+dot_product(ray2d_tl(ih)%t_tl,nbdry)
  th = dot_product(ray2d(ih)%t,nbdry)
  ray2d(ih1)%ntopbnc = ray2d(ih)%ntopbnc
  ray2d(ih1)%nbotbnc = ray2d(ih)%nbotbnc
  ray2d_tl(ih1)%x_tl = ray2d_tl(ih)%x_tl
  ray2d(ih1)%x = ray2d(ih)%x
  ray2d_tl(ih1)%t_tl = (-(2*nbdry_tl*th))+ray2d_tl(ih)%t_tl-2*th_tl*nbdry
  ray2d(ih1)%t = ray2d(ih)%t-2.0*th*nbdry
  cimagh_tl = 0._ikinef
  crrh_tl = 0._ikineg
  crzh_tl = 0._ikineh
  czzh_tl = 0._ikinei
  call evalssp_tl( ray2d(ih)%x,ray2d_tl(ih)%x_tl,c,c_tl,cimag,cimagh_tl,gradc,gradc_tl,crr,crrh_tl,crz,crzh_tl,czz,czzh_tl,rho,rho_tl,mythid )
  rayt_tl = c_tl*ray2d(ih)%t+ray2d_tl(ih)%t_tl*c
  rayt = c*ray2d(ih)%t
  rayn_tl = [ -rayt_tl(2),rayt_tl(1) ]
  rayn = [ -rayt(2),rayt(1) ]
  rayt_tilde_tl = c_tl*ray2d(ih1)%t+ray2d_tl(ih1)%t_tl*c
  rayt_tilde = c*ray2d(ih1)%t
  rayn_tilde_tl = [ real(kind=8) :: rayt_tilde_tl(2),-rayt_tilde_tl(1) ]
  rayn_tilde = [ real(kind=8) :: rayt_tilde(2),-rayt_tilde(1) ]
  cnjump_tl = -(dot_product(gradc_tl,rayn_tilde-rayn)+dot_product(gradc,-rayn_tl)+dot_product(gradc,rayn_tilde_tl))
  cnjump = -dot_product(gradc,rayn_tilde-rayn)
  csjump_tl = -(dot_product(gradc_tl,rayt_tilde-rayt)+dot_product(gradc,-rayt_tl)+dot_product(gradc,rayt_tilde_tl))
  csjump = -dot_product(gradc,rayt_tilde-rayt)
  rn_tl = (-(c_tl*(4*kappa*c/c**2/c**2/th)))-th_tl*(2*kappa/c**2/th/th)
  rn = 2*kappa/c**2/th
  if (bottop == 'TOP') then
    cnjump_tl = -cnjump_tl
    cnjump = -cnjump
    rn_tl = -rn_tl
    rn = -rn
  endif
  rm_tl = tg_tl/th-th_tl*(tg/th/th)
  rm = tg/th
  rn_tl = (-(c_tl*(2*(rm*(2*cnjump-rm*csjump))*c/c**2/c**2)))+cnjump_tl*(2*rm/c**2)-csjump_tl*(rm*rm/c**2)+rm_tl*(((-(rm*csjump))+(2*cnjump-rm*&
&csjump))/c**2)+rn_tl
  rn = rn+rm*(2*cnjump-rm*csjump)/c**2
  select case ( beam%type(3:3) )
  case ('D')
    rn_tl = 2*rn_tl
    rn = 2.0*rn
  case ('Z')
    rn_tl = 0._ikind6
    rn = 0.0
  end select
  ray2d_tl(ih1)%c_tl = c_tl
  ray2d(ih1)%c = c
  ray2d_tl(ih1)%tau_tl = ray2d_tl(ih)%tau_tl
  ray2d(ih1)%tau = ray2d(ih)%tau
  ray2d_tl(ih1)%p_tl = ray2d_tl(ih)%p_tl+ray2d_tl(ih)%q_tl*rn+rn_tl*ray2d(ih)%q
  ray2d(ih1)%p = ray2d(ih)%p+ray2d(ih)%q*rn
  ray2d_tl(ih1)%q_tl = ray2d_tl(ih)%q_tl
  ray2d(ih1)%q = ray2d(ih)%q
  select case ( hs%bc )
  case ('R')
    ray2d_tl(ih1)%amp_tl = ray2d_tl(ih)%amp_tl
    ray2d(ih1)%amp = ray2d(ih)%amp
    ray2d_tl(ih1)%phase_tl = ray2d_tl(ih)%phase_tl
    ray2d(ih1)%phase = ray2d(ih)%phase
  case ('V')
    ray2d_tl(ih1)%amp_tl = ray2d_tl(ih)%amp_tl
    ray2d(ih1)%amp = ray2d(ih)%amp
    ray2d_tl(ih1)%phase_tl = ray2d_tl(ih)%phase_tl
    ray2d(ih1)%phase = ray2d(ih)%phase+pi
  case ('F')
    if (th == 0.0 .and. tg == 0.0) then
      rint_tl%theta_tl = 0._ikind5
      rint%theta = 0.0
    else
      rint_tl%theta_tl = 0._ikind4
      rint%theta = rad2deg*abs(atan2(th,tg))
    endif
    if (rint%theta > 90.) then
      rint_tl%theta_tl = -rint_tl%theta_tl
      rint%theta = 180.-rint%theta
    endif
    call interpolatereflectioncoefficient_tl( rint,rint_tl,refc,refc_tl,npts )
    ray2d_tl(ih1)%amp_tl = ray2d_tl(ih)%amp_tl*rint%r+rint_tl%r_tl*ray2d(ih)%amp
    ray2d(ih1)%amp = ray2d(ih)%amp*rint%r
    ray2d_tl(ih1)%phase_tl = ray2d_tl(ih)%phase_tl+rint_tl%phi_tl
    ray2d(ih1)%phase = ray2d(ih)%phase+rint%phi
  case ('A','G')
    kx_tl = tg_tl*afreq
    kx = afreq*tg
    kz_tl = th_tl*afreq
    kz = afreq*th
    if (real(hs%cs) > 0.) then
      kzs2_tl = 2*kx_tl*kx
      kzs2 = kx**2-(afreq/hs%cs)**2
      kzp2_tl = 2*kx_tl*kx
      kzp2 = kx**2-(afreq/hs%cp)**2
      kzs_tl = kzs2_tl/(2._8*sqrt(kzs2))
      kzs = sqrt(kzs2)
      kzp_tl = kzp2_tl/(2._8*sqrt(kzp2))
      kzp = sqrt(kzp2)
      mu = hs%rho*hs%cs**2
      y2_tl = kx_tl*(4*kx*(kzs2+kx**2)-2*(4.0d0*kzs*kzp)*kx)*mu-4*kzp_tl*kzs*kx**2*mu-4*kzs_tl*kzp*kx**2*mu+2*kzs2_tl*(kzs2+kx**2)*mu
      y2 = ((kzs2+kx**2)**2-4.0d0*kzs*kzp*kx**2)*mu
      y4_tl = 2*kx_tl*kzp*kx+kzp_tl*(kx**2-kzs2)-kzs2_tl*kzp
      y4 = kzp*(kx**2-kzs2)
      f_tl = y4_tl*afreq**2
      f = afreq**2*y4
      g_tl = y2_tl
      g = y2
    else
      kzp_tl = 2*kx_tl/(2._8*sqrt(kx**2-(afreq/hs%cp)**2))*kx
      kzp = sqrt(kx**2-(afreq/hs%cp)**2)
      if (real(kzp) == 0. .and. aimag(kzp) < 0.) then
        kzp_tl = -kzp_tl
        kzp = -kzp
      endif
      f_tl = kzp_tl
      f = kzp
      g_tl = (0._ikind3,0._ikind3)
      g = hs%rho
    endif
    refl_tl = (-(f_tl*((rho-(rho*f-onecmplx*kz*g)*rho/(rho*f+onecmplx*kz*g))/(rho*f+onecmplx*kz*g))))+g_tl*((onecmplx*kz+(rho*f-onecmplx*kz*g)*&
&onecmplx*kz/(rho*f+onecmplx*kz*g))/(rho*f+onecmplx*kz*g))+kz_tl*((onecmplx*g+(rho*f-onecmplx*kz*g)*onecmplx*g/(rho*f+onecmplx*kz*g))/(rho*f+&
&onecmplx*kz*g))-rho_tl*((f-(rho*f-onecmplx*kz*g)*f/(rho*f+onecmplx*kz*g))/(rho*f+onecmplx*kz*g))
    refl = -((rho*f-onecmplx*kz*g)/(rho*f+onecmplx*kz*g))
    if (abs(refl) < 1.0e-5) then
      ray2d_tl(ih1)%amp_tl = 0._ikind2
      ray2d(ih1)%amp = 0.0
      ray2d_tl(ih1)%phase_tl = ray2d_tl(ih)%phase_tl
      ray2d(ih1)%phase = ray2d(ih)%phase
    else
      ray2dl = abs(refl)
      ray2d_tl(ih1)%amp_tl = ray2d_tl(ih)%amp_tl*ray2dl+(real(refl)*real(refl_tl)+aimag(refl)*aimag(refl_tl))/abs(refl)*ray2d(ih)%amp
      ray2d(ih1)%amp = ray2dl*ray2d(ih)%amp
      ray2dj = aimag(refl)
      ray2dk = real(refl)
      ray2d_tl(ih1)%phase_tl = ray2d_tl(ih)%phase_tl+ray2dk/(ray2dj**2+ray2dk**2)*aimag(refl_tl)-ray2dj/(ray2dj**2+ray2dk**2)*real(refl_tl)
      ray2d(ih1)%phase = ray2d(ih)%phase+atan2(ray2dj,ray2dk)
      if (beam%type(4:4) == 'S') then
        ch_tl = ray2d_tl(ih)%c_tl/conjg(hs%cp)
        ch = ray2d(ih)%c/conjg(hs%cp)
        co_tl = ray2d_tl(ih)%c_tl*ray2d(ih)%t(1)+ray2d_tl(ih)%t_tl(1)*ray2d(ih)%c
        co = ray2d(ih)%t(1)*ray2d(ih)%c
        si_tl = ray2d_tl(ih)%c_tl*ray2d(ih)%t(2)+ray2d_tl(ih)%t_tl(2)*ray2d(ih)%c
        si = ray2d(ih)%t(2)*ray2d(ih)%c
        ck_tl = -(ray2d_tl(ih)%c_tl*(afreq/ray2d(ih)%c/ray2d(ih)%c))
        ck = afreq/ray2d(ih)%c
        a_tl = -(4*ch_tl*hs%rho*ch)
        a = 2*hs%rho*(1-ch*ch)
        b_tl = (-(2*ch_tl*ch))+2*co_tl*co
        b = co*co-ch*ch
        d_tl = b_tl+2*si_tl*(hs%rho*hs%rho*si)
        d = hs%rho*hs%rho*si*si+b
        sb_tl = b_tl/(2._8*sqrt(b))
        sb = sqrt(b)
        cco_tl = 2*co_tl*co
        cco = co*co
        ssi_tl = 2*si_tl*si
        ssi = si*si
        if (si /= 0.) then
          delta_tl = a_tl*(co/si/(ck*sb*d))-ck_tl*(a*co/si*sb*d/(ck*sb*d)/(ck*sb*d))+co_tl*(a/si/(ck*sb*d))-d_tl*(a*co/si*ck*sb/(ck*sb*d)/(ck*sb*d))-&
&sb_tl*(a*co/si*ck*d/(ck*sb*d)/(ck*sb*d))-si_tl*(a*co/si/si/(ck*sb*d))
          delta = a*co/si/(ck*sb*d)
        else
          delta_tl = (0._ikind1,0._ikind1)
          delta = 0.0
        endif
        pdeltah = real(delta)
        pdelta_tl = co_tl*(pdeltah*(ray2d(ih)%c/co/co)/(ray2d(ih)%c/co)/(ray2d(ih)%c/co))+real(delta_tl)/(ray2d(ih)%c/co)-ray2d_tl(ih)%c_tl*(pdeltah/&
&co/(ray2d(ih)%c/co)/(ray2d(ih)%c/co))
        pdelta = pdeltah/(ray2d(ih)%c/co)
        ddelta_tl = a_tl*((-(1/(ck*sb*d)+cco/ssi/(ck*sb*d)))+cco/(ck*b*sb*d)-co/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si))-b_tl*(a*cco*ck*sb*d/&
&(ck*b*sb*d)/(ck*b*sb*d))+cco_tl*((-(a/ssi/(ck*sb*d)))+a/(ck*b*sb*d))+ck_tl*(a*sb*d/(ck*sb*d)/(ck*sb*d)+a*cco/ssi*sb*d/(ck*sb*d)/(ck*sb*d)-a*&
&cco*b*sb*d/(ck*b*sb*d)/(ck*b*sb*d)+a*co/si*sb*d*d/(ck*sb*d*d)/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si))-co_tl*(a*co/si/(ck*sb*d*d)*(2*hs%&
&rho*hs%rho*si-2*si)+a/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si))+d_tl*(a*ck*sb/(ck*sb*d)/(ck*sb*d)+a*cco/ssi*ck*sb/(ck*sb*d)/(ck*sb*d)-&
&a*cco*ck*b*sb/(ck*b*sb*d)/(ck*b*sb*d)+2*(a*co/si)*ck*sb*d/(ck*sb*d*d)/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si))+sb_tl*(a*ck*d/(ck*sb*d)/&
&(ck*sb*d)+a*cco/ssi*ck*d/(ck*sb*d)/(ck*sb*d)-a*cco*ck*b*d/(ck*b*sb*d)/(ck*b*sb*d)+a*co/si*ck*d*d/(ck*sb*d*d)/(ck*sb*d*d)*(2*hs%rho*hs%rho*&
&si*co-2*co*si))-si_tl*(a*co/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*co-2*co)-a*co/si/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si))+ssi_tl*(a*cco/&
&ssi/ssi/(ck*sb*d))
        ddelta = (-(a/(ck*sb*d)))-a*cco/ssi/(ck*sb*d)+a*cco/(ck*b*sb*d)-a*co/si/(ck*sb*d*d)*(2*hs%rho*hs%rho*si*co-2*co*si)
        rddelta_tl = -real(ddelta_tl)
        rddelta = -real(ddelta)
        sddeltah = abs(rddelta)
        sddelta_tl = rddelta_tl/sddeltah-rddelta_tl*(rddelta/sddeltah/sddeltah)*sign(1._8,rddelta)
        sddelta = rddelta/sddeltah
        theta_bot_tl = tbdry_tl(2)*(1.d0/(1.d0+(tbdry(2)/tbdry(1))**2)/tbdry(1))-tbdry_tl(1)/(1.d0+(tbdry(2)/tbdry(1))**2)*(tbdry(2)/tbdry(1)/&
&tbdry(1))
        theta_bot = datan(tbdry(2)/tbdry(1))
        ray2di = real(delta)
        ray2d_tl(ih1)%x_tl(1) = ray2d_tl(ih1)%x_tl(1)+real(delta_tl)*dcos(theta_bot)-theta_bot_tl*ray2di*dsin(theta_bot)
        ray2d(ih1)%x(1) = ray2d(ih1)%x(1)+ray2di*dcos(theta_bot)
        ray2dh = real(delta)
        ray2d_tl(ih1)%x_tl(2) = ray2d_tl(ih1)%x_tl(2)+real(delta_tl)*dsin(theta_bot)+theta_bot_tl*ray2dh*dcos(theta_bot)
        ray2d(ih1)%x(2) = ray2d(ih1)%x(2)+ray2dh*dsin(theta_bot)
        ray2d_tl(ih1)%tau_tl = pdelta_tl+ray2d_tl(ih1)%tau_tl
        ray2d(ih1)%tau = ray2d(ih1)%tau+pdelta
        ray2d_tl(ih1)%q_tl = c_tl*sddelta*rddelta*si*ray2d(ih)%p+ray2d_tl(ih)%p_tl*sddelta*rddelta*si*c+ray2d_tl(ih1)%q_tl+rddelta_tl*sddelta*si*c*&
&ray2d(ih)%p+sddelta_tl*rddelta*si*c*ray2d(ih)%p+si_tl*sddelta*rddelta*c*ray2d(ih)%p
        ray2d(ih1)%q = ray2d(ih1)%q+sddelta*rddelta*si*c*ray2d(ih)%p
      endif
    endif
  case default
    write(unit=msgbuf,fmt='(2A)') 'HS%BC = ',hs%bc
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
    write(unit=msgbuf,fmt='(A)') 'IHOP Reflect2D: Unknown boundary condition type'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Reflect2D'
  end select
  if (bottop == 'TOP') then
    ray2d(ih+1)%ntopbnc = ray2d(ih)%ntopbnc+1
  else if (bottop == 'BOT') then
    ray2d(ih+1)%nbotbnc = ray2d(ih)%nbotbnc+1
  else
    write(unit=msgbuf,fmt='(2A)') 'IHOP Reflect2D: ','no reflection bounce, but in reflect2d somehow'
    call print_error( msgbuf,mythid )
    stop 'ABNORMAL END: S/R Reflect2D'
  endif

  end subroutine reflect2d_tl
  subroutine traceray2d( xs, alpha, amp0, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_mod, only : istep,nmax
  use bdry_mod, only : atitype,bdry,bot,btytype,getbotseg,gettopseg,isegbot,isegtop,rbotseg,rtopseg,top
  use refcoef, only : nbotpts,ntoppts,rbot,rtop
  use step, only : step2d
  use ihop_mod, only : beam,ismallstepctr,ray2d
  use ssp_mod, only : evalssp,isegr

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: alpha
  real(kind=8), intent(in) :: amp0
  integer, intent(in) :: mythid
  real(kind=8), intent(in) :: xs(2)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: botnint(2)
  real(kind=8) :: bottint(2)
  real(kind=8) :: c
  real(kind=8) :: cimag
  logical :: continue_steps
  real(kind=8) :: crr
  real(kind=8) :: crz
  real(kind=8) :: czz
  real(kind=8) :: declalpha
  real(kind=8) :: declalphaold
  real(kind=8) :: dendbot(2)
  real(kind=8) :: dendtop(2)
  real(kind=8) :: distbegbot
  real(kind=8) :: distbegtop
  real(kind=8) :: distendbot
  real(kind=8) :: distendtop
  logical :: endray =  .false. 
  real(kind=8) :: gradc(2)
  integer :: ih
  integer :: ih1
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: rayt(2)
  real(kind=8) :: raytold(2)
  logical :: rayturn =  .false. 
  logical :: reflect
  real(kind=8) :: rho
  real(kind=8) :: sss
  real(kind=8) :: topnint(2)
  real(kind=8) :: toptint(2)

  ismallstepctr = 0
  c = 0.
  cimag = 0.
  gradc = 0.
  crr = 0.
  crz = 0.
  czz = 0.
  rho = 0.
  call evalssp( xs,c,cimag,gradc,crr,crz,czz,rho,mythid )
  if (c == 0) then
    stop 'ABNORMAL END: S/R TRACERAY2D'
  endif
  ray2d(1)%c = c
  ray2d(1)%x = xs
  ray2d(1)%t = [ cos(alpha),sin(alpha) ]/c
  ray2d(1)%p = [ 1.0,0.0 ]
  if (beam%runtype(2:2) == 'G' .or. beam%runtype(2:2) == 'B') then
    ray2d(1)%q = [ 0.0,0.0 ]
  else
    ray2d(1)%q = [ 0.0,1.0 ]
  endif
  ray2d(1)%tau = 0.0
  ray2d(1)%amp = amp0
  ray2d(1)%phase = 0.0
  ray2d(1)%ntopbnc = 0
  ray2d(1)%nbotbnc = 0
  ray2d(1)%nturnpt = 0
  call gettopseg( xs(1),mythid )
  call getbotseg( xs(1),mythid )
  if (atitype(2:2) == 'L') then
    bdry%top%hs%cp = top(isegtop)%hs%cp
    bdry%top%hs%cs = top(isegtop)%hs%cs
    bdry%top%hs%rho = top(isegtop)%hs%rho
  endif
  if (btytype(2:2) == 'L') then
    bdry%bot%hs%cp = bot(isegbot)%hs%cp
    bdry%bot%hs%cs = bot(isegbot)%hs%cs
    bdry%bot%hs%rho = bot(isegbot)%hs%rho
  endif
  call distances2d( ray2d(1)%x,top(isegtop)%x,bot(isegbot)%x,dendtop,dendbot,top(isegtop)%n,bot(isegbot)%n,distbegtop,distbegbot )
  if (distbegtop <= 0 .or. distbegbot <= 0) then
    beam%nsteps = 1
    write(unit=msgbuf,fmt='(A)') 'WARNING: TraceRay2D: The source is outside the domain boundaries'
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
  else
    ih = 0
    continue_steps =  .true. 
    reflect =  .false. 
    stepping: do istep = 1, nmax-1
      if (continue_steps) then
        ih = ih+1
        ih1 = ih+1
        call step2d( ray2d(ih),ray2d(ih1),top(isegtop)%x,top(isegtop)%n,bot(isegbot)%x,bot(isegbot)%n,mythid )
        if (ih > 1) then
          rayt = ray2d(ih1)%x-ray2d(ih)%x
          raytold = ray2d(ih)%x-ray2d(ih-1)%x
          if (all(rayt == 0.0)) then
            declalpha = 0.0
          else
            declalpha = atan2(rayt(2),rayt(1))
          endif
          if (all(raytold == 0.0)) then
            declalphaold = 0.0
          else
            declalphaold = atan2(raytold(2),raytold(1))
          endif
          rayturn = declalpha <= 0.0d0 .and. declalphaold > 0.0d0 .or. declalpha >= 0.0d0 .and. declalphaold < 0.0d0
          if (rayturn) then
            ray2d(ih1)%nturnpt = ray2d(ih)%nturnpt+1
          endif
        endif
        if (ray2d(ih1)%x(1) < rtopseg(1) .or. ray2d(ih1)%x(1) > rtopseg(2)) then
          call gettopseg( ray2d(ih1)%x(1),mythid )
          if (atitype(2:2) == 'L') then
            bdry%top%hs%cp = top(isegtop)%hs%cp
            bdry%top%hs%cs = top(isegtop)%hs%cs
            bdry%top%hs%rho = top(isegtop)%hs%rho
          endif
        endif
        if (ray2d(ih1)%x(1) < rbotseg(1) .or. ray2d(ih1)%x(1) > rbotseg(2)) then
          call getbotseg( ray2d(ih1)%x(1),mythid )
          if (btytype(2:2) == 'L') then
            bdry%bot%hs%cp = bot(isegbot)%hs%cp
            bdry%bot%hs%cs = bot(isegbot)%hs%cs
            bdry%bot%hs%rho = bot(isegbot)%hs%rho
          endif
        endif
        call distances2d( ray2d(ih1)%x,top(isegtop)%x,bot(isegbot)%x,dendtop,dendbot,top(isegtop)%n,bot(isegbot)%n,distendtop,distendbot )
        if (distbegtop > 0.0d0 .and. distendtop <= 0.0d0) then
          reflect =  .true. 
          if (atitype == 'C') then
            sss = dot_product(dendtop,top(isegtop)%t)/top(isegtop)%len
            toptint = (1-sss)*top(isegtop)%nodet+sss*top(1+isegtop)%nodet
            topnint = (1-sss)*top(isegtop)%noden+sss*top(1+isegtop)%noden
          else
            topnint = top(isegtop)%n
            toptint = top(isegtop)%t
          endif
          call reflect2d( ih,bdry%top%hs,'TOP',toptint,topnint,top(isegtop)%kappa,rtop,ntoppts,mythid )
          call distances2d( ray2d(ih+1)%x,top(isegtop)%x,bot(isegbot)%x,dendtop,dendbot,top(isegtop)%n,bot(isegbot)%n,distendtop,distendbot )
        else if (distbegbot > 0.0d0 .and. distendbot <= 0.0d0) then
          reflect =  .true. 
          if (btytype == 'C') then
            sss = dot_product(dendbot,bot(isegbot)%t)/bot(isegbot)%len
            botnint = (1-sss)*bot(isegbot)%noden+sss*bot(1+isegbot)%noden
            bottint = (1-sss)*bot(isegbot)%nodet+sss*bot(1+isegbot)%nodet
          else
            botnint = bot(isegbot)%n
            bottint = bot(isegbot)%t
          endif
          call reflect2d( ih,bdry%bot%hs,'BOT',bottint,botnint,bot(isegbot)%kappa,rbot,nbotpts,mythid )
          call distances2d( ray2d(ih+1)%x,top(isegtop)%x,bot(isegbot)%x,dendtop,dendbot,top(isegtop)%n,bot(isegbot)%n,distendtop,distendbot )
        else
          reflect =  .false. 
        endif
        write(unit=msgbuf,fmt='(A)') ' '
        if (ray2d(ih+1)%x(1) > beam%box%r) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box%R'
          endray =  .true. 
        else if (ray2d(ih+1)%x(1) < 0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box r=0'
          endray =  .true. 
        else if (ray2d(ih+1)%x(2) > beam%box%z) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box%Z'
          endray =  .true. 
        else if (abs(ray2d(ih+1)%amp) < 0.005) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray lost energy'
          endray =  .true. 
        else if (distbegtop < 0.0 .and. distendtop < 0.0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray escaped top bound'
          endray =  .true. 
        else if (distbegbot < 0.0 .and. distendbot < 0.0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray escaped bot bound'
          endray =  .true. 
        else if (ih >= nmax-3) then
          write(unit=msgbuf,fmt='(2A)') 'WARNING: TraceRay2D: Check storage ','for ray trajectory'
          endray =  .true. 
        else
          write(unit=msgbuf,fmt='(A)')
          endray =  .false. 
        endif
        if (endray) then
          if (ihop_dumpfreq >= 0) then
            call print_message( msgbuf,prtfile,squeeze_right,mythid )
          endif
        endif
        if (index(msgbuf,'TraceRay2D') == 1) then
          beam%nsteps = ih+1
          continue_steps =  .false. 
        else if (index(msgbuf,'WARNING: TraceRay2D') == 1) then
          beam%nsteps = ih
          continue_steps =  .false. 
        else
          continue_steps =  .true. 
        endif
        distbegtop = distendtop
        distbegbot = distendbot
      endif
    end do stepping
  endif
  end subroutine traceray2d
  subroutine traceray2d_tl( xs, alpha, amp0, amp0_tl, mythid )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.11  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use ihop_mod, only : istep,nmax
  use bdry_mod, only : atitype,bdry,bot,btytype,getbotseg,gettopseg,isegbot,isegtop,rbotseg,rtopseg,top
  use refcoef, only : nbotpts,ntoppts,rbot,rtop
  use refcoef, only : rbot_tl,rtop_tl
  use step, only : step2d,step2d_tl
  use ihop_mod, only : beam,ismallstepctr,ray2d
  use ihop_mod, only : ray2d_tl
  use ssp_mod, only : evalssp,evalssp_tl,isegr

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind2 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8
  integer, parameter :: ikind5 = 8
  integer, parameter :: ikind6 = 8
  integer, parameter :: ikind7 = 8
  integer, parameter :: ikind8 = 8
  integer, parameter :: ikind9 = 8
  integer, parameter :: ikinea = 8
  integer, parameter :: ikineb = 8
  integer, parameter :: ikinec = 8
  integer, parameter :: ikined = 8
  integer, parameter :: ikinee = 8
  integer, parameter :: ikinef = 8
  integer, parameter :: ikineg = 8
  integer, parameter :: ikineh = 8
  integer, parameter :: ikinei = 8
  integer, parameter :: ikinej = 8
  integer, parameter :: ikinek = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(in) :: alpha
  real(kind=8), intent(in) :: amp0
  real(kind=8), intent(in) :: amp0_tl
  integer, intent(in) :: mythid
  real(kind=8), intent(in) :: xs(2)

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: botnint(2)
  real(kind=8) :: botnint_tl(2)
  real(kind=8) :: bottint(2)
  real(kind=8) :: bottint_tl(2)
  real(kind=8) :: c
  real(kind=8) :: c_tl
  real(kind=8) :: cimag
  real(kind=8) :: cimagh_tl
  logical :: continue_steps
  real(kind=8) :: crr
  real(kind=8) :: crrh_tl
  real(kind=8) :: crz
  real(kind=8) :: crzh_tl
  real(kind=8) :: czz
  real(kind=8) :: czzh_tl
  real(kind=8) :: declalpha
  real(kind=8) :: declalpha_tl
  real(kind=8) :: declalphaold
  real(kind=8) :: declalphaold_tl
  real(kind=8) :: dendbot(2)
  real(kind=8) :: dendbot_tl(2)
  real(kind=8) :: dendtop(2)
  real(kind=8) :: dendtop_tl(2)
  real(kind=8) :: distbegbot
  real(kind=8) :: distbegbot_tl
  real(kind=8) :: distbegtop
  real(kind=8) :: distbegtop_tl
  real(kind=8) :: distendbot
  real(kind=8) :: distendbot_tl
  real(kind=8) :: distendtop
  real(kind=8) :: distendtop_tl
  logical :: endray =  .false. 
  real(kind=8) :: gradc(2)
  real(kind=8) :: gradch_tl(2)
  integer :: ih
  integer :: ih1
  character(len=max_len_mbuf) :: msgbuf
  real(kind=8) :: ray2dh(2)
  real(kind=8) :: rayt(2)
  real(kind=8) :: rayt_tl(2)
  real(kind=8) :: raytold(2)
  real(kind=8) :: raytold_tl(2)
  logical :: rayturn =  .false. 
  logical :: reflect
  real(kind=8) :: rho
  real(kind=8) :: rhoh_tl
  real(kind=8) :: sss
  real(kind=8) :: sss_tl
  real(kind=8) :: topnint(2)
  real(kind=8) :: topnint_tl(2)
  real(kind=8) :: toptint(2)
  real(kind=8) :: toptint_tl(2)
  real(kind=8) :: xsh_tl(2)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
  ismallstepctr = 0
  c_tl = 0._ikinek
  c = 0.
  cimag = 0.
  gradc = 0.
  crr = 0.
  crz = 0.
  czz = 0.
  rho = 0.
  xsh_tl = 0._ikined
  cimagh_tl = 0._ikinee
  gradch_tl = 0._ikinef
  crrh_tl = 0._ikineg
  crzh_tl = 0._ikineh
  czzh_tl = 0._ikinei
  rhoh_tl = 0._ikinej
  call evalssp_tl( xs,xsh_tl,c,c_tl,cimag,cimagh_tl,gradc,gradch_tl,crr,crrh_tl,crz,crzh_tl,czz,czzh_tl,rho,rhoh_tl,mythid )
  if (c == 0) then
    stop 'ABNORMAL END: S/R TRACERAY2D'
  endif
  ray2d_tl(1)%c_tl = c_tl
  ray2d(1)%c = c
  ray2d_tl(1)%x_tl = 0._ikinec
  ray2d(1)%x = xs
  ray2dh = [ cos(alpha),sin(alpha) ]
  ray2d_tl(1)%t_tl = -(c_tl*(ray2dh/c/c))
  ray2d(1)%t = ray2dh/c
  ray2d_tl(1)%p_tl = 0._ikineb
  ray2d(1)%p = [ 1.0,0.0 ]
  if (beam%runtype(2:2) == 'G' .or. beam%runtype(2:2) == 'B') then
    ray2d_tl(1)%q_tl = 0._ikinea
    ray2d(1)%q = [ 0.0,0.0 ]
  else
    ray2d_tl(1)%q_tl = 0._ikind9
    ray2d(1)%q = [ 0.0,1.0 ]
  endif
  ray2d_tl(1)%tau_tl = (0._ikind8,0._ikind8)
  ray2d(1)%tau = 0.0
  ray2d_tl(1)%amp_tl = amp0_tl
  ray2d(1)%amp = amp0
  ray2d_tl(1)%phase_tl = 0._ikind7
  ray2d(1)%phase = 0.0
  ray2d(1)%ntopbnc = 0
  ray2d(1)%nbotbnc = 0
  ray2d(1)%nturnpt = 0
  call gettopseg( xs(1),mythid )
  call getbotseg( xs(1),mythid )
  if (atitype(2:2) == 'L') then
    bdry%top%hs%cp = top(isegtop)%hs%cp
    bdry%top%hs%cs = top(isegtop)%hs%cs
    bdry%top%hs%rho = top(isegtop)%hs%rho
  endif
  if (btytype(2:2) == 'L') then
    bdry%bot%hs%cp = bot(isegbot)%hs%cp
    bdry%bot%hs%cs = bot(isegbot)%hs%cs
    bdry%bot%hs%rho = bot(isegbot)%hs%rho
  endif
  call distances2d_tl( ray2d(1)%x,ray2d_tl(1)%x_tl,top(isegtop)%x,bot(isegbot)%x,dendtop,dendtop_tl,dendbot,dendbot_tl,top(isegtop)%n,bot(isegbot)%n,&
&distbegtop,distbegtop_tl,distbegbot,distbegbot_tl )
  if (distbegtop <= 0 .or. distbegbot <= 0) then
    beam%nsteps = 1
    write(unit=msgbuf,fmt='(A)') 'WARNING: TraceRay2D: The source is outside the domain boundaries'
    if (ihop_dumpfreq >= 0) then
      call print_message( msgbuf,prtfile,squeeze_right,mythid )
    endif
  else
    ih = 0
    continue_steps =  .true. 
    reflect =  .false. 
    stepping1: do istep = 1, nmax-1
      if (continue_steps) then
        ih = ih+1
        ih1 = ih+1
        call step2d_tl( ray2d(ih),ray2d_tl(ih),ray2d(ih1),ray2d_tl(ih1),top(isegtop)%x,top(isegtop)%n,bot(isegbot)%x,bot(isegbot)%n,mythid )
        if (ih > 1) then
          rayt_tl = (-ray2d_tl(ih)%x_tl)+ray2d_tl(ih1)%x_tl
          rayt = ray2d(ih1)%x-ray2d(ih)%x
          raytold_tl = (-ray2d_tl(ih-1)%x_tl)+ray2d_tl(ih)%x_tl
          raytold = ray2d(ih)%x-ray2d(ih-1)%x
          if (all(rayt == 0.0)) then
            declalpha_tl = 0._ikind6
            declalpha = 0.0
          else
            declalpha_tl = rayt_tl(2)*(rayt(1)/(rayt(2)**2+rayt(1)**2))-rayt_tl(1)*(rayt(2)/(rayt(2)**2+rayt(1)**2))
            declalpha = atan2(rayt(2),rayt(1))
          endif
          if (all(raytold == 0.0)) then
            declalphaold_tl = 0._ikind5
            declalphaold = 0.0
          else
            declalphaold_tl = raytold_tl(2)*(raytold(1)/(raytold(2)**2+raytold(1)**2))-raytold_tl(1)*(raytold(2)/(raytold(2)**2+raytold(1)**2))
            declalphaold = atan2(raytold(2),raytold(1))
          endif
          rayturn = declalpha <= 0.0d0 .and. declalphaold > 0.0d0 .or. declalpha >= 0.0d0 .and. declalphaold < 0.0d0
          if (rayturn) then
            ray2d(ih1)%nturnpt = ray2d(ih)%nturnpt+1
          endif
        endif
        if (ray2d(ih1)%x(1) < rtopseg(1) .or. ray2d(ih1)%x(1) > rtopseg(2)) then
          call gettopseg( ray2d(ih1)%x(1),mythid )
          if (atitype(2:2) == 'L') then
            bdry%top%hs%cp = top(isegtop)%hs%cp
            bdry%top%hs%cs = top(isegtop)%hs%cs
            bdry%top%hs%rho = top(isegtop)%hs%rho
          endif
        endif
        if (ray2d(ih1)%x(1) < rbotseg(1) .or. ray2d(ih1)%x(1) > rbotseg(2)) then
          call getbotseg( ray2d(ih1)%x(1),mythid )
          if (btytype(2:2) == 'L') then
            bdry%bot%hs%cp = bot(isegbot)%hs%cp
            bdry%bot%hs%cs = bot(isegbot)%hs%cs
            bdry%bot%hs%rho = bot(isegbot)%hs%rho
          endif
        endif
        call distances2d_tl( ray2d(ih1)%x,ray2d_tl(ih1)%x_tl,top(isegtop)%x,bot(isegbot)%x,dendtop,dendtop_tl,dendbot,dendbot_tl,top(isegtop)%n,&
&bot(isegbot)%n,distendtop,distendtop_tl,distendbot,distendbot_tl )
        if (distbegtop > 0.0d0 .and. distendtop <= 0.0d0) then
          reflect =  .true. 
          if (atitype == 'C') then
            sss_tl = dot_product(dendtop_tl,top(isegtop)%t)/top(isegtop)%len
            sss = dot_product(dendtop,top(isegtop)%t)/top(isegtop)%len
            toptint_tl = sss_tl*((-top(isegtop)%nodet)+top(1+isegtop)%nodet)
            toptint = (1-sss)*top(isegtop)%nodet+sss*top(1+isegtop)%nodet
            topnint_tl = sss_tl*((-top(isegtop)%noden)+top(1+isegtop)%noden)
            topnint = (1-sss)*top(isegtop)%noden+sss*top(1+isegtop)%noden
          else
            topnint_tl = 0._ikind2
            topnint = top(isegtop)%n
            toptint_tl = 0._ikind1
            toptint = top(isegtop)%t
          endif
          call reflect2d_tl( ih,bdry%top%hs,'TOP',toptint,toptint_tl,topnint,topnint_tl,top(isegtop)%kappa,rtop,rtop_tl,ntoppts,mythid )
          call distances2d_tl( ray2d(ih+1)%x,ray2d_tl(ih+1)%x_tl,top(isegtop)%x,bot(isegbot)%x,dendtop,dendtop_tl,dendbot,dendbot_tl,top(isegtop)%n,&
&bot(isegbot)%n,distendtop,distendtop_tl,distendbot,distendbot_tl )
        else if (distbegbot > 0.0d0 .and. distendbot <= 0.0d0) then
          reflect =  .true. 
          if (btytype == 'C') then
            sss_tl = dot_product(dendbot_tl,bot(isegbot)%t)/bot(isegbot)%len
            sss = dot_product(dendbot,bot(isegbot)%t)/bot(isegbot)%len
            botnint_tl = sss_tl*((-bot(isegbot)%noden)+bot(1+isegbot)%noden)
            botnint = (1-sss)*bot(isegbot)%noden+sss*bot(1+isegbot)%noden
            bottint_tl = sss_tl*((-bot(isegbot)%nodet)+bot(1+isegbot)%nodet)
            bottint = (1-sss)*bot(isegbot)%nodet+sss*bot(1+isegbot)%nodet
          else
            botnint_tl = 0._ikind4
            botnint = bot(isegbot)%n
            bottint_tl = 0._ikind3
            bottint = bot(isegbot)%t
          endif
          call reflect2d_tl( ih,bdry%bot%hs,'BOT',bottint,bottint_tl,botnint,botnint_tl,bot(isegbot)%kappa,rbot,rbot_tl,nbotpts,mythid )
          call distances2d_tl( ray2d(ih+1)%x,ray2d_tl(ih+1)%x_tl,top(isegtop)%x,bot(isegbot)%x,dendtop,dendtop_tl,dendbot,dendbot_tl,top(isegtop)%n,&
&bot(isegbot)%n,distendtop,distendtop_tl,distendbot,distendbot_tl )
        else
          reflect =  .false. 
        endif
        write(unit=msgbuf,fmt='(A)') ' '
        if (ray2d(ih+1)%x(1) > beam%box%r) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box%R'
          endray =  .true. 
        else if (ray2d(ih+1)%x(1) < 0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box r=0'
          endray =  .true. 
        else if (ray2d(ih+1)%x(2) > beam%box%z) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray left Box%Z'
          endray =  .true. 
        else if (abs(ray2d(ih+1)%amp) < 0.005) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray lost energy'
          endray =  .true. 
        else if (distbegtop < 0.0 .and. distendtop < 0.0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray escaped top bound'
          endray =  .true. 
        else if (distbegbot < 0.0 .and. distendbot < 0.0) then
          write(unit=msgbuf,fmt='(A)') 'TraceRay2D: ray escaped bot bound'
          endray =  .true. 
        else if (ih >= nmax-3) then
          write(unit=msgbuf,fmt='(2A)') 'WARNING: TraceRay2D: Check storage ','for ray trajectory'
          endray =  .true. 
        else
          write(unit=msgbuf,fmt='(A)')
          endray =  .false. 
        endif
        if (endray) then
          if (ihop_dumpfreq >= 0) then
            call print_message( msgbuf,prtfile,squeeze_right,mythid )
          endif
        endif
        if (index(msgbuf,'TraceRay2D') == 1) then
          beam%nsteps = ih+1
          continue_steps =  .false. 
        else if (index(msgbuf,'WARNING: TraceRay2D') == 1) then
          beam%nsteps = ih
          continue_steps =  .false. 
        else
          continue_steps =  .true. 
        endif
        distbegtop_tl = distendtop_tl
        distbegtop = distendtop
        distbegbot_tl = distendbot_tl
        distbegbot = distendbot
      endif
    end do stepping1
  endif

  end subroutine traceray2d_tl
end module     ihop
