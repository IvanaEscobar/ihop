#include "IHOP_OPTIONS.h"
!BOP
! !INTERFACE:
MODULE atten_mod
  ! <CONTACT EMAIL="ivana@utexas.edu">
  !   Ivana Escobar
  ! </CONTACT>

  ! Attenuation module
  !  Routines to convert a sound speed and attenuation in user units to a
  !  complex sound speed
  !  Includes a formula for volume attenuation

#ifdef IHOP_WRITE_OUT
  USE ihop_mod, only: PRTFile
#endif
! ! USES
  implicit none
!  == Global variables ==
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#include "IHOP_SIZE.h"
#include "IHOP.h"

  PRIVATE

! public interfaces
!=======================================================================

    public CRCI, T, Salinity, pH, z_bar, iBio, NBioLayers, bio

!=======================================================================

  INTEGER, PARAMETER               :: MaxBioLayers = 200
  INTEGER                          :: iBio, NBioLayers
  ! Francois-Garrison volume attenuation; temperature, salinity, ...
  REAL (KIND=_RL90) :: T = 20, Salinity = 35, pH = 8, z_bar = 0, FG

  TYPE bioStructure
     REAL (KIND=_RL90) :: Z1, Z2, f0, Q, a0
  END TYPE bioStructure

  TYPE( bioStructure ) :: bio( MaxBioLayers )

CONTAINS
  FUNCTION CRCI( z, c, alpha, AttenUnit, beta, fT, myThid )

    ! Converts real wave speed and attenuation to a single
    !  complex wave speed (with positive imaginary part)

    ! AttenUnit
    ! 6 Cases:    N Nepers/meter
    !             M dB/meter      (M for Meters)
    !             m dB/meter with a power law
    !             F dB/m-kHz      (F for frequency dependent)
    !             W dB/wavelength (W for Wavelength)
    !             Q Q
    !             L Loss parameter
    !
    ! second letter adds volume attenuation according to standard laws:
    !             T for Thorp
    !             F for Francois Garrison
    !             B for biological
    !
    ! freq is the current frequency
    ! freq0 is the reference frequency for which the dB/meter was specified
    !  (used only for 'm')

    ! Returns
    ! c     real      part of sound speed
    ! alpha imaginary part of sound speed

    INTEGER, INTENT( IN ) :: myThid
    REAL (KIND=_RL90), INTENT( IN ) :: z, c, alpha, beta, fT
    CHARACTER (LEN=2), INTENT( IN ) :: AttenUnit
    REAL    (KIND=_RL90)            :: f2, afreq, alphaT, Thorp, a, FG
    COMPLEX (KIND=_RL90)            :: CRCI

    afreq = 2.0 * PI * IHOP_freq

    !  Convert to Nepers/m
    alphaT = 0.0
    SELECT CASE ( AttenUnit( 1:1 ) )
      CASE ( 'N' )
         alphaT = alpha
      CASE ( 'M' )   ! dB/m
         alphaT = alpha / 8.6858896D0
      CASE ( 'm' )   ! dB/m with power law
         alphaT = alpha / 8.6858896D0
         IF ( IHOP_freq < fT ) THEN   ! frequency raised to the power beta
            alphaT = alphaT * ( IHOP_freq / IHOP_freq ) ** beta
         ELSE                    ! linear in frequency
            alphaT = alphaT * ( IHOP_freq / IHOP_freq ) * &
                      ( fT / IHOP_freq ) ** ( beta - 1 )
         END IF
      CASE ( 'F' )   ! dB/(m kHz)
         alphaT = alpha * IHOP_freq / 8685.8896D0
      CASE ( 'W' )   ! dB/wavelength
         IF ( c /= 0.0 ) alphaT = alpha * IHOP_freq / ( 8.6858896D0 * c )
         !        The following lines give f^1.25 frequency dependence
         !        FAC = SQRT( SQRT( IHOP_freq / 50.0 ) )
         !        IF ( c /= 0.0 ) alphaT=FAC*alpha*IHOP_freq / ( 8.6858896D0*c )
      CASE ( 'Q' )   ! Quality factor
         IF ( c * alpha /= 0.0 ) alphaT = afreq / ( 2.0 * c * alpha )
      CASE ( 'L' )   ! loss parameter
         IF ( c /= 0.0         ) alphaT = alpha * afreq / c
      CASE DEFAULT
         ! Do nothing
         alphaT = 0.0
         STOP '1 ABNORMAL END: S/R CRCI'
    END SELECT

    ! added volume attenuation
    SELECT CASE ( AttenUnit( 2:2 ) )
      CASE ( 'T' )
         f2 = ( IHOP_freq / 1000.0 ) ** 2

         ! Original formula from Thorp 1967
         ! Thorp = 40.0 * f2 / ( 4100.0+f2 ) + 0.1 * f2 / ( 1.0+f2 )! dB/kyard
         ! Thorp = Thorp / 914.4D0              ! dB / m
         ! Thorp = Thorp / 8.6858896D0          ! Nepers / m

         ! Updated formula from JKPS Eq. 1.34
         Thorp = 3.3d-3 + 0.11 * f2 / ( 1.0+f2 ) + 44.0 * f2 / ( 4100.0+f2 ) &
                 + 3d-4 * f2       ! dB/km
         Thorp = Thorp / 8685.8896 ! Nepers / m

         alphaT = alphaT + Thorp
      CASE ( 'F' )   ! Francois-Garrison
         FG     = Franc_Garr( IHOP_freq / 1000 )   ! dB/km
         FG     = FG / 8685.8896              ! Nepers / m
         alphaT = alphaT + FG
      CASE ( 'B' )   ! biological attenuation per Orest Diachok
         DO iBio = 1, NBioLayers
            IF ( z >= bio( iBio )%Z1 .AND. z <= bio( iBio )%Z2 ) THEN
               a = bio( iBio )%a0 / ( ( 1.0-bio( iBio )%f0**2 &
                   / IHOP_freq**2  )**2 &
                   + 1.0 / bio( iBio )%Q**2 ) ! dB/km
               a = a / 8685.8896              ! Nepers / m
               alphaT = alphaT + a
            END IF
         END DO
      CASE DEFAULT
         ! Do nothing
         alphaT = alphaT
    END SELECT

    ! Convert Nepers/m to equivalent imaginary sound speed
    alphaT = alphaT * c * c / afreq
    CRCI   = CMPLX( c, alphaT, KIND=_RL90 )

    IF ( alphaT > c ) THEN
#ifdef IHOP_WRITE_OUT
       ! In adjoint mode we do not write output besides on the first run
       IF (IHOP_dumpfreq.LT.0) THEN
        WRITE( PRTFile, * ) 'Complex sound speed: ', CRCI
        WRITE( PRTFile, '(2A)' ) 'Usually this means you have an attenuation',&
        'that is way too high'
       ENDIF

       WRITE(errorMessageUnit,'(2A)') 'ATTENMOD CRCI: complex sound speed',&
           'has an imaginary part > real part'
#endif /* IHOP_WRITE_OUT */
       STOP 'ABNORMAL END: S/R CRCI'
    END IF

  RETURN
  END !FUNCTION CRCI

  !**********************************************************************!

  FUNCTION Franc_Garr( f )

    ! Francois Garrison formulas for attenuation
    ! Based on a Matlab version by D. Jackson APL-UW

    ! mbp Feb. 2019
    ! Verified using F-G Table IV

    ! alpha = attenuation   (dB/km)
    ! f     = frequency     (kHz)
    ! T     = temperature   (deg C)
    ! S     = salinity      (psu)
    ! pH    = 7 for neutral water
    ! z_bar = depth         (m)

    !     Returns
    !        alpha = volume attenuation in dB/km

    REAL (KIND=_RL90) :: f, Franc_Garr
    REAL (KIND=_RL90) :: c, A1, A2, A3, P1, P2, P3, f1, f2

    c = 1412 + 3.21 * T + 1.19 * Salinity + 0.0167 * z_bar

    ! Boric acid contribution
    A1 = 8.86 / c * 10**( 0.78 * pH - 5 )
    P1 = 1
    f1 = 2.8 * sqrt( Salinity / 35 ) * 10**( 4 - 1245 / ( T + 273 ) )

    ! Magnesium sulfate contribution
    A2 = 21.44 * Salinity / c * ( 1 + 0.025 * T )
    P2 = 1 - 1.37D-4 * z_bar + 6.2D-9 * z_bar**2
    f2 = 8.17 * 10**( 8 - 1990 / ( T + 273 ) ) / ( 1 + 0.0018*( Salinity - 35 ) )

    ! Viscosity
    P3 = 1 - 3.83D-5 * z_bar + 4.9D-10 * z_bar**2
    if ( T < 20 ) THEN
       A3 = 4.937D-4 - 2.59D-5 * T + 9.11D-7 * T**2 - 1.5D-8  * T**3
    else
       A3 = 3.964D-4 -1.146D-5 * T + 1.45D-7 * T**2 - 6.5D-10 * T**3
    end if

    Franc_Garr = A1 * P1 * ( f1 * f**2 ) / ( f1**2 + f**2 ) &
                 + A2 * P2 * ( f2 * f**2 ) / ( f2**2 + f**2 ) &
                 + A3 * P3 * f**2
  RETURN
  END !FUNCTION Franc_Garr

END !MODULE atten_mod
